' Gambas module file

' Description:
' Execute.module
' Support for getting shell script output in device values.

' Development Status:
' Just started.

' DomotiGa - an open source home automation program.
' Copyright(C) 2008-2011 Ron Klinkien

' Read file called COPYING for license details.

PUBLIC tShell AS Timer
PRIVATE hShell AS Process
PRIVATE cOutput AS NEW Collection

'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
' start timer
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
PUBLIC SUB Run()

  ' start poll timer for Shell
  tShell = NEW Timer AS "tShell"
  tShell.Delay = Main.iShellPollTime * 1000 ' multiply for seconds
  tShell.Start

END

'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
' gets called at each timer event
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
PUBLIC SUB tShell_Timer()

  CheckShell()

END

'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
' find all devices of type Shell and run command to get value(s)
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
PRIVATE SUB CheckShell()

  DIM rResult AS Result
  DIM iInterface AS Integer

  ' get all devices with this devicetype
  rResult = Main.hDB.Exec("SELECT * FROM devices WHERE interface = &1 AND enabled is TRUE", Devices.FindInterface("Shell Interface"))
  IF rResult.Available THEN
    IF rResult.Count >= 1 THEN
      FOR EACH rResult
        IF Main.bShellDebug THEN Main.WriteDebugLog(("[Shell] Getting value(s) for device '") & rResult!name & ("' with command '") & rResult!address & "'.")
        RunShellCommand(rResult!id, rResult!address)
      NEXT
    ELSE
      Main.WriteLog(("Shell: No devices of type shell script found in device table!"))
    ENDIF
  ENDIF

END

'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
' run command to get value(s)
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
PRIVATE SUB RunShellCommand(iId AS Integer, sAddress AS String)

  hShell = EXEC [sAddress] FOR READ AS "Shell"
  hShell.Tag = iId
  cOutput.Add("", iId)

END

'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
' read command output and store it in collection
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
PUBLIC SUB Shell_Read()

  DIM sBuffer AS String
  DIM iId AS Integer

  READ #LAST, sBuffer, -256
  iId = LAST.Tag

  IF cOutput.Exist(iId) THEN cOutput[iId] &= sBuffer

END

'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
' get id and returned value(s) and store them
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
PUBLIC SUB Shell_Kill()

  DIM iId, iRc, iCnt AS Integer
  DIM sOutput, sLine, sValue, sValue2, sValue3, sValue4 AS String

  iId = LAST.Tag
  iRc = LAST.Value

  ' save shell output
  sOutput = cOutput[iId]
  cOutput.Remove(iId)

  SELECT iRC
    CASE 0
      FOR EACH sLine IN Split(sOutput, "\n")
        SELECT iCnt
          CASE 0
            sValue = sLine
          CASE 1
            sValue2 = sLine
          CASE 2
            sValue3 = sLine
          CASE 3
            sValue4 = sLine
        END SELECT
        INC iCnt
      NEXT
      ' debug output
      IF Main.bShellDebug THEN
        Main.WriteDebugLog("[Shell] < '" & sOutput)
        Main.WriteDebugLog(("[Shell] Device with id '") & iId & ("' returned value(s)") & IIf(sValue, " '" & sValue & "'", "") & IIf(sValue2, " '" & sValue2 & "'", "") & IIf(sValue3, " '" & sValue3 & "'", "") & IIf(sValue4, " '" & sValue4 & "'", "") & ".")
      ENDIF
      ' find and update device
      Devices.CheckFirstSeen(iId)
      Devices.ValueUpdate(iId, sValue, sValue2, sValue3, sValue4)
    CASE 127
      IF Main.bShellDebug THEN Main.WriteDebugLog(("[Shell] Command of device with id '") & iId & ("' not found!"))
    CASE ELSE
      IF Main.bShellDebug THEN Main.WriteDebugLog(("[Shell] Device with id '") & iId & ("' returned unknown shell error '" & iRc & "'"))
    END SELECT

CATCH
  Main.WriteDebugLog(("ERROR: Parsing Shell Result: ") & Error.Text & " at " & Error.Where)

END
