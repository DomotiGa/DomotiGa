' Gambas class file

' Description:
' CCUL.class
' Connect to CULFW interface via tcp socket or serial port.

' Development Status:
' Just started.

' DomotiGa - an open source home automation program.
' Copyright(C) 2008-2011 Ron Klinkien

' Read file called COPYING for license details.

PROPERTY TCPHost AS String
PROPERTY TCPPort AS Integer
PROPERTY Interface AS String
PROPERTY SerPort AS String
PROPERTY Baud AS String
PROPERTY CULDebug AS Boolean
PROPERTY Model AS Integer
PROPERTY FHTid AS String
PROPERTY AutoCreate AS Boolean

PRIVATE sTCPHost AS String
PRIVATE iTCPPort AS Integer
PRIVATE sInterface AS String
PRIVATE sSerPort AS String
PRIVATE sBaud AS String
PRIVATE bCULDebug AS Boolean
PRIVATE iModel AS Integer
PRIVATE sFHTid AS String
PRIVATE bAutoCreate AS Boolean

PUBLIC hCUL AS NEW Socket
PUBLIC hCULSer AS NEW SerialPort
PUBLIC bSimulate AS Boolean = FALSE
PUBLIC tCULBusy AS Timer
PUBLIC tCULLed AS Timer
PUBLIC tCULConnect AS Timer
PUBLIC tCULPoll AS Timer

PRIVATE bFirstByte AS Boolean = TRUE
PRIVATE RecBuf AS Byte[255]
PRIVATE bMessage AS Boolean = FALSE
PRIVATE iByteCount AS Integer = 0
PRIVATE cQueue AS NEW Collection  ' command buffer
PRIVATE bCULBusy AS Boolean  ' waiting for delay timer to finish
PRIVATE iConnectRetry AS Integer = 0 ' retries
PRIVATE iConnectDelay AS Integer = 60000 ' 1 minute
PRIVATE cLowTemps AS NEW Collection ' to store FHT low temp byte

' FS20
PRIVATE sFS20Values AS String[] = ["Off", "Dim 6", "Dim 12", "Dim 18", "Dim 25", "Dim 31", "Dim 37", "Dim 43", "Dim 50", "Dim 56", "Dim 62", "Dim 68", "Dim 75", "Dim 81", "Dim 87", "Dim 93", "Dim 100", "On", "Toggle", "DimUp", "DimDown", "DimUpDown", "Timer", "SendState", "Off-For-Timer", "On-For-Timer", "On-Old-For-Timer", "Reset", "Ramp-On-Time", "Ramp-Of-Time", "On-Old-For-Timer-Prev", "On-100-For-Timer-Prev"]

' FHT not used yet
' CONST FHT_SYNCTIME AS Byte = &H2C
' CONST FHT_MODE AS Byte = &H3D
' CONST FHT_DESIREDTEMP AS Byte = &H41
' CONST FHT_STATUS AS Byte = &H44
' CONST FHT_DAYTEMP AS Byte = &H82
' CONST FHT_NIGHTTEMP AS Byte = &H84
' CONST FHT_WINDOWOPENTEMP AS Byte = &H8A

PUBLIC SUB CUL_Ready()

  Main.WriteLog(("CUL TCP socket connected."))
  Init()
  tCULPoll.Start

END

'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
' temp poll routine to see if CUL socket stays active
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
PUBLIC SUB tCULPoll_Timer()

 ' get version
  QueueCommand("V")

END

'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
' reconnect routine
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
PUBLIC SUB tCULConnect_Timer()

  IF NOT ConnectTCP() THEN
    INC iConnectRetry
    iConnectDelay *= iConnectRetry
    tCULConnect.Delay = iConnectDelay
  ENDIF

END

PUBLIC SUB CUL_Closed()

  Main.WriteDebugLog(("[CUL] ERROR: TCP socket closed by peer."))
  IF iConnectRetry < 6 THEN
    Main.WriteDebugLog(("[CUL] Retry to connect" & IIf(iConnectRetry, " in " & (iConnectDelay / 60) & " minutes.", ".")))
    tCULConnect.Start
  ENDIF

END

PUBLIC SUB CUL_Found()

  Main.WriteLog(("CUL IP address resolved."))

END

'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
' connect to the host:port
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
PUBLIC FUNCTION ConnectTCP() AS Boolean

  ' try to close the connection
  TRY hCUL.Close

  ' get a new one
  hCUL = NEW Socket AS "CUL"
  hCUL.Connect(sTCPHost, iTCPPort)

  tCULPoll = NEW Timer AS "tCULPoll"
  tCULPoll.Delay = 60 * 1000

  ' all ok
  RETURN TRUE

CATCH ' some errors
  Main.WriteLog(("CUL Error: ") & ERROR.Text)
  RETURN FALSE

END

'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
' connect to the serial port
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
PUBLIC FUNCTION ConnectSerial() AS Boolean

  ' try to close the connection
  TRY hCULSer.Close

  ' get a new one
  hCULSer = NEW Serialport AS "CULSer"
  WITH hCULSer
    .PortName = sSerPort
    .Speed = sBaud
    .Parity = 0
    .DataBits = 8
    .StopBits = 1
    .FlowControl = 0
    .Open()
  END WITH

  Init()

  ' all ok
  RETURN TRUE

CATCH ' some errors
  Main.WriteLog(("CUL Error: ") & ERROR.Text)
  RETURN FALSE

END

'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
' disconnect from the host
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
PUBLIC FUNCTION Disconnect() AS Boolean

  ' try to close the connection
  TRY tCULBusy.Stop
  TRY tCULLed.Stop
  TRY tCULPoll.Stop
  TRY tCULConnect.Stop
  TRY hCUL.Close
  TRY hCULSer.Close

  IF InStr(sInterface, "tcp") THEN
    Main.WriteLog(("CUL TCP socket close."))
  ELSE
    Main.WriteLog(("CUL serial port close."))
  END IF
  ' all ok
  RETURN TRUE

CATCH ' some errors
  Main.WriteLog(("CUL Error: ") & ERROR.Text)
  RETURN FALSE

END

'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
' reset led status in main status bar
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
PUBLIC SUB tCULLED_Timer()

  Main.ControlLed("CUL", "Off")
  tCULLED.Stop

END

PUBLIC SUB CUL_Error()

  DIM sString AS String = "CUL: "

  ' handle error
  SELECT CASE hCUL.Status
    CASE Net.CannotCreateSocket
      Main.WriteLog(sString & ("The system does not allow to create a socket."))
    CASE Net.HostNotFound
      Main.WriteLog(sString & ("Host '") & sTCPHost & ("' not found."))
    CASE Net.ConnectionRefused
      Main.WriteLog(sString & ("Unable to connect. Connection refused."))
    CASE Net.CannotRead
      Main.WriteLog(sString & ("Error reading data."))
    CASE Net.CannotWrite
      Main.WriteLog(sString & ("Error writing data."))
  END SELECT

END

PUBLIC SUB CUL_Read()

  DIM bData AS Byte

  TRY READ #hCUL, bData
  IF ERROR THEN Main.WriteDebugLog(("[CUL] Error reading data from the TCP port! -> ") & Error.Text)
  ProcessReceivedChar(bData)

END

PUBLIC SUB CULSer_Read()

  DIM bData AS Byte

  TRY READ #hCULSer, bData
  IF ERROR THEN Main.WriteDebugLog(("[CUL] Error reading data from the serial port! -> ") & Error.Text)
  ProcessReceivedChar(bData)

END

'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
' control devices
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
PUBLIC SUB SendCommand(sAddress AS String, sCmd AS String)

  DIM iDeviceId AS Integer
  DIM sType AS String

  ' find out what kind of device we are dealing with
  iDeviceId = Devices.Find(sAddress, Devices.FindInterface("CUL Interface"))
  IF iDeviceId THEN
    sType = Devices.FindTypeForDevice(iDeviceId)
  ELSE
    RETURN
  ENDIF

  ' select which routine to use
  SELECT sType
    CASE "FS20"
      PrepareFS20Command(sAddress, sCmd)
    DEFAULT
      Main.WriteDebugLog(("[CUL] Controlling '" & sType & "' devices is not supported in this version!"))
      RETURN
  END SELECT

END

'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
' prepare packet to send to FS20 device
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
PUBLIC SUB PrepareFS20Command(sAddress AS String, sCmd AS String)

  DIM sPacket, sCommand AS String
  DIM aParams AS String[]

  ' F <Hex>
  ' <Hex> is a Hex String of the following form:
  ' hhhhaacc or hhhhaaccee, where
  ' hhhh is the FS20 housecode,
  ' aa is the FS20 device address,
  ' cc is the FS20 command
  ' ee is the FS20 timespec. Note that cc must have the extension bit set.
  ' Example: F12340111

  ' check if address has 3 bytes
  IF (Len(sAddress) <> 6) THEN
    Main.WriteDebugLog(("[CUL] FS20 address has invalid format '" & sAddress & "' we need 3 bytes!"))
    RETURN
  ENDIF

  aParams = Split(sCmd, " ")
  '--- for example ON, OFF
  IF aParams.Count = 1 THEN
    sCommand = CommandtoFS20(aParams[0])
    IF Len(sCommand) = 0 THEN
      Main.WriteDebugLog(("[CUL] Only ON, OFF and DIM are supported in this version!"))
      RETURN
    ENDIF
  '--- for example DIM 1
  ELSE IF aParams.Count = 2 THEN
    IF UCase(aParams[0]) = "DIM" THEN
      sCommand = ConvertFS20Dim(aParams[1])
    ELSE
      Main.WriteDebugLog(("[CUL] Invalid command format!"))
      RETURN
    ENDIF
  ENDIF

  ' --- set extended bit ---
  ' IF bAck THEN bCommand = bCommand OR &H20

  sPacket = "F" & sAddress & sCommand
  QueueCommand(sPacket)

END

'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
' add command to queue
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
PUBLIC SUB QueueCommand(sPacket AS String)

  ' add command to queue
  cQueue.Add(sPacket & "\r\n", Rnd)

  ' if interface is not busy process it
  IF bCULBusy = FALSE THEN DoQueue()

END

'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
' process items in queue
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
PUBLIC SUB DoQueue()

  DIM sPacket AS String

  FOR EACH sPacket IN cQueue
    WriteCommand(sPacket, cQueue.Key)
    BREAK ' only do first one
  NEXT

END

'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
' initialize interface
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
PUBLIC FUNCTION Init()

  ' define timer for CUL interface busy
  tCULBusy = NEW Timer AS "tCULBusy"
  tCULBusy.Stop

  ' define timer for CUL status LED
  tCULLed = NEW Timer AS "tCULLED"
  tCULLed.Delay = 500
  tCULLed.Stop

  ' define timer for CUL reconnect
  tCULConnect = NEW Timer AS "tCULConnect"
  tCULConnect.Delay = iConnectRetry
  tCULConnect.Stop

  ' init CUL
  QueueCommand("X21")

  ' set FHTid
  IF Len(sFHTid) AND IF sFHTid <> "0000" THEN
    QueueCommand("T01" & sFHTid)
    IF bCULDebug THEN
      Main.WriteRFXDebugLog("[CUL] Setting FHTid to '" & sFHTid & "' (" & HexToDec(sFHTid) & ")\n")
    ENDIF
  ELSE
    IF bCULDebug THEN Main.WriteRFXDebugLog("[CUL] No FHTid set, value '" & sFHTid & "' is not valid!\n")
  ENDIF

  ' get version
  QueueCommand("V")

  ParseDump()

END

' just here for development/debugging
PUBLIC SUB ParseDump()

  DIM hFile AS File
  DIM sLine AS String

  TRY hFile = OPEN "/home/ron/FHT.txt" FOR INPUT
  IF ERROR THEN RETURN

  WHILE NOT Eof(hFile)
    LINE INPUT #hFile, sLine
    IF Len(sLine) > 5 THEN Simulate(sLine)
  WEND

END

PRIVATE SUB ConvertFS20Dim(iLevel AS Integer) AS String

  RETURN Hex(CInt((iLevel / 6.5) + 1), 2) ' cut 1-99 down to 16 steps

END

'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
' send string to CUL interface
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
PUBLIC SUB WriteCommand(sBuffer AS String, sKey AS String)

  DIM bByte AS Byte
  DIM iCnt AS Integer

  Main.ControlLed("CUL", "On")
  IF Main.bServer THEN tCULLed.Start

  IF sInterface = "tcp" THEN
    ' send the message to the tcp stream
    TRY WRITE #hCUL, sBuffer, Len(sBuffer)
    IF ERROR THEN Main.WriteRFXDebugLog(("[CUL] Unable to write to TCP port! -> ") & Error.Text)
  ELSE
    ' send the message to the serial port
    TRY WRITE #hCULSer, sBuffer, Len(sBuffer)
    IF ERROR THEN Main.WriteRFXDebugLog(("[CUL] Unable to write to serial port! -> ") & Error.Text)
  ENDIF
  IF bCULDebug THEN Main.WriteRFXDebugLog("[CUL] > " & Mid(sBuffer, 1, Len(sBuffer) - 2) & "\n")

  ' remove sent command from queue
  cQueue.Remove(sKey)

  tCULBusy.Delay = 100 ' 100mS
  IF bCULBusy = FALSE THEN bCULBusy = TRUE
  tCULBusy.Start

END

'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
' cul interface busy reset
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
PUBLIC SUB tCULBusy_Timer()

  bCULBusy = FALSE
  tCULBusy.Stop

  IF cQueue.Count THEN ' if there are more commands left in queue, send next one
    IF bCULDebug THEN Main.WriteDebugLog(("[CUL] Sending next command from Queue (count = " & cQueue.Count & ")"))
    DoQueue()
  ENDIF

END

PRIVATE SUB CommandtoFS20(sCmd AS String) AS String

  SELECT UCase(sCmd)
    CASE "OFF"
      RETURN "00"
    CASE "ON"
      RETURN "11"
    DEFAULT
      RETURN ""
  END SELECT

  ' CONST FS20_TOGGLE AS Byte = &H12
  ' CONST FS20_DIMUP AS Byte = &H13
  ' CONST FS20_DIMDOWN AS Byte = &H14
  ' CONST FS20_DIMSWITCH AS Byte = &H15
  ' CONST FS20_TIMER AS Byte = &H16
  ' CONST FS20_SENDSTATE AS Byte = &H17
  ' CONST FS20_OFFFORTIMER AS Byte = &H18
  ' CONST FS20_ONFORTIMER AS Byte = &H19
  ' CONST FS20_ONOLDFORTIMER AS Byte = &H1A
  ' CONST FS20_RESET AS Byte = &H1B
  ' CONST FS20_RAMPONTIME AS Byte = &H1C
  ' CONST FS20_RAMPOFFTIME AS Byte = &H1D

END

'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
' inject packet into parser.
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
PUBLIC SUB Simulate(sPacket AS String)

  DIM iCnt AS Integer

  bSimulate = TRUE
  bFirstByte = TRUE
  IF bCULDebug THEN Main.WriteRFXDebugLog(("[CUL] CUL receiver Simulate String: ") & sPacket & "\n")

  FOR iCnt = 1 TO Len(sPacket)
    ProcessReceivedChar(Asc(Mid(sPacket, iCnt, 1)))
  NEXT
  ProcessReceivedChar(&HD)
  ProcessReceivedChar(&HA)
  bSimulate = FALSE

END SUB

PRIVATE SUB ProcessReceivedChar(bTemp AS Byte)

  IF bFirstByte = TRUE THEN
    bFirstByte = FALSE
    iByteCount = 0
    IF bCULDebug THEN Main.WriteRFXDebugLog("[CUL] < ", 0)
  ENDIF

  Main.ControlLed("CUL", "On")

  TRY RecBuf[iByteCount] = bTemp
  IF ERROR THEN RETURN

  IF bTemp = &HA THEN
    iByteCount -= 2 ' do not count \r\n
    bMessage = TRUE
  ELSE
    IF bCULDebug AND IF (bTemp <> &HD) THEN Main.WriteRFXDebugLog(Chr(bTemp), 1)
    INC iByteCount
  ENDIF

  IF bMessage THEN Display_Message()

END

PRIVATE SUB Display_Message()

  DIM iDeviceId, iCnt, iCmd, iDur, iI, iJ, iRSSI AS Integer
  DIM sHouseCode, sAddress, sValue, sValue2, sCmd, sEMType, sEMCumulValue, sEMPeakValue, sMsgCounter, sBatt, sVal, sId, sSval, sFv AS String
  DIM sWarn, sLowTemp, sSensor, sWindow AS String
  DIM aEMType AS String[] = ["EM1000", "EM1000-S", "EM1000-EM", "EM1000-GZ"]
  DIM aFHTc2m AS String[] = ["Auto", "Manual", "Holiday", "Holiday-Short"]
  DIM bConfirm AS Boolean

  bMessage = FALSE
  bFirstByte = TRUE

  IF bCULDebug THEN Main.WriteRFXDebugLog("\n", 1)

  SELECT CASE Chr(RecBuf[0])
    CASE "F" ' FS20 message
      ' F <Hex>
      ' <Hex> is a hex string with the following format:
      ' hhhhaacc or hhhhaaccee, where
      ' hhhh is the FS20 housecode
      ' aa is the FS20 device address
      ' cc is the FS20 command
      ' ee is the FS20 timespec. Note that cc must have the extension bit set.
      ' Example: F12340111

      ' check for valid packet size
      IF iByteCount < 9 OR IF iByteCount > 12 THEN
        IF bCULDebug THEN Main.WriteDebugLog(("[CUL] FS20 message received with invalid length of " & iByteCount & " bytes!"))
        RETURN
      ENDIF

      sHouseCode = Chr(RecBuf[1]) & Chr(RecBuf[2]) & Chr(RecBuf[3]) & Chr(RecBuf[4])
      sAddress = Chr(RecBuf[5]) & Chr(RecBuf[6])
      iCmd = Val("&H" & Chr(RecBuf[7]) & Chr(RecBuf[8]))

      ' signal
      IF iByteCount > 11 THEN
        iRSSI = Val("&H" & Chr(RecBuf[11]) & Chr(RecBuf[12]))
      ELSE
        iRSSI = Val("&H" & Chr(RecBuf[9]) & Chr(RecBuf[10]))
      ENDIF

      ' calculate duration if extension bit is set
      IF (iCmd AND &H20) THEN
        iDur = Val("&H" & Chr(RecBuf[9]) & Chr(RecBuf[10]))
        iI = (iDur AND &HF0) / 16
        iJ = (iDur AND &HF)
        iDur = (iI ^ 2) * iJ * 0.25

        ' calculate cmd
        iCmd = iCmd XOR &H20
      ENDIF

      ' test if cmd value is known
      TRY sVal = sFS20Values[iCmd]
      IF NOT ERROR THEN
        IF bCULDebug THEN Main.WriteDebugLog(("[CUL] FS20 message received with address '") & sHouseCode & sAddress & "' (" & Hex2Four(sHouseCode & sAddress) & ") and command '" & sVal & "'" & IIf(iDur, " duration " & iDur, "") & IIf(iRSSI, " RSSI: " & iRSSI, ""))
        ' move some values around if needed
        IF iCmd < 18 THEN ' Off, Dim, On
          sValue = sVal
          sValue2 = " "
        ELSE IF iCmd = 24 ' Off-For-Timer
          sValue = "Off"
          sValue2 = sVal
        ELSE IF iCmd = 25 ' On-For-Timer
          sValue = "On"
          sValue2 = sVal
        ELSE
          sValue = ""
          sValue2 = sVal
        ENDIF
        ' find device id
        iDeviceId = Devices.Find(sHouseCode & sAddress, Devices.FindInterface("CUL Interface"), "FS20")
        IF iDeviceId THEN Devices.ValueUpdate(iDeviceId, sValue, sValue2, "", "")
      ELSE
        IF bCULDebug THEN Main.WriteDebugLog(("[CUL] FS20 message received with address '") & sHouseCode & sAddress & "' (" & Hex2Four(sHouseCode & sAddress) & ") and unknown/invalid command '" & Hex(iCmd) & "'")
      ENDIF
    CASE "T" ' FHT messages
      ' check for valid packet size
      IF iByteCount < 9 OR IF iByteCount > 13 THEN
        IF bCULDebug THEN Main.WriteDebugLog(("[CUL] FHT message received with invalid length of " & iByteCount & " bytes!"))
        RETURN
      ENDIF

      sAddress = Chr(RecBuf[1]) & Chr(RecBuf[2]) & Chr(RecBuf[3]) & Chr(RecBuf[4]) & Chr(RecBuf[5]) & Chr(RecBuf[6])
      iCmd = Val("&H" & Chr(RecBuf[7]) & Chr(RecBuf[8]))
      IF iByteCount = 10 THEN ' must be FHT FTK sensor
        ' T <Hex>
        ' <Hex> is a hex string with the following format:
        ' ccccccxx
        ' where cccccc being the id of the sensor in hex
        ' xx being the current status like 'open,close,sync,test,battlow'
        SELECT CASE iCmd
          CASE &H02, &H82
            sValue = "Closed"
            sBatt = "Ok"
          CASE &H01, &H81
            sValue = "Open"
            sBatt = "Ok"
          CASE &H11, &H91
            sValue = "Open"
            sBatt = "Low"
          CASE &H12, &H92
            sValue = "Closed"
            sBatt = "Low"
          CASE &H0C
            sValue2 = "Sync:Syncing"
          CASE &H0F
            sValue2 = "Test:Success"
        END SELECT

        IF bCULDebug THEN Main.WriteDebugLog(("[CUL] FHT TFK message received with address '") & sHouseCode & sAddress & "', status '" & IIf(Len(sValue2), sValue2, sValue) & "' and battery level '" & sBatt & "'")
        ' find device id
        iDeviceId = Devices.Find(sHouseCode & sAddress, Devices.FindInterface("CUL Interface"), "FHTTFK")
        IF iDeviceId THEN
          ' update values
          Devices.ValueUpdate(iDeviceId, sValue, sValue2, "", "")
          ' store battery status
          IF (Len(sBatt) > 1) THEN Devices.Battery(iDeviceId, sBatt)
        ENDIF
      ELSE ' FHT80 message
        ' T15157D671216
        ' T15177E7712FA
        ' T5A334369001A
        ' T <Hex>
        ' <Hex> is a hex string with the following format:
        ' Thhhhccnnvvxx
        ' hhhh = address
        ' cc = command
        ' nn = report value / id
        ' vv = value
        ' xx = rssi
        sAddress = Chr(RecBuf[1]) & Chr(RecBuf[2]) & Chr(RecBuf[3]) & Chr(RecBuf[4])
        iCmd = Val("&H" & Chr(RecBuf[5]) & Chr(RecBuf[6]))
        sCmd = FHTCode(iCmd)

        IF iByteCount > 9 THEN
          sVal = Val("&H" & (Chr(RecBuf[9]) & Chr(RecBuf[10])))
        ELSE IF iByteCount < 9 THEN
          sCmd = "FHT short message"
          sVal = ""
        ENDIF

        IF iByteCount > 11 THEN
          ' rssi
          iRSSI = Val("&H" & Chr(RecBuf[11]) & Chr(RecBuf[12]))
        ENDIF

        IF sCmd = "Report1" OR IF sCmd = "Report2" THEN
          sVal = Val("&H" & (Chr(RecBuf[7]) & Chr(RecBuf[8])))
          bConfirm = TRUE
        ENDIF

        IF InStr(sCmd, "-From") OR IF InStr(sCmd, "-To") THEN ' time format
          sVal = Format(Val(sVal) / 6, "0#") & ":" & Format((Val(sVal) MOD 6) * 10, "0#")
        ELSE IF sCmd = "Mode" ' auto, manual, holiday, holiday-short
          sVal = aFHTc2m[sVal]
        ELSE IF InStr(sCmd, "-Temp")
          sVal = sVal / 2
          sVal = Format(sVal, "#.0")
        ELSE IF sCmd = "Lowtemp-Offset"
          sVal = Format(sVal, "#.0")
        ELSE IF InStr(sCmd, "Actuator")
          sSval = Chr(RecBuf[7]) & Chr(RecBuf[8])
          sFv = Format((100 * Val(sVal) / 255), "#")
          sId = Chr(RecBuf[8])
          IF sSval = "A0" OR IF sSval = "B0" THEN
            sVal = sFv ' sync in the summer
          ELSE IF Right(sSval, 1) = "0" THEN
            sVal = "SyncNow"
          ELSE IF Right(sSval, 1) = "1" THEN
            sVal = "99%" ' FHT set to 30.5, FHT80B="ON"
          ELSE IF Right(sSval, 1) = "2" THEN
            sVal = "0%" ' FHT set to 5.5
          ELSE IF Right(sSval, 1) = "6" THEN
            sVal = sFv
          ELSE IF Right(sSval, 1) = "8" THEN
            sVal = "Offset: " & sFv
          ELSE IF sSval = "2A" OR IF sSval = "3A" THEN
            sVal = "Lime-Protection"
          ELSE IF sSval = "AA" OR IF sSval = "BA" THEN
            sVal = sFv ' lime protection bug
          ELSE IF Right(sSval, 1) = "C" THEN
            sVal = Val(sVal) / 2 - 1.5
            sVal = "SyncTime: " & Str(sVal)
          ELSE IF Right(sSval, 1) = "E" THEN
            sVal = "Test"
          ELSE IF Right(sSval, 1) = "F" THEN
            sVal = "Pair"
          ELSE
            sVal = "Unknown"
          ENDIF

          IF InStr(sVal, "%") AND IF sId = 0 THEN
            IF bCULDebug THEN Main.WriteDebugLog(("[CUL] Position " & sId & " " & sVal))
          ENDIF
        ELSE IF sCmd = "Measured-Low"
          cLowTemps[sAddress] = sVal
        ELSE IF sCmd = "Measured-High"
          TRY sLowTemp = cLowTemps[sAddress]
          IF NOT ERROR THEN
            sVal = (sVal * 256) + sLowTemp
            sVal /= 10
            sCmd = "Measured-Temp"
          ENDIF
        ELSE IF sCmd = "Warnings"
          IF (sVal AND 1) THEN
            sWarn = "Battery low"
            sBatt = "Low"
          ENDIF
          IF (sVal AND 2) THEN
            IF sWarn THEN sWarn &= "; "
            sWarn &= "Temp too low"
            sLowTemp = "Warn"
          ENDIF
          IF (sVal AND 32) THEN
            IF sWarn THEN sWarn &= "; "
            sWarn &= "Window open"
            sWindow = "Open"
          ENDIF
          IF (sVal AND 16) THEN
            IF sWarn THEN sWarn &= "; "
            sWarn &= "Window sensor fault"
            sSensor = "Fault"
          ENDIF
          ' default value if not set
          IF NOT Len(sBatt) THEN sBatt = "Ok"
          IF NOT Len(sLowTemp) THEN sLowTemp = "Ok"
          IF NOT Len(sWindow) THEN sWindow = "Closed"
          IF NOT Len(sSensor) THEN sSensor = "Ok"
          IF NOT Len(sWarn) THEN sWarn = "None"
        ENDIF
        IF bCULDebug THEN
          Main.WriteDebugLog(("[CUL] FHT message received with address '") & sAddress & "' (" & HexToDec(sAddress) & ") command '" & sCmd & "' (" & Hex(iCmd) & ") value '" & sVal & "'" & IIf(iRSSI, " RSSI: " & iRSSI, ""))
          IF sCmd = "Warnings" THEN Main.WriteDebugLog(("[CUL] Warnings: " & sWarn & ", Battery: " & sBatt & " LowTemp: " & sLowTemp & " Sensor: " & sSensor & " Window: " & sWindow))
        ENDIF
        ' find device id
        iDeviceId = Devices.Find(sAddress, Devices.FindInterface("CUL Interface"), "FHT80")
        IF iDeviceId THEN
          IF sCmd = "Measured-Temp" THEN
            ' update values
            Devices.ValueUpdate(iDeviceId, sVal, "", "", "")
          ELSE IF sCmd = "Desired-Temp" THEN
            Devices.ValueUpdate(iDeviceId, "", sVal, "", "")
          ELSE IF InStr(sCmd, "Actuator") THEN
            Devices.ValueUpdate(iDeviceId, "", "", sVal, "")
          ' ELSE
          '   Devices.ValueUpdate(iDeviceId, "", "", "", sVal)
          ENDIF
          ' store battery status
          IF (Len(sBatt) > 1) THEN Devices.Battery(iDeviceId, sBatt)
        ENDIF
      ENDIF
    CASE "E"
      ' E <Hex>
      ' EM message. <Hex> is a hex string with the following format:
      ' Ettaacc111122223333
      ' tt: type 01 = EM-1000S, 02 = EM-1000EM, 03 = EM-1000GZ
      ' aa: address, depending on the type above 01: 01-04, 02: 05-08, 03: 09-12
      ' cc: counter, will be incremented by one for each message
      ' 1111: cumulated value
      ' 2222: last value(not set for type 2)
      ' 3333: top value(not set for type 2)
      sEMType = Chr(RecBuf[1]) & Chr(RecBuf[2])
      sAddress = Chr(RecBuf[3]) & Chr(RecBuf[4])
      sEMCumulValue = Chr(RecBuf[7]) & Chr(RecBuf[8]) & Chr(RecBuf[9]) & Chr(RecBuf[10])
      sMsgCounter = Chr(RecBuf[5]) & Chr(RecBuf[6])
      TRY sValue = Chr(RecBuf[11]) & Chr(RecBuf[12]) & Chr(RecBuf[13]) & Chr(RecBuf[14])
      TRY sEMPeakValue = Chr(RecBuf[15]) & Chr(RecBuf[16]) & Chr(RecBuf[17]) & Chr(RecBuf[18])

      IF bCULDebug THEN Main.WriteDebugLog(("[CUL] EM message received sensor '") & aEMType[Val(sEMType)] & "' [" & sEMType & "]" & " with address '" & sAddress & "' cumulated value: " & sEMCumulValue & (" last: ") & sValue & (" top: ") & sEMPeakValue & (" msg count: ") & Val("&H" & sMsgCounter))
      iDeviceId = Devices.Find(sAddress, Devices.FindInterface("CUL Interface"), aEMType[Val(sEMType)])
      ' update value
      IF iDeviceId THEN Devices.ValueUpdate(iDeviceId, sEMCumulValue, sValue, sEMPeakValue, "")
    CASE "V"
      IF bCULDebug THEN Main.WriteDebugLog(("[CUL] Version string received."))
    CASE ELSE
      Main.WriteDebugLog(("[CUL] Unknown/unsupported message format received!"))
  END SELECT
  Main.ControlLed("CUL", "Off")

CATCH
   Main.WriteDebugLog(("[CUL] ERROR: " & Error.Text & " at " & Error.Where & " Parsing CUL data packet: ") & DisplayPacket(RecBuf))

END

' convert doubles bytes hex to decimal
PRIVATE SUB HexToDec(sHex AS String) AS String

  RETURN Val("&H" & Mid(sHex, 1, 2)) & Val("&H" & Mid(sHex, 3, 2))

END

' converting CUL Hex IDs into ELV-4-Ids
PRIVATE SUB Hex2Four(sHex AS String) AS String

  DIM iCnt AS Integer
  DIM sELV AS String

  FOR iCnt = 1 TO Len(sHex)
    sELV &= Left(Str((Val("&H" & Mid(sHex, iCnt, 1)) / 4) + 1), 1)
    sELV &= (Val("&H" & Mid(sHex, iCnt, 1)) MOD 4) + 1
  NEXT
  RETURN sELV

END

PRIVATE SUB FHTCode(iCode AS Byte) AS String

  SELECT CASE iCode
    CASE &H00
      RETURN "Actuator"
    CASE &H01
      RETURN "Actuator1"
    CASE &H02
      RETURN "Actuator2"
    CASE &H03
      RETURN "Actuator3"
    CASE &H04
      RETURN "Actuator4"
    CASE &H05
      RETURN "Actuator5"
    CASE &H06
      RETURN "Actuator6"
    CASE &H07
      RETURN "Actuator7"
    CASE &H08
      RETURN "Actuator8"
    CASE &H14
      RETURN "Mon-From1"
    CASE &H15
      RETURN "Mon-To1"
    CASE &H16
      RETURN "Mon-From2"
    CASE &H17
      RETURN "Mon-To2"
    CASE &H18
      RETURN "Tue-From1"
    CASE &H19
      RETURN "Tue-To1"
    CASE &H1A
      RETURN "Tue-From2"
    CASE &H1B
      RETURN "Tue-To2"
    CASE &H1C
      RETURN "Wed-From1"
    CASE &H1D
      RETURN "Wed-To1"
    CASE &H1E
      RETURN "Wed-From2"
    CASE &H1F
      RETURN "Wed-To2"
    CASE &H20
      RETURN "Thu-From1"
    CASE &H21
      RETURN "Thu-To1"
    CASE &H22
      RETURN "Thu-From2"
    CASE &H23
      RETURN "Thu-To2"
    CASE &H24
      RETURN "Fri-From1"
    CASE &H25
      RETURN "Fri-To1"
    CASE &H26
      RETURN "Fri-From2"
    CASE &H27
      RETURN "Fri-To2"
    CASE &H28
      RETURN "Sat-From1"
    CASE &H29
      RETURN "Sat-To1"
    CASE &H2A
      RETURN "Sat-From2"
    CASE &H2B
      RETURN "Sat-To2"
    CASE &H2C
      RETURN "Sun-From1"
    CASE &H2D
      RETURN "Sun-To1"
    CASE &H2E
      RETURN "Sun-From2"
    CASE &H2F
      RETURN "Sun-To2"
    CASE &H3E
      RETURN "Mode"
    CASE &H3F
      RETURN "Holiday1"
    CASE &H40
      RETURN "Holiday2"
    CASE &H41
      RETURN "Desired-Temp"
    CASE &H42
      RETURN "Measured-Low"
    CASE &H43
      RETURN "Measured-High"
    CASE &H44
      RETURN "Warnings"
    CASE &H45
      RETURN "Manu-Temp"
    CASE &H4B
      RETURN "Ack"
    CASE &H53
      RETURN "Can-Xmit"
    CASE &H54
      RETURN "Can-Rcv"
    CASE &H60
      RETURN "Year"
    CASE &H61
      RETURN "Month"
    CASE &H62
      RETURN "Day"
    CASE &H63
      RETURN "Hour"
    CASE &H64
      RETURN "Minute"
    CASE &H65
      RETURN "Report1"
    CASE &H66
      RETURN "Report2"
    CASE &H69
      RETURN "Ack2"
    CASE &H7D
      RETURN "Start-Xmit"
    CASE &H7E
      RETURN "End-Xmit"
    CASE &H82
      RETURN "Day-Temp"
    CASE &H84
      RETURN "Night-Temp"
    CASE &H85
      RETURN "Lowtemp-Offset"
    CASE &H8A
      RETURN "WindowOpen-Temp"
    CASE ELSE
      RETURN "Unknown"
    END SELECT

END

PRIVATE SUB DisplayPacket(bBuf AS Byte[]) AS String

  DIM sMsg AS String
  DIM iCnt AS Integer

  FOR iCnt = 0 TO iByteCount
    sMsg &= Chr(bBuf[iCnt])
  NEXT
  RETURN sMsg

END

' implement properties
PRIVATE FUNCTION TCPHost_Read() AS String

  RETURN sTCPHost

END

PRIVATE SUB TCPHost_Write(Value AS String)

  sTCPHost = Value

END

PRIVATE FUNCTION TCPPort_Read() AS Integer

  RETURN iTCPPort

END

PRIVATE SUB TCPPort_Write(Value AS Integer)

  iTCPPort = Value

END

PRIVATE FUNCTION Interface_Read() AS String

  RETURN sInterface

END

PRIVATE SUB Interface_Write(Value AS String)

  sInterface = Value

END

PRIVATE FUNCTION Baud_Read() AS String

  RETURN sBaud

END

PRIVATE SUB Baud_Write(Value AS String)

  sBaud = Value

END

PRIVATE FUNCTION SerPort_Read() AS String

  RETURN sSerPort

END

PRIVATE SUB SerPort_Write(Value AS String)

  sSerPort = Value

END

PRIVATE FUNCTION CULDebug_Read() AS Boolean

  RETURN bCULDebug

END

PRIVATE SUB CULDebug_Write(Value AS Boolean)

  bCULDebug = Value

END

PRIVATE FUNCTION Model_Read() AS Integer

  RETURN iModel

END

PRIVATE SUB Model_Write(Value AS Integer)

  iModel = Value

END

PRIVATE FUNCTION AutoCreate_Read() AS Boolean

  RETURN bAutoCreate

END

PRIVATE SUB AutoCreate_Write(Value AS Boolean)

  bAutoCreate = Value

END

PRIVATE FUNCTION FHTid_Read() AS String

  RETURN sFHTid

END

PRIVATE SUB FHTid_Write(Value AS String)

  sFHTid = Value

END
