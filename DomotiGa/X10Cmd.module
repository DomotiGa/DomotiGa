' Gambas module file

' Description:
' X10Cmd.module
' Use Heyu or other command to control X10 devices.

' Development Status:
' Writing is working, maybe better error checking is needed.

' DomotiGa - an open source home automation program.
' Copyright (C) Ron Klinkien, The Netherlands.

' Reading device status code was written by Renaud.

' Read file called COPYING for license details.

PRIVATE sOutput AS String
PRIVATE sMonitorBuffer AS String
PRIVATE pMonitor AS Process
PRIVATE cQueue AS NEW Collection  ' command buffer
PRIVATE bX10CmdBusy AS Boolean  ' waiting for command to finish

'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
' send a command with heyu or other command
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
PUBLIC SUB SendCommand(sDevice AS String, sCmd AS String)

  DIM sCommand AS String
  DIM aDim AS String[]
  DIM iDim AS Integer

  sCmd = UCase(sCmd)

  IF InStr(sCmd, "ON") OR InStr(sCmd, "OFF") THEN
    SELECT Main.iX10Cmdtype
      CASE 0 ' cm11a heyu
        sCommand = Main.sX10CmdCommand & " " & LCase(sCmd) & " " & sDevice
      CASE 1 ' cma15a cm15ademo
        sCommand = Main.sX10CmdCommand & " " & LCase(sDevice) & " " & LCase(sCmd)
      CASE 2 ' cm17a heyu
        sCommand = Main.sX10CmdCommand & " f" & LCase(sCmd) & " " & sDevice
    END SELECT
  ELSE IF InStr(sCmd, "DIM ") THEN ' DIM 1 - 99
    aDim = Split(sCmd, " ")
    IF aDim.Count = 2 THEN
      iDim = Val(aDim[1])
      SELECT Main.iX10Cmdtype
        CASE 0 ' cm11a heyu
          IF iDim > 0 THEN iDim = Round(0.32 * iDim) ' 32 steps
          sCommand = Main.sX10CmdCommand & " " & "preset " & sDevice & " " & iDim
        CASE 1 ' cm15a cm15ademo
          sCommand = Main.sX10CmdCommand & " " & LCase(sDevice) & " " & "PreDim " & iDim
      END SELECT
    ELSE
      Main.WriteDebugLog(("[X10Cmd] invalid dim command format '") & sCmd & "'")
      RETURN
    ENDIF
  ELSE IF InStr(sCmd, "DIM") OR InStr(sCmd, "BRIGHT") THEN
    SELECT Main.iX10Cmdtype
      CASE 0 ' heyu
        sCommand = Main.sX10CmdCommand & " " & LCase(sCmd) & " " & sDevice & " 2"
      CASE 1 ' cm15ademo
        sCommand = Main.sX10CmdCommand & " " & LCase(sDevice) & " " & LCase(sCmd)
    END SELECT
  ELSE IF InStr(sCmd, "STOP")
    ' ignore
  ELSE
    Main.WriteDebugLog(("[X10Cmd] Unsupported command '") & sCmd & "'")
    RETURN
  ENDIF
  QueueCommand(sCommand)

END

'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
' add command to queue
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
PUBLIC SUB QueueCommand(sCmd AS String)

  ' add command to queue
  cQueue.Add(sCmd, Rnd)

  ' if interface is not busy process it
  IF bX10CmdBusy = FALSE THEN DoQueue()

END

'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
' process items in queue
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
PUBLIC SUB DoQueue()

  DIM sCmd AS String

  FOR EACH sCmd IN cQueue
    RunCommand(sCmd, cQueue.Key)
    BREAK ' only do first one
  NEXT

END

'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
' run command
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
PUBLIC SUB RunCommand(sCmd AS String, sKey AS String)

  SHELL sCmd & " 2>&1" FOR READ AS "X10Cmd"
  IF Main.bX10CmdDebug THEN Main.WriteDebugLog(("[X10Cmd] Run: ") & sCmd)
  ' remove command from queue
  cQueue.Remove(sKey)
  IF bX10CmdBusy = FALSE THEN bX10CmdBusy = TRUE

CATCH
  Main.WriteDebugLog(("[X10Cmd] Error executing: '") & sCmd & "' " & ERROR.Text & " at " & ERROR.Where)

END

'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
' got output, save it
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
PUBLIC SUB X10Cmd_Read()

  DIM sLine AS String

  READ #LAST, sLine, -256
  sOutput &= sLine

END

'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
' command has finished, process it's output
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
PUBLIC SUB X10Cmd_Kill()

  IF Main.bX10CmdDebug THEN Main.WriteDebugLog(("[X10Cmd] Result: ") & sOutput)
  sOutput = NULL

  bX10CmdBusy = FALSE
  IF cQueue.Count THEN ' if there are more commands left in queue, send next one
    IF Main.bX10CmdDebug THEN Main.WriteDebugLog(("[X10Cmd] Sending next command from Queue (count = " & cQueue.Count & ")"))
    DoQueue()
  ENDIF

END

'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
' start heyu monitor
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
PUBLIC SUB Monitor()

  pMonitor = EXEC [Main.sX10CmdCommand, "monitor"] FOR READ AS "X10CmdMonitor"

CATCH
  Main.WriteDebugLog(("[X10Cmd] Error executing: '") & Main.sX10CmdCommand & " monitor' " & ERROR.Text & " at " & ERROR.Where)

END

'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
' read monitor output
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
PUBLIC SUB X10CmdMonitor_Read()

  DIM sLine AS String

  TRY READ #LAST, sLine, -256
  IF ERROR THEN Main.WriteDebugLog(("[X10Cmd] Error reading data from Heyu monitor output-> ") & Error.Text)
  IF Len(sLine) > 0 THEN
    sMonitorBuffer &= sLine
    IF InStr(sMonitorBuffer, "func") > 0 THEN
      ParseMonitorMessage(sMonitorBuffer)
      sMonitorBuffer = NULL
    ENDIF
  ENDIF

END

'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
' parse monitor output
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
PRIVATE SUB ParseMonitorMessage(sMessage AS String)

  DIM iDeviceId, iCnt AS Integer
  DIM aFirstLine, aSecondLine AS String[]
  DIM sAddress, sOrder, sHouseCode AS String

  IF Main.bX10CmdDebug THEN Main.WriteDebugLog(("[X10Cmd] Monitor get: ") & sMessage)

  ' Message sample :
  ' 1 line : 09/19 18:44:53  rcvi addr unit       4 : hu I4  (_no_alias_)
  ' 2 line : 09/19 18:44:53  rcvi func          Off : hc I

  aFirstLine = Scan(sMessage, "*addr unit* : hu*(*")
  aSecondLine = Scan(sMessage, "*func*: hc*")

  IF aFirstLine.Count = 4 AND aSecondLine.Count = 3 THEN
    sAddress = Trim(aFirstLine[2])

    IF Len(sAddress) = 2 THEN
      sAddress = Left(sAddress, 1) & "0" & Right(sAddress, 1)
    ENDIF
    sOrder = Trim(aSecondLine[1])

    IF Main.bX10CmdGlobalX10 THEN
      iDeviceId = Devices.FindAll(sAddress, 9999, "X10")
    ELSE
      iDeviceId = Devices.Find(sAddress, Devices.FindInterface("X10Cmd Interface"), "X10")
    ENDIF

    ' if found then update it's value
    IF iDeviceId THEN Devices.ValueUpdate(iDeviceId, sOrder, "", "", "")
  ELSE ' support for AllOff
    IF aSecondLine.Count = 3 AND Trim(aSecondLine[1]) = "AllOff" THEN
      sHouseCode = Trim(aSecondLine[2])
      IF Main.bX10CmdDebug THEN Main.WriteDebugLog(("[X10Cmd] AllOff command detected for HouseCode: ") & sHouseCode)
      FOR iCnt = 1 TO 16 STEP 1
        sAddress = sHouseCode & Format(iCnt, "0#")
        IF Main.bX10CmdGlobalX10 THEN
          iDeviceId = Devices.FindAll(sAddress, 9999, "X10")
        ELSE
          iDeviceId = Devices.Find(sAddress, Devices.FindInterface("X10Cmd Interface"), "X10")
        ENDIF
        IF Main.bX10CmdDebug THEN Main.WriteDebugLog(("[X10Cmd] Switching device ") & sHouseCode & icnt & (" Off"))
        IF iDeviceId THEN Devices.ValueUpdate(iDeviceId, "Off", "", "", "")
      NEXT
    ENDIF
  ENDIF

END

'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
' stop monitor
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
PUBLIC SUB Monitor_Stop()

  TRY pMonitor.Kill

END
