' Gambas class file

' Description:
' EIB.class
' Provide support for KNX / EIB using eibd.

' Development Status:
' Just started developing this one.

' Links:
' http://www.auto.tuwien.ac.at/~mkoegler/index.php/eibd

' DomotiGa - an open source home automation program.
' Copyright(C) 2008-2010 Ron Klinkien
' This module is written by and Copyright(C) 2009 Timo Sariwating

' Read file called COPYING for license details.

PROPERTY TCPHost AS String
PROPERTY TCPPort AS String
PROPERTY EIBDebug AS Boolean

PRIVATE sTCPHost AS String
PRIVATE sTCPPort AS String
PRIVATE bEIBDebug AS Boolean

PUBLIC hEIB AS NEW Socket
PUBLIC tEIB AS Timer

PRIVATE CONST ON AS Byte = &H81
PRIVATE CONST OFF AS Byte = &H80

'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
' connect to the host:port
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
PUBLIC FUNCTION Connect() AS Boolean

  ' try to close the connection
  TRY hEIB.Close

  ' get a new one
  hEIB = NEW Socket AS "eib"
  hEIB.Connect(sTCPHost, sTCPPort)

  ' start poll timer for KNX/EIB status LED
  tEIB = NEW Timer AS "tEIBLED"
  tEIB.Delay = 250
  tEIB.Stop

  ' all ok
  RETURN TRUE

CATCH ' some errors
  Main.WriteLog(("KNX/EIB Error: ") & ERROR.Text)
  RETURN FALSE

END

'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
' after connecting open a group socket for group communication
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
PUBLIC SUB EIB_Ready()

  DIM bCommand AS Byte[] = [CByte(&H00), CByte(&H26), CByte(&H00), CByte(&H00), CByte(&H00)]

  Main.WriteLog(("KNX/EIB TCP socket connected."))
  TX(bCommand)

END

'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
' remote end closed socket
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
PUBLIC SUB EIB_Closed()

  Main.WriteLog(("KNX/EIB Error: TCP socket closed."))

END

'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
' blink led
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
PUBLIC SUB tEIBLED_Timer()

  Main.ControlLed("EIB", "Off")
  tEIB.Stop

END

'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
' send a packet to the KNX/EIB interface
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
PRIVATE SUB TX(bCommand AS Byte[])

  DIM bData AS Byte
  DIM iLen AS Integer = bCommand.Count

  IF hEIB.Status = Net.Connected THEN
    bCommand.Add(&H00, 0)
    bCommand.Add(Hex(iLen), 1)
    bCommand.Write(hEIB, 0, bCommand.Length)

    IF NOT bEIBDebug THEN RETURN
    Main.WriteDebugLog("[KNX/EIB] >", TRUE)
    FOR EACH bData IN bCommand
      Main.WriteRFXDebugLog(" " & Hex(bData, 2), TRUE)
    NEXT
    Main.WriteRFXDebugLog("\n", TRUE)
  ENDIF

CATCH
  Main.WriteDebugLog(("[KNX/EIB] Error while trying to send: ") & ERROR.Text & (" at ") & ERROR.Where)

END

'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
' disconnect from the host
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
PUBLIC FUNCTION Disconnect() AS Boolean

  ' try to close the connection
  TRY hEIB.Close
  Main.WriteLog(("KNX/EIB TCP socket port close."))

  ' all ok
  RETURN TRUE

CATCH ' some errors
  Main.WriteLog(("KNX/EIB Error: ") & ERROR.Text)
  RETURN FALSE

END

PUBLIC SUB EIB_Error()

  ' handle error
  SELECT CASE hEIB.Status
    CASE Net.CannotCreateSocket
      Main.WriteLog(("KNX/EIB: The system does not allow to create a socket."))
    CASE Net.HostNotFound
      Main.WriteLog(("KNX/EIB: Host '") & sTCPHost & ("' not found."))
    CASE Net.ConnectionRefused
      Main.WriteLog(("KNX/EIB: Unable to connect to eibd. Connection refused."))
    CASE Net.CannotRead
      Main.WriteLog(("KNX/EIB: Error reading data."))
    CASE Net.CannotWrite
      Main.WriteLog(("KNX/EIB: Error writing data."))
  END SELECT

END

'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
' Read EIB/KNX socket
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
PUBLIC SUB EIB_Read()

  DIM bMyBuf AS Byte[512]
  DIM iCnt AS Integer
  DIM sDevice, sAddress AS String
  DIM sReceived AS String[0]

  IF hEIB.Status <> Net.Connected THEN RETURN
    bMyBuf[0] = 0
    READ #hEIB, bMyBuf[0] ' read the first byte
    Main.ControlLed("EIB", "On")
    IF Main.bServer THEN tEIB.Start

    SELECT bMyBuf[0]
      CASE 0
        TRY READ #hEIB, bMyBuf[1], 1 ' read the length byte
        FOR iCnt = 0 TO bMyBuf[1] - 1 ' read the rest of the frame
          TRY READ #hEIB, bMyBuf[2 + iCnt], 1
        NEXT
    END SELECT

    SELECT Hex$(bMyBuf[3])
      CASE 26 ' open group socket reply
        IF Main.bEIBDebug THEN Main.WriteDebugLog(("[KNX/EIB] got group socket reply."))
      CASE 27 ' group packet
        sDevice = Addr2Str((Hex$(bMyBuf[4], 2)) & (Hex(bMyBuf[5], 2)), FALSE)
        sAddress = Addr2Str((Hex$(bMyBuf[6], 2)) & (Hex$(bMyBuf[7], 2)), TRUE)
        IF Main.bEIBDebug THEN Main.WriteDebugLog(("[KNX/EIB] received packet from '") & sDevice & ("' to '") & sAddress & "'")
        FOR iCnt = 9 TO bMyBuf.Length - 1 ' bMyBuf[1]
          sReceived.Add(Hex(bMyBuf[iCnt], 2))
        NEXT
        LookupEIS(sAddress, sReceived)
    END SELECT

    IF NOT bEIBDebug THEN RETURN
    Main.WriteDebugLog("[KNX/EIB] <", TRUE)
    FOR iCnt = 0 TO bMyBuf[1] + 2
      Main.WriteRFXDebugLog(" " & Hex(bMyBuf[iCnt], 2), TRUE)
    NEXT
    Main.WriteRFXDebugLog("\n", TRUE)

END

'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
' lookup the EIS type for received data
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
PRIVATE SUB LookupEIS(sAddress AS String, sReceived AS String[])

  DIM iDeviceId AS Integer = Devices.Find(sAddress, Devices.FindInterface("KNX/EIB Interface"))

  IF iDeviceId THEN
    SELECT CASE Devices.FindDescrForDeviceType(Devices.FindModuleForDevice(iDeviceId))
      CASE "EIS 1" ' On/Off
        EIS1(iDeviceId, sReceived)
      CASE "EIS 2" ' Dim
        EIS2(iDeviceId, sReceived)
      CASE "EIS 3" ' Time
        EIS3(iDeviceId, sReceived)
      CASE "EIS 4" ' Date
        EIS4(iDeviceId, sReceived)
      CASE "EIS 5" ' Values
        EIS5(iDeviceId, sReceived)
      CASE ELSE
        ' IF NOT bEIBDebug THEN RETURN
        ' Main.WriteDebugLog("[KNX/EIB] <", TRUE)
        ' FOR iCnt = 0 TO bMyBuf[1] + 2
        '   Main.WriteRFXDebugLog(" " & Hex(bMyBuf[iCnt], 2), TRUE)
        ' NEXT
        ' Main.WriteRFXDebugLog("\n", TRUE)
        Main.WriteDebugLog(("[KNX/EIB] EIS Unknown for address ") & sAddress & (" and data ") & sReceived)
    END SELECT
  ENDIF

END

'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
' handle received commands for EIB1 devices (switch on/off)
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
PRIVATE SUB EIS1(iDeviceId AS Integer, sReceived AS String[])

  DIM iCnt AS Integer

  SELECT CASE sReceived[0]
    CASE 80
      Devices.ValueUpdate(iDeviceId, "Off", "", "", "")
      IF bEIBDebug THEN Main.WriteDebugLog(("[KNX/EIB] EIS1: ") & Devices.FindNameForDevice(iDeviceId) & " Off")
    CASE 81
      Devices.ValueUpdate(iDeviceId, "On", "", "", "")
      IF bEIBDebug THEN Main.WriteDebugLog(("[KNX/EIB] EIS1: ") & Devices.FindNameForDevice(iDeviceId) & " On")
  END SELECT

END

'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
' handle received commands for EIB2 devices (dim)
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
PRIVATE SUB EIS2(iDeviceId AS Integer, sReceived AS String[])

  DIM sAddress, sDeviceName AS String
  DIM sAddressSplit AS String[]
  DIM bCommand AS Byte[6]
  DIM iPercentage AS Integer

  sDeviceName = Devices.FindNameForDevice(iDeviceId)
  sAddress = Devices.FindAddressForDevice(sDeviceName)

  sAddressSplit = Split(sAddress, "|" "/")

  bCommand[0] = &H00
  bCommand[1] = &H27
  bCommand[2] = Hex$(Val(sAddressSplit[6]) & Val(sAddressSplit[7]))
  bCommand[3] = Val(sAddressSplit[8])
  bCommand[4] = &H00
  bCommand[5] = &H00

  SELECT CASE sReceived[0]
    CASE 80
      IF bEIBDebug THEN Main.WriteDebugLog(("[KNX/EIB] EIS2: ") & sDeviceName & " Off")
      TX(bCommand)
    CASE 81
      IF bEIBDebug THEN Main.WriteDebugLog(("[KNX/EIB] EIS2: ") & sDeviceName & " On")
      TX(bCommand)
    CASE 89
      IF bEIBDebug THEN Main.WriteDebugLog(("[KNX/EIB] EIS2: ") & sDeviceName & " Dim")
      TX(bCommand)
    CASE 40
      iPercentage = Val("&H" & sReceived[1]) / 255 * 100
      IF iPercentage = 0 THEN
        Devices.ValueUpdate(iDeviceId, "Off", CStr(iPercentage), "", "")
      ELSE
        Devices.ValueUpdate(iDeviceId, "On", CStr(iPercentage), "", "")
      ENDIF
  END SELECT

END

'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
' handle received commands for EIB3 devices (time)
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
PRIVATE SUB EIS3(iDeviceId AS Integer, sReceived AS String[])

  DIM sAddressSplit AS String[]
  DIM bCommand AS Byte[9]
  DIM iMinute, iHour, iSecond AS Integer

  SELECT CASE sReceived[1]
    CASE 80
      iHour = Val("&H" & (Mid$(sReceived, 5, 2)))
      iMinute = Val("&H" & (Mid$(sReceived, 7, 2)))
      iSecond = Val("&H" & (Mid$(sReceived, 9, 2)))
      IF bEIBDebug THEN Main.WriteDebugLog(("[KNX/EIB] EIS3: ") & Devices.FindNameForDevice(iDeviceId) & " " & Time(iHour, iMinute, iSecond))
    CASE 00
      sAddressSplit = Split(Devices.FindAddressForDevice(Devices.FindNameForDevice(iDeviceId)), "/")
      bCommand[0] = &H00
      bCommand[1] = &H27
      bCommand[2] = Hex$(Val(sAddressSplit[0]) & Val(sAddressSplit[1]))
      bCommand[3] = Val(sAddressSplit[2])
      bCommand[4] = &H00
      bCommand[5] = &H80
      bCommand[6] = Hex$(Hour(Now))
      bCommand[7] = Hex$(Minute(Now))
      bCommand[8] = Hex$(Second(Now))
      TX(bCommand)
      IF bEIBDebug THEN Main.WriteDebugLog(("[KNX/EIB] EIS3: Time ") & Time(Now) & (" send to bus."))
  END SELECT

END

'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
' handle received commands for EIB4 devices (date)
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
PRIVATE SUB EIS4(iDeviceId AS Integer, sReceived AS String[])

  DIM sAddressSplit AS String[]
  DIM bCommand AS Byte[9]
  DIM iDay, iMonth, iYear AS Integer

  SELECT CASE sReceived[1]
    CASE 80
      iday = Val("&H" & (Mid$(sReceived, 5, 2)))
      iMonth = Val("&H" & (Mid$(sReceived, 7, 2)))
      iYear = Val("&H" & (Mid$(sReceived, 9, 2))) + 2000
      IF bEIBDebug THEN Main.WriteDebugLog(("[KNX/EIB] EIS4: ") & Devices.FindNameForDevice(iDeviceId) & " " & Date(iYear, iMonth, iDay))
    CASE 00
      sAddressSplit = Split(Devices.FindAddressForDevice(Devices.FindNameForDevice(iDeviceId)), "/")
      bCommand[0] = &H00
      bCommand[1] = &H27
      bCommand[2] = Hex$(Val(sAddressSplit[0]) & Val(sAddressSplit[1]))
      bCommand[3] = Val(sAddressSplit[2])
      bCommand[4] = &H00
      bCommand[5] = &H80
      bCommand[6] = Hex$(Day(Now))
      bCommand[7] = Hex$(Month(Now))
      bCommand[8] = Hex$(Right$(CStr(Year(Now)), 2))
      TX(bCommand)
      IF bEIBDebug THEN Main.WriteDebugLog(("[KNX/EIB] EIS4: Date ") & Day(Now) & "/" & Month(Now) & "/" & Year(Now) & (" send to bus."))
  END SELECT

END

'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
' handle received for EIB5 devices (values)
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
PRIVATE SUB EIS5(iDeviceId AS Integer, sReceived AS String[])

  DIM iValue AS Integer

  iValue = Val(Hex$(sReceived[1]))
  Main.WriteDebugLog(("[KNX/EIB] EIS5: ") & Devices.FindNameForDevice(iDeviceId) & " " & iValue)

END

'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
' prepare a command for sending to the KNX/EIB interface
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
PUBLIC SUB SendCommand(sAddress AS String, sValue AS String)

  DIM sModule AS String
  DIM sAddressSplit AS String[]
  DIM iBrightness AS Integer
  DIM bCommand AS Byte[5]

  sModule = Devices.FindDescrForDeviceType(Devices.FindModuleForDevice(Devices.Find(sAddress, Devices.FindInterface("KNX/EIB Interface"))))
  SELECT CASE sModule
    CASE "EIS 1" ' (On/Off)
      sAddressSplit = Split(sAddress, "/")
      sAddress = Str2Addr(sAddressSplit[0], sAddressSplit[1], sAddressSplit[2])
      bCommand[0] = &H00
      bCommand[1] = &H27
      bCommand[2] = Val("&H" & Left(sAddress, 2))
      bCommand[3] = Val("&H" & Right(sAddress, 2))
      bCommand[4] = &H00
      SELECT CASE sValue
        CASE "On"
          bCommand.Add(ON)
          TX(bCommand)
        CASE "Off"
          bCommand.Add(OFF)
          TX(bCommand)
      END SELECT
    CASE "EIS 2" ' (Dim)
      sAddressSplit = Split(sAddress, "|" "/")
      sAddress = Str2Addr(sAddressSplit[0], sAddressSplit[1], sAddressSplit[2])
      bCommand[0] = &H00
      bCommand[1] = &H27
      bCommand[2] = Val("&H" & Left(sAddress, 2))
      bCommand[3] = Val("&H" & Right(sAddress, 2))
      bCommand[4] = &H00
      SELECT CASE sValue
        CASE "On"
          bCommand.Add(ON)
          TX(bCommand)
        CASE "Off"
          bCommand.Add(OFF)
          TX(bCommand)
        CASE "Stop"
          sAddress = Str2Addr(sAddressSplit[3], sAddressSplit[4], sAddressSplit[5])
          bCommand[2] = Val("&H" & Left(sAddress, 2))
          bCommand[3] = Val("&H" & Right(sAddress, 2))
          bCommand.Add(&H80)
          TX(bCommand)
        CASE ELSE
          IF InStr(sValue, "Dim ") THEN ' DIM 0-100
            iBrightness = Val(Replace(sValue, "Dim ", ""))
            sAddress = Str2Addr(sAddressSplit[6], sAddressSplit[7], sAddressSplit[8])
            bCommand[2] = Val("&H" & Left(sAddress, 2))
            bCommand[3] = Val("&H" & Right(sAddress, 2))
            bCommand.Add(&H80)
            bCommand.Add(CInt(iBrightness * 2.55))
            TX(bCommand)
          ENDIF
      END SELECT
  END SELECT

END

PUBLIC FUNCTION Addr2Str(sAddress AS String, bLogical AS Boolean) AS String

 IF bLogical THEN
  ' convert to logical address
  RETURN (Lsr((Val("&H" & sAddress)), 11) AND &HF) & "/" & (Lsr((Val("&H" & sAddress)), 8) AND &H7) & "/" & ((Val("&H" & sAddress)) AND &HFF)
 ELSE
  ' convert to physical address
  RETURN (Lsr((Val("&H" & sAddress)), 12)) & "." & (Lsr((Val("&H" & sAddress)), 8) AND &HF) & "." & ((Val("&H" & sAddress)) AND &HFF)
 END IF

END

PUBLIC FUNCTION Str2Addr(sA1 AS String, sA2 AS String, sA3 AS String) AS String

  DIM sString AS String

  sString = Lsl(Val(sA1), 11) OR Lsl(Val(sA2), 8) OR Val(sA3)
  RETURN Hex$(sString, 4)

END

' implement properties
PRIVATE FUNCTION TCPHost_Read() AS String

  RETURN sTCPHost

END

PRIVATE SUB TCPHost_Write(Value AS String)

  sTCPHost = Value

END

PRIVATE FUNCTION TCPPort_Read() AS String

  RETURN sTCPPort

END

PRIVATE FUNCTION TCPPort_Write(Value AS String)

  sTCPPort = Value

END

PRIVATE FUNCTION EIBDebug_Read() AS Boolean

  RETURN bEIBDebug

END

PRIVATE SUB EIBDebug_Write(Value AS Boolean)

  bEIBDebug = Value

END
