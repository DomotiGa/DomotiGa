' Gambas module file

' Description:
' Astro.module
' Calculate Sun and Moon related things.

' Development Status:
' Calculating values seems to work ok, accuracy and precision needs to be verified.
' Support for Daylight Saving Time needs to be added.

' Links:
' http://www.drbeat.li/php/source.php?src=php/sunrise.inc.php
' http://home.att.net/~srschmitt/script_moon_phase.html

' DomotiGa - an open source home automation program.
' Copyright(C) 2008-2010 Ron Klinkien

' Read file called COPYING for license details.

PUBLIC FUNCTION CalcSunTimes(lon AS Float, lat AS Float, timezone AS Float, isRise AS Boolean, twilight AS Integer) AS String

  DIM a, b, c, d, e, f, g, j, k, l, m, p, q, r, s, t, u, v AS Float
  DIM yday, ihour, imin, isec AS Integer

  ' twilight setting
  IF (twilight = 0) THEN r = -0.0145439 ' effective sunrise/sunset
  IF (twilight = 1) THEN r = -0.104528 ' civil twilight (brightest)
  IF (twilight = 2) THEN r = -0.207912 ' nautical twilight
  IF (twilight = 3) THEN r = -0.309017 ' astronomical twilight (darkest)

  ' multiples of Pi
  a = 0.5 * Pi
  b = Pi
  c = 1.5 * Pi
  d = 2 * Pi

  ' convert coordinates and timezone to radians
  e = lat * b / 180
  f = lon * b / 180
  g = timezone * d / 24

  ' calculate sunrise or sunset?
  j = IIf(isRise, a, c)

  ' calculate day of year
  yday = DateDiff("01/01/" & Year(Now()), Now(), gb.day)

  k = yday + (j - f) / d
  l = k * 0.017202 - 0.0574039 ' solar mean anomoly
  m = l + 0.0334405 * Sin(l) ' solar true longitude
  m += 4.93289 + 3.49066E-4 * Sin(2 * l)

  ' quadrant determination
  m = norm(m, d)
  IF ((m / a) - CInt(m / a) = 0) THEN
    m += 4.84814E-6
    p = Sin(m) / Cos(m) ' solar right ascension
    p = ATan2(0.91746 * p, 1)
  END IF

  ' quadrant adjustment
  IF (m > c) THEN
    p += d
  ELSE IF (m > a) THEN
    p += b
  ENDIF

  q = 0.39782 * Sin(m) ' solar declination
  q /= Sqr(- q * q + 1)
  q = ATan2(q, 1)

  s = r - Sin(q) * Sin(e)
  s /= Cos(q) * Cos(e)
  IF (Abs(s) > 1) THEN PRINT "(Midnight Sun)"

  s /= Sqr(- s * s + 1)
  s = a - ATan2(s, 1)

  IF (isRise) THEN s = d - s

  t = s + p - 0.0172028 * k - 1.73364 ' local apparent time
  u = t - f ' universal time
  v = u + g ' wall clock time

  ' quadrant Determination
  v = norm(v, d)

  ' scale from radians to hours
  v *= 24 / d

  ' local time
  ihour = CInt(v)
  iMin = CInt((v - ihour) * 60)

  RETURN Format(ihour, "0#") & ":" & Format(imin, "0#")

END

PRIVATE FUNCTION norm(a AS Float, b AS Float) AS Float

  WHILE (a < 0)
    a += b
  WEND
  WHILE (a >= b)
    a -= b
  WEND
  RETURN a

END

PUBLIC SUB CalcMoonPhase()

  DIM yy, mm, k1, k2, k3, jd, y, d, m AS Integer
  DIM ip, dp, np, rp AS Float
  DIM ag AS Float ' moon's age
  DIM di AS Float ' moon's distance in earth radii
  DIM la AS Float ' moon's ecliptic latitude
  DIM lo AS Float ' moon's ecliptic longitude
  DIM phase, zodiac AS String

  y = Year(Now)
  m = Month(Now)
  d = Day(Now)

  ' calculate the Julian Date at 12h UT
  YY = Y - Int((12 - M) / 10)
  MM = M + 9
  IF (MM >= 12) THEN MM = MM - 12

  K1 = Int(365.25 * (YY + 4712))
  K2 = Int(30.6 * MM + 0.5)
  K3 = Int(Int((YY / 100) + 49) * 0.75) - 38

  JD = K1 + K2 + D + 59 ' for dates in Julian calendar
  IF (JD > 2299160) THEN JD = JD - K3 ' for Gregorian calendar

  ' calculate moon's age in days
  IP = normalize((JD - 2451550.1) / 29.530588853)
  AG = IP * 29.53

  IF (AG < 1.84566) THEN
    Phase = ("New")
  ELSE IF (AG < 5.53699) THEN
    Phase = ("Evening crescent")
  ELSE IF (AG < 9.22831) THEN
    Phase = ("First quarter")
  ELSE IF (AG < 12.91963) THEN
    Phase = ("Waxing gibbous")
  ELSE IF (AG < 16.61096) THEN
    Phase = ("Full")
  ELSE IF (AG < 20.30228) THEN
    Phase = ("Waning gibbous")
  ELSE IF (AG < 23.99361) THEN
    Phase = ("Last quarter")
  ELSE IF (AG < 27.68493) THEN
    Phase = ("Morning crescent")
  ELSE
    Phase = ("New")
  ENDIF

  IP = IP * 2 * Pi ' convert phase to radians

  ' calculate moon's distance
  DP = 2 * Pi * normalize((JD - 2451562.2) / 27.55454988)
  DI = 60.4 - 3.3 * Cos(DP) - 0.6 * Cos(2 * IP - DP) - 0.5 * Cos(2 * IP)

  ' calculate moon's ecliptic latitude
  NP = 2 * Pi * normalize((JD - 2451565.2) / 27.212220817)
  LA = 5.1 * Sin(NP)

  ' calculate moon's ecliptic longitude
  RP = normalize((JD - 2451555.8) / 27.321582241)
  LO = 360 * RP + 6.3 * Sin(DP) + 1.3 * Sin(2 * IP - DP) + 0.7 * Sin(2 * IP)

  IF (LO < 33.18) THEN
    Zodiac = ("Pisces")
  ELSE IF (LO < 51.16) THEN
    Zodiac = ("Aries")
  ELSE IF (LO < 93.44) THEN
    Zodiac = ("Taurus")
  ELSE IF (LO < 119.48) THEN
    Zodiac = ("Gemini")
  ELSE IF (LO < 135.30) THEN
    Zodiac = ("Cancer")
  ELSE IF (LO < 173.34) THEN
    Zodiac = ("Leo")
  ELSE IF (LO < 224.17) THEN
    Zodiac = ("Virgo")
  ELSE IF (LO < 242.57) THEN
    Zodiac = ("Libra")
  ELSE IF (LO < 271.26) THEN
    Zodiac = ("Scorpio")
  ELSE IF (LO < 302.49) THEN
    Zodiac = ("Sagittarius")
  ELSE IF (LO < 311.72) THEN
    Zodiac = ("Capricorn")
  ELSE IF (LO < 348.58) THEN
    Zodiac = ("Aquarius")
  ELSE
    Zodiac = ("Pisces")
  END IF

  ' so longitude is not greater than 360!
  IF (LO > 360) THEN LO = LO - 360

  Main.MoonPhase = Phase
  Main.MoonZodiac = Zodiac
  Main.MoonAge = Round(ag, -2)
  Main.MoonDistance = Round(di, -2)
  Main.MoonLatitude = Round(la, -2)
  Main.MoonLongitude = Round(lo, -2)
  Main.MoonIsLeapYear = isleapyear(y)

END

PRIVATE FUNCTION normalize(v AS Float) AS Float

  v = v - Int(v)
  IF (v < 0) THEN v = v + 1
  RETURN v

END

PRIVATE FUNCTION isleapyear(y AS Integer) AS Boolean

  DIM x, w, z AS Integer

  x = Int(y - 4 * Int(y / 4))
  w = Int(y - 100 * Int(y / 100))
  z = Int(y - 400 * Int(y / 400))

  IF (x = 0) THEN ' possible leap Year
    IF ((w = 0) & (NOT z = 0))
      RETURN FALSE ' not a leap Year
    ELSE
      RETURN TRUE ' is leap Year
    END IF
  END IF
  RETURN FALSE

END 
