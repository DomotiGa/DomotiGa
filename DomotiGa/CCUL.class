' Gambas class file

' Description:
' CCUL.class
' Connect to CULFW interface via tcp socket or serial port.

' Development Status:
' Just started.

' DomotiGa - an open source home automation program.
' Copyright(C) 2008-2011 Ron Klinkien

' Read file called COPYING for license details.

PROPERTY TCPHost AS String
PROPERTY TCPPort AS Integer
PROPERTY Interface AS String
PROPERTY SerPort AS String
PROPERTY Baud AS String
PROPERTY CULDebug AS Boolean
PROPERTY Model AS Integer
PROPERTY FHTid AS String
PROPERTY AutoCreate AS Boolean

PRIVATE sTCPHost AS String
PRIVATE iTCPPort AS Integer
PRIVATE sInterface AS String
PRIVATE sSerPort AS String
PRIVATE sBaud AS String
PRIVATE bCULDebug AS Boolean
PRIVATE iModel AS Integer
PRIVATE sFHTid AS String
PRIVATE bAutoCreate AS Boolean

PUBLIC hCUL AS NEW Socket
PUBLIC hCULSer AS NEW SerialPort
PUBLIC bSimulate AS Boolean = FALSE

PRIVATE bFirstByte AS Boolean = TRUE
PRIVATE RecBuf AS Byte[255]
PRIVATE bMessage AS Boolean = FALSE
PRIVATE iByteCount AS Integer = 0

' FS20
PRIVATE sFS20Values AS String[] = ["Off", "Dim 6", "Dim 12", "Dim 18", "Dim 25", "Dim 31", "Dim 37", "Dim 43", "Dim 50", "Dim 56", "Dim 62", "Dim 68", "Dim 75", "Dim 81", "Dim 87", "Dim 93", "Dim 100", "On", "Toggle", "DimUp", "DimDown", "DimUpDown", "Timer", "SendState", "Off-For-Timer", "On-For-Timer", "On-Old-For-Timer", "Reset", "Ramp-On-Time", "Ramp-Of-Time", "On-Old-For-Timer-Prev", "On-100-For-Timer-Prev"]

' FHT
CONST FHT_SYNCTIME AS Byte = &H2C
CONST FHT_MODE AS Byte = &H3D
CONST FHT_DESIREDTEMP AS Byte = &H41
CONST FHT_STATUS AS Byte = &H44
CONST FHT_DAYTEMP AS Byte = &H82
CONST FHT_NIGHTTEMP AS Byte = &H84
CONST FHT_WINDOWOPENTEMP AS Byte = &H8A

PUBLIC SUB CUL_Ready()

  Main.WriteLog(("CUL TCP socket connected."))
  Init()

END

'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
' connect to the host:port
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
PUBLIC FUNCTION ConnectTCP() AS Boolean

  ' try to close the connection
  TRY hCUL.Close

  ' get a new one
  hCUL = NEW Socket AS "CUL"
  hCUL.Connect(sTCPHost, iTCPPort)

  ' all ok
  RETURN TRUE

CATCH ' some errors
  Main.WriteLog(("CUL Error: ") & ERROR.Text)
  RETURN FALSE

END

'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
' connect to the serial port
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
PUBLIC FUNCTION ConnectSerial() AS Boolean

  ' try to close the connection
  TRY hCULSer.Close

  ' get a new one
  hCULSer = NEW Serialport AS "CULSer"
  WITH hCULSer
    .PortName = sSerPort
    .Speed = sBaud
    .Parity = 0
    .DataBits = 8
    .StopBits = 1
    .FlowControl = 0
    .Open()
  END WITH

  Init()

  ' all ok
  RETURN TRUE

CATCH ' some errors
  Main.WriteLog(("CUL Error: ") & ERROR.Text)
  RETURN FALSE

END

'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
' disconnect from the host
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
PUBLIC FUNCTION Disconnect() AS Boolean

  ' try to close the connection
  TRY hCUL.Close
  TRY hCULSer.Close
  IF InStr(sInterface, "tcp") THEN
    Main.WriteLog(("CUL TCP socket close."))
  ELSE
    Main.WriteLog(("CUL serial port close."))
  END IF
  ' all ok
  RETURN TRUE

CATCH ' some errors
  Main.WriteLog(("CUL Error: ") & ERROR.Text)
  RETURN FALSE

END

PUBLIC SUB CUL_Error()

  DIM sString AS String = "CUL: "

  ' handle error
  SELECT CASE hCUL.Status
    CASE Net.CannotCreateSocket
      Main.WriteLog(sString & ("The system does not allow to create a socket."))
    CASE Net.HostNotFound
      Main.WriteLog(sString & ("Host '") & sTCPHost & ("' not found."))
    CASE Net.ConnectionRefused
      Main.WriteLog(sString & ("Unable to connect. Connection refused."))
    CASE Net.CannotRead
      Main.WriteLog(sString & ("Error reading data."))
    CASE Net.CannotWrite
      Main.WriteLog(sString & ("Error writing data."))
  END SELECT

END

PUBLIC SUB CUL_Read()

  DIM bData AS Byte

  TRY READ #hCUL, bData
  IF ERROR THEN Main.WriteDebugLog(("[CUL] Error reading data from the TCP port! -> ") & Error.Text)
  ProcessReceivedChar(bData)

END

PUBLIC SUB CULSer_Read()

  DIM bData AS Byte

  TRY READ #hCULSer, bData
  IF ERROR THEN Main.WriteDebugLog(("[CUL] Error reading data from the serial port! -> ") & Error.Text)
  ProcessReceivedChar(bData)

END

'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
' initialize interface
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
PUBLIC FUNCTION Init()

  SendCommand("X21\r\n")
  IF bCULDebug THEN Main.WriteRFXDebugLog("[CUL] > X21\n")
  IF Len(sFHTid) THEN
    SendCommand("T01" & sFHTid & "\r\n")
    IF bCULDebug THEN Main.WriteRFXDebugLog("[CUL] > T01" & sFHTid & "\n")
  ENDIF
  GetVersion()

  ' ParseDump()

END

' just here for development/debugging
PUBLIC SUB ParseDump()

  DIM hFile AS File
  DIM sLine AS String

  TRY hFile = OPEN "/home/ron/FHT.txt" FOR INPUT
  IF ERROR THEN RETURN

  WHILE NOT Eof(hFile)
    LINE INPUT #hFile, sLine
    IF Len(sLine) > 5 THEN Simulate(sLine)
  WEND

END

'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
' initialize interface
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
PUBLIC FUNCTION GetVersion()

  SendCommand("V\r\n")
  IF bCULDebug THEN Main.WriteRFXDebugLog("[CUL] > V\n")

END

'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
' inject packet into parser.
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
PUBLIC SUB Simulate(sPacket AS String)

  DIM iCnt AS Integer

  bFirstByte = TRUE
  IF bCULDebug THEN Main.WriteRFXDebugLog(("[CUL] CUL receiver Simulate String: ") & sPacket & "\n")

  FOR iCnt = 1 TO Len(sPacket)
    ProcessReceivedChar(Asc(Mid(sPacket, iCnt, 1)))
  NEXT
  ProcessReceivedChar(&HD)
  ProcessReceivedChar(&HA)
  bSimulate = FALSE

END SUB
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
' send a command to the interface
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
PUBLIC FUNCTION SendCommand(sBuffer AS String)

  IF sInterface = "tcp" THEN
    ' send the message to the tcp stream
    TRY WRITE #hCUL, sBuffer, Len(sBuffer)
    IF ERROR THEN Main.WriteRFXDebugLog(("[CUL] Unable to write to TCP port! -> ") & Error.Text)
  ELSE
    ' send the message to the serial port
    TRY WRITE #hCULSer, sBuffer, Len(sBuffer)
    IF ERROR THEN Main.WriteRFXDebugLog(("[CUL] Unable to write to serial port! -> ") & Error.Text)
  ENDIF

END

PRIVATE SUB ProcessReceivedChar(bTemp AS Byte)

  IF bFirstByte = TRUE THEN
    bFirstByte = FALSE
    iByteCount = 0
    IF bCULDebug THEN Main.WriteRFXDebugLog("[CUL] < ", 0)
  ENDIF

  Main.ControlLed("CUL", "On")

  RecBuf[iByteCount] = bTemp
  IF bTemp = &HA THEN
    iByteCount -= 2 ' do not count \r\n
    bMessage = TRUE
  ELSE
    IF bCULDebug AND IF (bTemp <> &HD) THEN Main.WriteRFXDebugLog(Chr(bTemp), 1)
    INC iByteCount
  ENDIF

  IF bMessage THEN Display_Message()

END

PRIVATE SUB Display_Message()

  DIM iDeviceId, iCnt, iCmd, iDur, iI, iJ, iRSSI AS Integer
  DIM sHouseCode, sAddress, sValue, sValue2, sCmd, sEMType, sEMCumulValue, sEMPeakValue, sMsgCounter, sBatt, sVal, sId, sSval, sFv AS String
  DIM sWarn, sLowTemp, sSensor, sWindow, sOffset AS String
  DIM aEMType AS String[] = ["", "EM1000-S", "EM1000-EM", "EM1000-GZ"]
  DIM aFHTc2m AS String[] = ["auto", "manual", "holiday", "holiday-short"]
  DIM bConfirm AS Boolean

  bMessage = FALSE
  bFirstByte = TRUE

  IF bCULDebug THEN Main.WriteRFXDebugLog("\n", 1)

  SELECT CASE Chr(RecBuf[0])
    CASE "F" ' FS20 message
      ' F <Hex>
      ' <Hex> is a hex string with the following format:
      ' hhhhaacc or hhhhaaccee, where
      ' hhhh is the FS20 housecode
      ' aa is the FS20 device address
      ' cc is the FS20 command
      ' ee is the FS20 timespec. Note that cc must have the extension bit set.
      ' Example: F12340111

      ' check for valid packet size
      IF iByteCount < 9 OR IF iByteCount > 12 THEN
        IF bCULDebug THEN Main.WriteDebugLog(("[CUL] FS20 message received with invalid length of " & iByteCount & " bytes!"))
        RETURN
      ENDIF

      sHouseCode = Chr(RecBuf[1]) & Chr(RecBuf[2]) & Chr(RecBuf[3]) & Chr(RecBuf[4])
      sAddress = Chr(RecBuf[5]) & Chr(RecBuf[6])
      iCmd = Val("&H" & Chr(RecBuf[7]) & Chr(RecBuf[8]))

      ' signal
      IF iByteCount > 11 THEN
        iRSSI = Val("&H" & Chr(RecBuf[11]) & Chr(RecBuf[12]))
      ELSE
        iRSSI = Val("&H" & Chr(RecBuf[9]) & Chr(RecBuf[10]))
      ENDIF

      ' calculate duration if extension bit is set
      IF (iCmd AND &H20) THEN
        iDur = Val("&H" & Chr(RecBuf[9]) & Chr(RecBuf[10]))
        iI = (iDur AND &HF0) / 16
        iJ = (iDur AND &HF)
        iDur = (iI ^ 2) * iJ * 0.25

        ' calculate cmd
        iCmd = iCmd XOR &H20
      ENDIF

      ' test if cmd value is known
      TRY sValue = sFS20Values[iCmd]
      IF NOT ERROR THEN
        IF bCULDebug THEN Main.WriteDebugLog(("[CUL] FS20 message received with address '") & sHouseCode & sAddress & "' (" & Hex2Four(sHouseCode & sAddress) & ") and command '" & sValue & "'" & IIf(iDur, " duration: " & iDur, "") & IIf(iRSSI, " rssi: " & iRSSI, ""))
        ' find device id
        iDeviceId = Devices.Find(sHouseCode & sAddress, Devices.FindInterface("CUL Interface"), "FS20")
        IF iCmd < 17 THEN
          ' update value1
          IF iDeviceId THEN Devices.ValueUpdate(iDeviceId, sValue, "", "", "")
        ELSE
          ' update value2
          IF iDeviceId THEN Devices.ValueUpdate(iDeviceId, "", sValue, "", "")
        ENDIF
      ELSE
        IF bCULDebug THEN Main.WriteDebugLog(("[CUL] FS20 message received with address '") & sHouseCode & sAddress & "' (" & Hex2Four(sHouseCode & sAddress) & ") and unknown/invalid command '" & Hex(iCmd) & "'")
      ENDIF
    CASE "T" ' FHT messages
      ' check for valid packet size
      IF iByteCount < 9 OR IF iByteCount > 13 THEN
        IF bCULDebug THEN Main.WriteDebugLog(("[CUL] FHT message received with invalid length of " & iByteCount & " bytes!"))
        RETURN
      ENDIF

      sAddress = Chr(RecBuf[1]) & Chr(RecBuf[2]) & Chr(RecBuf[3]) & Chr(RecBuf[4]) & Chr(RecBuf[5]) & Chr(RecBuf[6])
      iCmd = Val("&H" & Chr(RecBuf[7]) & Chr(RecBuf[8]))

      IF iByteCount = 10 THEN ' must be FHT FTK sensor
        ' T <Hex>
        ' <Hex> is a hex string with the following format:
        ' ccccccxx
        ' where cccccc being the id of the sensor in hex
        ' xx being the current status like 'open,close,sync,test,battlow'
        SELECT CASE iCmd
          CASE &H02, &H82
            sValue = "Closed"
            sBatt = "Ok"
          CASE &H01, &H81
            sValue = "Open"
            sBatt = "Ok"
          CASE &H11, &H91
            sValue = "Open"
            sBatt = "Low"
          CASE &H12, &H92
            sValue = "Closed"
            sBatt = "Low"
          CASE &H0C
            sValue2 = "Sync:Syncing"
          CASE &H0F
            sValue2 = "Test:Success"
        END SELECT

        IF bCULDebug THEN Main.WriteDebugLog(("[CUL] FHT TFK message received with address '") & sHouseCode & sAddress & "', status '" & IIf(Len(sValue2), sValue2, sValue) & "' and battery level '" & sBatt & "'")
        ' find device id
        iDeviceId = Devices.Find(sHouseCode & sAddress, Devices.FindInterface("CUL Interface"), "FHTTFK")
        IF iDeviceId THEN
          ' update values
          Devices.ValueUpdate(iDeviceId, sValue, sValue2, "", "")
          ' store battery status
          IF (Len(sBatt) > 1) THEN Devices.Battery(iDeviceId, sBatt)
        ENDIF
      ELSE ' FHT80 message
        ' T15157D671216
        ' T15177E7712FA
        ' T5A334369001A
        ' T <Hex>
        ' <Hex> is a hex string with the following format:
        ' Thhhhccnnvvxx
        ' hhhh = address
        ' cc = command
        ' nn = report value / id
        ' vv = value
        ' xx = rssi
        sAddress = Chr(RecBuf[1]) & Chr(RecBuf[2]) & Chr(RecBuf[3]) & Chr(RecBuf[4])
        iCmd = Val("&H" & Chr(RecBuf[5]) & Chr(RecBuf[6]))
        sCmd = FHTCode(iCmd)

        IF iByteCount > 9 THEN
          sVal = Val("&H" & (Chr(RecBuf[9]) & Chr(RecBuf[10])))
        ELSE IF iByteCount < 9 THEN
          sCmd = "FHT short message"
          sVal = ""
        ENDIF

        IF iByteCount > 11 THEN
          ' rssi
          iRSSI = Val("&H" & Chr(RecBuf[11]) & Chr(RecBuf[12]))
        ENDIF

        ' IF NOT Len(sVal) OR IF sCmd = "report1" OR IF sCmd = "report2" THEN
        IF sCmd = "report1" OR IF sCmd = "report2" THEN
          sVal = Val("&H" & (Chr(RecBuf[7]) & Chr(RecBuf[8])))
          bConfirm = TRUE
        ENDIF

        IF InStr(sCmd, "-from") OR IF InStr(sCmd, "-to") THEN ' time format
          sVal = Format(Val(sVal) / 6, "0#") & ":" & Format((Val(sVal) MOD 6) * 10, "0#")
        ELSE IF sCmd = "mode" ' auto, manual, holiday, holiday-short
          sVal = aFHTc2m[sVal]
        ELSE IF InStr(sCmd, "-temp")
          sVal = sVal / 2
          sVal = Format(sVal, "#.0")
        ELSE IF sCmd = "lowtemp-offset"
          sVal = Format(sVal, "#.0")
        ELSE IF InStr(sCmd, "actuator")
          sSval = Chr(RecBuf[9]) & Chr(RecBuf[10])
          sFv = (100 * Val(sVal) / 255 + 0.5) & "%"
          sId = Chr(RecBuf[8])
          IF sSval = "A0" OR IF sSval = "B0" THEN
            sVal = sFv ' sync in the summer
          ELSE IF Right(sSval, 1) = "0" THEN
            sVal = "syncnow"
          ELSE IF Right(sSval, 1) = "1" THEN
            sVal = "99%" ' FHT set to 30.5, FHT80B="ON"
          ELSE IF Right(sSval, 1) = "2" THEN
            sVal = "0%" ' FHT set to 5.5
          ELSE IF Right(sSval, 1) = "6" THEN
            sVal = sFv
          ELSE IF Right(sSval, 1) = "8" THEN
            sVal = "offset: " & sFv
          ELSE IF sSval = "2A" OR IF sSval = "3A" THEN
            sVal = "lime-protection"
          ELSE IF sSval = "AA" OR IF sSval = "BA" THEN
            sVal = sFv ' lime protection bug
          ELSE IF Right(sSval, 1) = "C" THEN
            sVal = "synctime: " & (Val(sVal) / 2) - 1
          ELSE IF Right(sSval, 1) = "E" THEN
            sVal = "test"
          ELSE IF Right(sSval, 1) = "F" THEN
            sVal = "pair"
          ELSE
            sVal = "unknown"
          ENDIF

          IF InStr(sVal, "%") AND IF sId = 0 THEN
            IF bCULDebug THEN Main.WriteDebugLog(("[CUL] Position " & sId & " " & sVal))
          ENDIF
        ELSE IF sCmd = "measured-low"
          sVal /= 10
          sVal = Format(sVal, "#.0")
        ELSE IF sCmd = "measured-high"
        'PRINT sVal
          sOffset = 0
          sVal = sVal * 256
          sVal = sVal / 10
          sVal = Format(sVal, "#.0")
          'sCmd = "measured-temp"
        ELSE IF sCmd = "warnings"
          IF (sVal AND 1) THEN
            sWarn = "Battery low"
            sBatt = "Low"
          ENDIF
          IF (sVal AND 2) THEN
            IF sWarn THEN sWarn &= "; "
            sWarn &= "Temp too low"
            sLowTemp = "Warn"
          ENDIF
          IF (sVal AND 32) THEN
            IF sWarn THEN sWarn &= "; "
            sWarn &= "Window open"
            sWindow = "Open"
          ENDIF
          IF (sVal AND 16) THEN
            IF sWarn THEN sWarn &= "; "
            sWarn &= "Window sensor fault"
            sSensor = "Fault"
          ENDIF
          ' default value if not set
          IF NOT Len(sBatt) THEN sBatt = "Ok"
          IF NOT Len(sLowTemp) THEN sLowTemp = "Ok"
          IF NOT Len(sWindow) THEN sWindow = "Closed"
          IF NOT Len(sSensor) THEN sSensor = "Ok"
          IF NOT Len(sWarn) THEN sWarn = "None"
      ENDIF
      IF bCULDebug THEN
        Main.WriteDebugLog(("[CUL] FHT message received with address '") & sAddress & "' command '" & sCmd & "' (" & Hex(iCmd) & ") sval '" & sVal & "'" & IIf(iRSSI, " rssi: " & iRSSI, ""))
        IF Len(sWarn) THEN Main.WriteDebugLog(("[CUL] Warnings ") & sWarn)
        IF Len(sBatt) THEN Main.WriteDebugLog(("[CUL] Battery ") & sBatt)
        IF Len(sLowTemp) THEN Main.WriteDebugLog(("[CUL] LowTemp ") & sLowTemp)
        IF Len(sSensor) THEN Main.WriteDebugLog(("[CUL] Sensor ") & sSensor)
        IF Len(sWindow) THEN Main.WriteDebugLog(("[CUL] Window ") & sWindow)
      ENDIF
      ENDIF
    CASE "E"
      ' E <Hex>
      ' EM message. <Hex> is a hex string with the following format:
      ' Ettaacc111122223333
      ' tt: type 01 = EM-1000S, 02 = EM-1000EM, 03 = EM-1000GZ
      ' aa: address, depending on the type above 01: 01-04, 02: 05-08, 03: 09-12
      ' cc: counter, will be incremented by one for each message
      ' 1111: cumulated value
      ' 2222: last value(not set for type 2)
      ' 3333: top value(not set for type 2)
      sEMType = Chr(RecBuf[1]) & Chr(RecBuf[2])
      sAddress = Chr(RecBuf[3]) & Chr(RecBuf[4])
      sEMCumulValue = Chr(RecBuf[7]) & Chr(RecBuf[8]) & Chr(RecBuf[9]) & Chr(RecBuf[10])
      sMsgCounter = Chr(RecBuf[5]) & Chr(RecBuf[6])
      TRY sValue = Chr(RecBuf[11]) & Chr(RecBuf[12]) & Chr(RecBuf[13]) & Chr(RecBuf[14])
      TRY sEMPeakValue = Chr(RecBuf[15]) & Chr(RecBuf[16]) & Chr(RecBuf[17]) & Chr(RecBuf[18])

      IF bCULDebug THEN Main.WriteDebugLog(("[CUL] EM message received sensor '") & aEMType[Val(sEMType)] & "' [" & sEMType & "]" & " with address '" & sAddress & "' cumulated value: " & sEMCumulValue & (" last: ") & sValue & (" top: ") & sEMPeakValue & (" msg count: ") & Val("&H" & sMsgCounter))

      iDeviceId = Devices.Find(sAddress, Devices.FindInterface("CUL Interface"), "EM1000")
      ' update value
      IF iDeviceId THEN Devices.ValueUpdate(iDeviceId, sEMCumulValue, sValue, sEMPeakValue, "")
    CASE "V"
      IF bCULDebug THEN Main.WriteDebugLog(("[CUL] Version string received."))
    CASE ELSE
      Main.WriteDebugLog(("[CUL] Unknown/unsupported message format received!"))
  END SELECT
  Main.ControlLed("CUL", "Off")

CATCH
   Main.WriteDebugLog(("[CUL] ERROR: " & Error.Text & " at " & Error.Where & " Parsing CUL data packet: ") & DisplayPacket(RecBuf))

END

' converting CUL Hex IDs into ELV-4-Ids
PRIVATE SUB Hex2Four(sHex AS String) AS String

  DIM iCnt AS Integer
  DIM sELV AS String

  FOR iCnt = 1 TO Len(sHex)
    sELV &= Left(Str((Val("&H" & Mid(sHex, iCnt, 1)) / 4) + 1), 1)
    sELV &= (Val("&H" & Mid(sHex, iCnt, 1)) MOD 4) + 1
  NEXT
  RETURN sELV

END

PRIVATE SUB FHTCode(iCode AS Byte) AS String

  SELECT CASE iCode
    CASE &H00
      RETURN "actuator"
    CASE &H01
      RETURN "actuator1"
    CASE &H02
      RETURN "actuator2"
    CASE &H03
      RETURN "actuator3"
    CASE &H04
      RETURN "actuator4"
    CASE &H05
      RETURN "actuator5"
    CASE &H06
      RETURN "actuator6"
    CASE &H07
      RETURN "actuator7"
    CASE &H08
      RETURN "actuator8"
    CASE &H14
      RETURN "mon-from1"
    CASE &H15
      RETURN "mon-to1"
    CASE &H16
      RETURN "mon-from2"
    CASE &H17
      RETURN "mon-to2"
    CASE &H18
      RETURN "tue-from1"
    CASE &H19
      RETURN "tue-to1"
    CASE &H1A
      RETURN "tue-from2"
    CASE &H1B
      RETURN "tue-to2"
    CASE &H1C
      RETURN "wed-from1"
    CASE &H1D
      RETURN "wed-to1"
    CASE &H1E
      RETURN "wed-from2"
    CASE &H1F
      RETURN "wed-to2"
    CASE &H20
      RETURN "thu-from1"
    CASE &H21
      RETURN "thu-to1"
    CASE &H22
      RETURN "thu-from2"
    CASE &H23
      RETURN "thu-to2"
    CASE &H24
      RETURN "fri-from1"
    CASE &H25
      RETURN "fri-to1"
    CASE &H26
      RETURN "fri-from2"
    CASE &H27
      RETURN "fri-to2"
    CASE &H28
      RETURN "sat-from1"
    CASE &H29
      RETURN "sat-to1"
    CASE &H2A
      RETURN "sat-from2"
    CASE &H2B
      RETURN "sat-to2"
    CASE &H2C
      RETURN "sun-from1"
    CASE &H2D
      RETURN "sun-to1"
    CASE &H2E
      RETURN "sun-from2"
    CASE &H2F
      RETURN "sun-to2"
    CASE &H3E
      RETURN "mode"
    CASE &H3F
      RETURN "holiday1"
    CASE &H40
      RETURN "holiday2"
    CASE &H41
      RETURN "desired-temp"
    CASE &H42
      RETURN "measured-low"
    CASE &H43
      RETURN "measured-high"
    CASE &H44
      RETURN "warnings"
    CASE &H45
      RETURN "manu-temp"
    CASE &H4B
      RETURN "ack"
    CASE &H53
      RETURN "can-xmit"
    CASE &H54
      RETURN "can-rcv"
    CASE &H60
      RETURN "year"
    CASE &H61
      RETURN "month"
    CASE &H62
      RETURN "day"
    CASE &H63
      RETURN "hour"
    CASE &H64
      RETURN "minute"
    CASE &H65
      RETURN "report1"
    CASE &H66
      RETURN "report2"
    CASE &H69
      RETURN "ack2"
    CASE &H7D
      RETURN "start-xmit"
    CASE &H7E
      RETURN "end-xmit"
    CASE &H82
      RETURN "day-temp"
    CASE &H84
      RETURN "night-temp"
    CASE &H85
      RETURN "lowtemp-offset"
    CASE &H8A
      RETURN "windowopen-temp"
    CASE ELSE
      RETURN "unknown"
    END SELECT

END

PRIVATE SUB DisplayPacket(bBuf AS Byte[]) AS String

  DIM sMsg AS String
  DIM iCnt AS Integer

  FOR iCnt = 0 TO iByteCount
    sMsg &= Chr(bBuf[iCnt])
  NEXT
  RETURN sMsg

END

' implement properties
PRIVATE FUNCTION TCPHost_Read() AS String

  RETURN sTCPHost

END

PRIVATE SUB TCPHost_Write(Value AS String)

  sTCPHost = Value

END

PRIVATE FUNCTION TCPPort_Read() AS Integer

  RETURN iTCPPort

END

PRIVATE SUB TCPPort_Write(Value AS Integer)

  iTCPPort = Value

END

PRIVATE FUNCTION Interface_Read() AS String

  RETURN sInterface

END

PRIVATE SUB Interface_Write(Value AS String)

  sInterface = Value

END

PRIVATE FUNCTION Baud_Read() AS String

  RETURN sBaud

END

PRIVATE SUB Baud_Write(Value AS String)

  sBaud = Value

END

PRIVATE FUNCTION SerPort_Read() AS String

  RETURN sSerPort

END

PRIVATE SUB SerPort_Write(Value AS String)

  sSerPort = Value

END

PRIVATE FUNCTION CULDebug_Read() AS Boolean

  RETURN bCULDebug

END

PRIVATE SUB CULDebug_Write(Value AS Boolean)

  bCULDebug = Value

END

PRIVATE FUNCTION Model_Read() AS Integer

  RETURN iModel

END

PRIVATE SUB Model_Write(Value AS Integer)

  iModel = Value

END

PRIVATE FUNCTION AutoCreate_Read() AS Boolean

  RETURN bAutoCreate

END

PRIVATE SUB AutoCreate_Write(Value AS Boolean)

  bAutoCreate = Value

END

PRIVATE FUNCTION FHTid_Read() AS String

  RETURN sFHTid

END

PRIVATE SUB FHTid_Write(Value AS String)

  sFHTid = Value

END
