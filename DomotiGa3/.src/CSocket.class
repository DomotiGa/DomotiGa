' Gambas class file

' Description:
' CSocket.class
' Support none-SSL and SSL TCP sockets

' Development Status:
' Finished

' DomotiGa - an open source home automation program.
' Copyright (C) Ron Klinkien, The Netherlands.

' Read file called COPYING for license details.

'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
' Define external OpenSSL library calls. We support 0.9.8/1.0.x/1.1.x
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Library "libcrypto"
Private Extern SSLeay_version(iInt As Integer) As String

Library "libssl"
Private Extern SSL_library_init()
Private Extern SSL_load_error_strings()
Private Extern SSLv23_method() As Pointer ' deprecated in OpenSSL 1.1.x
Private Extern TLS_method() As Pointer ' new in OpenSSL 1.1.x
Private Extern SSL_CTX_new(pCTX As Pointer) As Pointer
Private Extern SSL_CTX_free(pCTX As Pointer)
Private Extern SSL_CTX_ctrl(pCTX As Pointer, iCmd As Integer, lOptions As Long, pParm As Pointer) As Long
Private Extern SSL_new(pCTX As Pointer) As Pointer
Private Extern SSL_free(pSSL As Pointer)
Private Extern SSL_shutdown(pSSL As Pointer) As Integer
Private Extern SSL_set_fd(pSSL As Pointer, iFd As Integer) As Integer
Private Extern SSL_read(pSSL As Pointer, pData As Pointer, iLen As Integer) As Integer
Private Extern SSL_write(pSSL As Pointer, pData As Pointer, iLen As Integer) As Integer
Private Extern SSL_accept(pSSL As Pointer) As Integer
Private Extern SSL_connect(pSSL As Pointer) As Integer
Private Extern SSL_get_error(pSSL As Pointer, iRC As Integer) As Integer

'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
' My events
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Event {Closed}
Event {Error}(sError As String)
Event {Found}
Event {Read}(vData As Variant)
Event {Ready}
Event {WebSocketReady}
Event {Write}
Event {Reconnect} ' Only applicable in client mode
Event {Authorization}(sData As String)

'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
' Constants
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Public Const SSL_ERROR_NONE As Integer = 0
Public Const SSL_ERROR_SSL As Integer = 1
Public Const SSL_ERROR_WANT_READ As Integer = 2
Public Const SSL_ERROR_WANT_WRITE As Integer = 3
Public Const SSL_ERROR_WANT_X509_LOOKUP As Integer = 4
Public Const SSL_ERROR_SYSCALL As Integer = 5
Public Const SSL_ERROR_ZERO_RETURN As Integer = 6
Public Const SSL_ERROR_WANT_CONNECT As Integer = 7
Public Const SSL_ERROR_WANT_ACCEPT As Integer = 8

Public Const PROTOCOL_NONE As Integer = 0 ' RAW
Public Const PROTOCOL_HTTP As Integer = 1
Public Const PROTOCOL_HTTP_WEBSOCKET As Integer = 2 ' Only allowed in server mode
Public Const PROTOCOL_WEBSOCKET As Integer = 3 ' WebSocket RFC6455

'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
' Properties
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Property Debug As Boolean
Property EndOfLine As Integer
Property Read Handle As Integer
Property Host As String
Property Read LocalHost As String
Property Read LocalPort As Integer
Property Path As String
Property Port As Integer
Property Read RemoteHost As String
Property Read RemotePort As Integer
Property Read Status As Integer
Property Timeout As Integer
Property Tag As Variant
Property Protocol As Integer
Property ReadTimeOut As Integer
Property Server As Object
Property DataType As Integer
Property ReconnectRetry As Integer
Property Encrypt As Integer

' HTTP Server
Property HTTPCode As Integer
Property HTTPKeepAlive As Integer
Property HTTPSize As Integer
Property HTTPMethods As String[]
Property HTTPContentTypes As String[]
Property HTTPHeaders As String[]
Property HTTPRequestInUrl As String
Property HTTPRAWInUrl As String

' HTTP Client
Property HTTPMethod As String ' GET or POST
Property HTTPUrl As String ' / or something else

Property WebSocketOpcode As String
Property WebSocketTextBinary As String
Property WebSocketOrigin As String

'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
' Variables
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Private LogLabel As String = "[Socket]"
Private $bDebug As Boolean = False
Private $iEndOfLine As Integer = gb.Unix
Private $iTimeout As Integer = 0
Private $iEncrypt As Integer = Net.None ' 0=Net.None, 1=Net.SSL
Private $iProtocol As Integer = PROTOCOL_NONE
Private $iSSLBufferSize As Integer = 2048 ' The SSL buffer size for reading the socket
Private $pCTX As Pointer
Private $pSSL As Pointer
Private $bSSLAcceptHandshake As Boolean
Private $sDataIn As String
Private $sDataInExtra As String
Private $sDataOut As String
Private $cServer As Object
Private $sSSLVersion As String
Private $sSSLVersionId As String
Private $lSSLMethod As Long
Private $iDataType As Integer = gb.String
Public MySocket As Socket
Private $bEventClosedRaised As Boolean = False

Private $iReadTimeOut As Integer = 200 '*0.005

Public $tHTTPTimer As Timer
Private $iHTTPCode As Integer
Private $iHTTPSize As Integer = 65535 ' 64kByte
Private $cHTTPMethods As New String[]
Private $cHTTPContentTypes As New String[]
Private $sHTTPMethodIn As String = ""
Private $cHTTPHeaders As New String[]
Private $sHTTPRequestInUrl As String ' Request URL, will be URL Decoded
Private $sHTTPRAWInUrl As String ' Handy if you want to parse the data yourself, before URL Decoding
Private $iHTTPKeepAlive As Integer = 15000
Private $cHTTPConnection As New String[]
Private $bHTTPDeflate As Boolean = False
Private $sHTTPCrossOrigin As String
Private $sHTTPAccessControlRequestHeaders As String
Private $sHTTPMethod As String = "GET"
Private $sHTTPUrl As String = "/"
Private $sHTTPAuthorization As String

Private $sWebSocketOpCode As String
Private $bWebSocketMask As Boolean
Private $sWebSocketTextBinary As String = "text"
Private $lWebSocketSize As Long = 1048576 ' 1MByte
Private $sWebSocketProtocol As String
Private $bWebSocketEnabled As Boolean
Private $bWebSocketInit As Boolean
Private $sWebSocketHandShake As String
Private $bWebSocketFIN As Boolean
Private $iWebSocketCloseCode As Integer
'Private $sWebSocketCloseText As String
Private $sWebSocketMultiPacket As String
Private $sWebSocketPrevOpCode As String
Private $sWebSocketOrigin As String = "http://localhost"

' Reconnect - we raise an Event if it happened
Public tReconnect As Timer
Private $iReconnectRetry As Integer = 0 ' retries
Private $aReconnectDelay As Integer[] = [5000, 10000, 20000, 30000, 60000, 120000, 300000, 900000, 1800000, 3600000, 7200000, 14400000, 14400000, 14400000, 14400000] ' 5sec, 5sec, 10sec, 20sec, 30sec, 1min, 2min, 5min, 15min, 1/2hour, 1hour, 2hours, 4hours (4x)

'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
' Called when Class is created
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Public Sub _new(Optional iReconnectRetry As Integer = -1)

  MySocket = New Socket As "Socket"

  $cHTTPMethods.Insert(["POST", "GET", "OPTIONS", "HEAD", "PUT", "DELETE", "TRACE", "CONNECT"])

  ' Use the reconnectretry if a valid value is supplied
  If iReconnectRetry >= 0 Then
    $iReconnectRetry = iReconnectRetry
  Endif

End

'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
' Called when Class is destroyed, free/close used variables
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Public Sub _free()

  'If $pCTX <> Null Then
  '  Try SSL_CTX_free($pCTX)
  'Endif

  If $pSSL <> Null Then
    Try SSL_shutdown($pSSL)
    Try SSL_free($pSSL)
    $pSSL = Null
  Endif

  Try $tHTTPTimer.Stop
  Try Close #MySocket

End

'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
' Read None-SSL and SSL data from socket
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Public Sub Socket_Read()

  Dim sData As String
  Dim pData As Pointer
  Dim aData As Byte[]
  Dim iLen As Integer
  Dim iRet As Integer
  Dim bDeny As Boolean

  If $iEncrypt = Net.SSL Then

    If $bDebug Then Main.WriteDebugLog(Loglabel & "Event=Read")

    If $pSSL = Null Then
      Raise Error("SSL Object has Null value (SSL_read)")
      Return
    Endif 

    If Not $bSSLAcceptHandshake Then
      iRet = SSL_accept($pSSL)
      If iRet = 1 Then
        $bSSLAcceptHandshake = True

        ' Raise Ready event if the SSL handshake is done succesfully
        Raise Ready

        ' Now we can also raise Write event
        Raise Write
      Else
        If iRet = -1 Then
          Try iRet = SSL_get_error($pSSL, iRet)
          If iRet <> SSL_ERROR_WANT_READ And If iRet <> SSL_ERROR_WANT_WRITE Then
            If $pSSL <> Null Then
              Try SSL_shutdown($pSSL)
              Try SSL_free($pSSL)
              $pSSL = Null
            Endif

            Raise Error("SSL handshake failed RC=" & iRet & " (" & Display_SSL_ERROR(iRet) & ")")
            Close()
            Return
          Endif
        Endif

      Endif
    Endif

    ' Don't continue if the handshake didn't succeed
    If Not $bSSLAcceptHandshake Then Return

    ' Allocate a read buffer for the read routine
    pData = Alloc($iSSLBufferSize)

    Repeat
      iLen = SSL_read($pSSL, pData, $iSSLBufferSize)

      If iLen < 0 Then
        '
        iRet = SSL_get_error($pSSL, iLen)

      Else If iLen = 0 Then
        ' Socket gone or almost gone
      Else
        ' We have read data from the socket, append it to our string
        sData &= String@(pData, iLen)
      Endif

      ' Run until SSL_read returns zero, or our buffer is empty
    Until iLen <= 0 Or Lof(Last) = 0

    If $bDebug Then Main.WriteDebugLog(LogLabel & "Event=Read, Length=" & Len(sData) & ", Status=" & Last.Status)

    Free(pData)

  Else
    iLen = Lof(Last)
    If $bDebug Then Main.WriteDebugLog(LogLabel & "Event=Read, Length=" & iLen & ", Status=" & Last.Status)

    ' No SSL, just read the socket
    Read #Last, sData, Lof(Last)
  Endif

  ' Data read, raise the read event for further processing
  If sData Then

    If $iProtocol = PROTOCOL_HTTP Or If ($iProtocol = PROTOCOL_HTTP_WEBSOCKET And Not $bWebSocketEnabled) Or If ($iProtocol = PROTOCOL_WEBSOCKET And Not $bWebSocketEnabled) Then

      If $sDataIn Then
        ' Don't continue, the other loop will pick of the changes
        $sDataIn &= sData
        Return
      Else
        If $cServer Then
          ' Server mode

          ' Do a repeat/until loop, for HTTP/1.1 requests
          Repeat
            $sHTTPMethodIn = ""
            $cHTTPConnection.Clear()
            $bHTTPDeflate = False
            $sHTTPCrossOrigin = ""
            $sHTTPAccessControlRequestHeaders = ""
            $sHTTPAuthorization = ""

            $sDataIn &= $sDataInExtra & sData
            $sDataInExtra = ""

            If Protocol_HTTPServer_Read() Then

              ' If we received an Authorization header, raise it as an event. Application needs to handle it
              bDeny = Raise Authorization($sHTTPAuthorization)

              If bDeny Then
                $sDataInExtra = ""

                $iHTTPCode = 401 'Unauthorized
                Send()
                Close()
              Else

                Select $iDataType
                  Case &HFF + gb.Byte
                    aData = New Byte[]
                    For iLen = 1 To Len($sDataIn)
                      aData.Add(Asc($sDataIn, iLen))
                    Next

                    Raise Read(aData)
                  Case gb.Byte
                    For iLen = 1 To Len($sDataIn)
                      Raise Read(Asc($sDataIn, iLen))
                    Next
                  Default
                    Raise Read($sDataIn)
                End Select
              Endif

            Endif

            $sDataIn = ""
          Until Not $sDataInExtra
        Else
          ' Client mode
          ' TODO
          ' Do a repeat/until loop, for HTTP/1.1 requests
          Repeat
            $sHTTPMethodIn = ""
            $cHTTPConnection.Clear()
            $bHTTPDeflate = False
            $sHTTPCrossOrigin = ""
            $sHTTPAccessControlRequestHeaders = ""
            $sHTTPAuthorization = ""

            $sDataIn &= $sDataInExtra & sData
            $sDataInExtra = ""

            If Protocol_HTTPClient_Read() Then

              Select $iDataType
                Case &HFF + gb.Byte
                  aData = New Byte[]
                  For iLen = 1 To Len($sDataIn)
                    aData.Add(Asc($sDataIn, iLen))
                  Next
        
                  Raise Read(aData)
                Case gb.Byte
                  For iLen = 1 To Len($sDataIn)
                    Raise Read(Asc($sDataIn, iLen))
                  Next
                Default
                  Raise Read($sDataIn)
              End Select

            Endif

            $sDataIn = ""
          Until Not $sDataInExtra
        Endif
       Endif

    Else
      If $bWebSocketEnabled Then

        If $sDataIn Then
          ' Don't continue, the other loop will pick of the changes
          $sDataIn &= sData
          Return
        Else
          Repeat
            $sWebSocketOpCode = ""
            $bWebSocketMask = False

            $sDataIn &= $sDataInExtra & sData
            $sDataInExtra = ""

            If Protocol_WebSocket_Read() Then

              ' This isn't a single packet, but split across multiple websocket packets
              If Not $bWebSocketFIN And ($sWebSocketOpCode = "text" Or $sWebSocketOpCode = "binary") Then
                $sWebSocketMultiPacket &= $sDataIn
                $sWebSocketPrevOpCode = $sWebSocketOpCode
              Else
                If $bWebSocketFIN And $sWebSocketOpCode = "continue" Then
                  ' Only allow it, if we found previous data
                  If $sWebSocketMultiPacket Then

                    Select $iDataType
                      Case &HFF + gb.Byte
                        $sWebSocketMultiPacket &= $sDataIn
                        aData = New Byte[]
                        For iLen = 1 To Len($sWebSocketMultiPacket)
                          aData.Add(Asc($sWebSocketMultiPacket, iLen))
                        Next

                        Raise Read(aData)
                      Case gb.Byte
                        $sWebSocketMultiPacket &= $sDataIn
                        For iLen = 1 To Len($sWebSocketMultiPacket)
                          Raise Read(Asc($sWebSocketMultiPacket, iLen))
                        Next
                      Default
                        Raise Read($sWebSocketMultiPacket & $sDataIn)
                    End Select

                  Else
                    ' Discard this one, it looks to be invalid
                  Endif
                Else
                  If $sWebSocketOpCode = "text" Or $sWebSocketOpCode = "binary" Then

                    Select $iDataType
                      Case &HFF + gb.Byte
                        aData = New Byte[]
                        For iLen = 1 To Len($sDataIn)
                          aData.Add(Asc($sDataIn, iLen))
                        Next

                        Raise Read(aData)
                      Case gb.Byte
                        For iLen = 1 To Len($sDataIn)
                          Raise Read(Asc($sDataIn, iLen))
                        Next
                      Default
                        Raise Read($sDataIn)
                    End Select

                  Else If $sWebSocketOpCode = "ping" Then
                    ' We got a ping, lets return a pong :-)
                  Endif
                Endif

                $sWebSocketMultiPacket = ""
              Endif
            Endif

            $sDataIn = ""
          Until Not $sDataInExtra
        Endif
      Else
        ' Just send the read data to the application to handle it
        $sDataIn = ""
        Select $iDataType
          Case &HFF + gb.Byte
            aData = New Byte[]
            For iLen = 1 To Len(sData)
              aData.Add(Asc(sData, iLen))
            Next

            Raise Read(aData)
          Case gb.Byte
            For iLen = 1 To Len(sData)
              Raise Read(Asc(sData, iLen))
            Next
          Default
            Raise Read(sData)
        End Select
      Endif
    Endif
  Endif

End

'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
' Handle HTTP data and only return the body of the request upstream
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Private Sub Protocol_HTTPServer_Read() As Boolean

  Dim iWait As Integer = 1
  Dim iCount As Integer
  Dim iPos As Integer
  Dim iLen As Integer
  Dim sHTTPHeader As String
  Dim cHTTPHeader As New Collection
  Dim sHTTPHeaderTemp As String
  Dim sHTTPProtocol As String
  Dim iHTTPContentLength As Integer
  Dim sHTTPContentType As String
  Dim bHTTPChunked As Boolean = False
  Dim bDeny As Boolean

  Try $tHTTPTimer.Stop
  $tHTTPTimer = Null

  ' At least wait until we retrieve the http headers
  For iCount = 1 To $iReadTimeOut Step 1
    iPos = InStr($sDataIn, gb.CrLf & gb.CrLf)
    If iPos >= 1 Then Break
    Wait 0.005
  Next

  ' Problem with reading valid http data
  If iCount > $iReadTimeOut Then
    Close()
    Return False
  Else
    iWait = iCount
  Endif

  sHTTPHeader = Left($sDataIn, iPos)
  iPos = InStr(sHTTPHeader, Chr(13))
  If iPos >= 1 Then
    sHTTPHeaderTemp = Left(sHTTPHeader, iPos - 1)
  Else
    Close()
    Return False
  Endif

  ' Look for the http method
  iPos = InStr(sHTTPHeaderTemp, " ") - 1
  If iPos >= 1 Then
    $sHTTPMethodIn = Left(sHTTPHeaderTemp, iPos)
  Else
    Close()
    Return False
  Endif

  iPos = RInStr(sHTTPHeaderTemp, " ") + 1
  If iPos > 1 Then
    sHTTPProtocol = Mid(sHTTPHeaderTemp, iPos)

    If sHTTPProtocol <> "HTTP/1.0" And If sHTTPProtocol <> "HTTP/1.1" Then
      $iHTTPCode = 505 'HTTP Version Not Supported
      Send()
      Close()
      Return False
    Endif
  Else
    Close()
    Return False
  Endif

  ' Only allow certain methods
  If Not $cHTTPMethods.Exist($sHTTPMethodIn) Then
    $iHTTPCode = 405 'Not Allowed
    Send()
    Close()
    Return False
  Endif

  For Each sHTTPHeaderTemp In Split(Mid(sHTTPHeader, iPos + Len(sHTTPProtocol) + 1), gb.CrLf)
    iPos = InStr(sHTTPHeaderTemp, ":")
    If iPos > 0
      cHTTPHeader[UCase(Left(sHTTPHeaderTemp, iPos - 1))] = Trim(Right(sHTTPHeaderTemp, -1 * (iPos + 1)))
    Endif
  Next

  If cHTTPHeader.Exist("ACCEPT-ENCODING") Then
    If InStr(UCase(cHTTPHeader["ACCEPT-ENCODING"]), "DEFLATE") Then $bHTTPDeflate = True
  Endif

  If cHTTPHeader.Exist("CONTENT-LENGTH") Then
    Try iHTTPContentLength = CInt(cHTTPHeader["CONTENT-LENGTH"])
    If Error Then
      $iHTTPCode = 411 'Length Required
      Send()
      Close()
      Return False
    Endif

    If iHTTPContentLength < 0 Then
      $iHTTPCode = 400 'Bad Request
      Send()
      Close()
      Return False
    Endif
  Else
    If cHTTPHeader.Exist("TRANSFER-ENCODING") Then
      If InStr(UCase(cHTTPHeader["TRANSFER-ENCODING"]), "CHUNKED") Then bHTTPChunked = True

      If Not bHTTPChunked Then
        $iHTTPCode = 400 'Bad Request
        Send()
        Close()
        Return False
      Endif
    Endif
  Endif

  If cHTTPHeader.Exist("CONTENT-TYPE") Then
    If InStr(cHTTPHeader["CONTENT-TYPE"], ";") Then cHTTPHeader["CONTENT-TYPE"] = Left(cHTTPHeader["CONTENT-TYPE"], InStr(cHTTPHeader["CONTENT-TYPE"], ";") - 1)

    sHTTPHeaderTemp = UCase($cHTTPContentTypes.Join(";"))
    $cHTTPContentTypes = Split(sHTTPHeaderTemp, ";")
  Endif

  If $cHTTPContentTypes.Count > 0 Then
    If cHTTPHeader.Exist("CONTENT-TYPE") Or If Not $cHTTPContentTypes.Exist(sHTTPContentType) Then
      $iHTTPCode = 415 'Unsupported Media Type
      Send()
      Close()
      Return False
    Endif
  Endif

  If cHTTPHeader.Exist("ORIGIN") Then
    If InStr(cHTTPHeader["ORIGIN"], "http://localhost") Then
      $sHTTPCrossOrigin = "*"
    Else
      $sHTTPCrossOrigin = cHTTPHeader["ORIGIN"]
    Endif

    ' Maybe we got a "Access-Control-Request-Headers" too?
    If cHTTPHeader.Exist("ACCESS-CONTROL-REQUEST-HEADERS") Then
      $sHTTPAccessControlRequestHeaders = cHTTPHeader["ACCESS-CONTROL-REQUEST-HEADERS"]
    Endif
  Endif

  If cHTTPHeader.Exist("CONNECTION") Then
  iPos = InStr(UCase(sHTTPHeader), Chr(10) & "CONNECTION:")
    $cHTTPConnection = Split(UCase(Replace(cHTTPHeader["CONNECTION"], " ", "")), ",")

    ' Don't accept upgrades on normal HTTP requests
    If $cHTTPConnection.Exist("UPGRADE") And If $iProtocol = PROTOCOL_HTTP Then
      $iHTTPCode = 400 'Bad Request
      Send()
      Close()
      Return False
    Endif
  Endif

  ' We received a HTTP Authentication basic header
  If cHTTPHeader.Exist("AUTHORIZATION") Then
    If InStr(cHTTPHeader["AUTHORIZATION"], "Basic ", gb.IgnoreCase) = 1 Then
      ' Store the base64 encoded value into our internal variable
      $sHTTPAuthorization = Mid(cHTTPHeader["AUTHORIZATION"], InStr(cHTTPHeader["AUTHORIZATION"], " ") + 1)
    Else
      ' We got an unknown authentication mechanism
      $iHTTPCode = 401 'Unauthorized
      Send()
      Close()
      Return False
    Endif
  Endif

  ' HTTP/1.0 doesn't support keep-alive properly
  If sHTTPProtocol = "HTTP/1.0" Then
    $cHTTPConnection.Clear()
    $cHTTPConnection.Add("CLOSE")
  Endif

  ' Any HTTP/1.1 request is required to have "Host: ..." field
  If sHTTPProtocol = "HTTP/1.1" And If Not cHTTPHeader.Exist("HOST") Then
    $iHTTPCode = 400 'Bad Request
    Send()
    Close()
    Return False
  Endif

  ' Check for "Expect: 100-continue" option & HTTP/1.1
  If sHTTPProtocol = "HTTP/1.1" And If cHTTPHeader.Exist("EXPECT") And If UCase(cHTTPHeader["EXPECT"]) = "100-CONTINUE" Then

    ' When it isn't chunked mode, reject the request if the body is too large
    If Not bHTTPChunked Then
      If iHTTPContentLength > $iHTTPSize Then
        $iHTTPCode = 417 'Expectation Failed
        Send()
        Close()
        Return False
      Endif
   Endif

    ' Do a special check if no body is received - only then reply
    If (Len(sHTTPHeader) + 3) = Len($sDataIn) Then
      Begin()
      $iEndOfLine = gb.Windows
      Print("HTTP/1.1 100 Continue", True)
      Print("", True)
      Try Send(False)
    Endif
  Endif

  ' When it isn't chunked mode, reject the request if the body is too large
  If Not bHTTPChunked Then
    If iHTTPContentLength > $iHTTPSize Then
      $iHTTPCode = 413 'Request Entity Too Large
      Send()
      Close()
      Return False
    Endif
  Endif

  ' Check if we have an upgrade request to websocket
  If $iProtocol = PROTOCOL_HTTP_WEBSOCKET Or If $iProtocol = PROTOCOL_WEBSOCKET Then

    If UCase(cHTTPHeader["UPGRADE"]) = "WEBSOCKET" And If $cHTTPConnection.Exist("UPGRADE") Then

      ' WebSocket upgrade only can be done via a GET
      If $sHTTPMethodIn <> "GET" Then
        $iHTTPCode = 400 'Bad Request
        Send()
        Close()
        Return False
      Endif

      ' We only support RFC6455 , version=13
      If cHTTPHeader.Exist("SEC-WEBSOCKET-KEY") And If Len(UnBase64(cHTTPHeader["SEC-WEBSOCKET-KEY"])) = 16 And If cHTTPHeader.Exist("SEC-WEBSOCKET-VERSION") And If cHTTPHeader["SEC-WEBSOCKET-VERSION"] = 13 Then

        If $sWebSocketProtocol And If cHTTPHeader.Exist("SEC-WEBSOCKET-PROTOCOL") Then
        Endif


        ' If we received an Authorization header, raise it as an event. Application needs to handle it
        bDeny = Raise Authorization($sHTTPAuthorization)

        ' Check if we should deny the request with a 401 Unauthorized
        If bDeny Then
          $iHTTPCode = 401 'Unauthorized
          Send()
          Close()
          Return False
        Endif

        ' Make the handshake key and start switching the protocol
        $sWebSocketHandShake = MakeWebSocketHandShake(cHTTPHeader["SEC-WEBSOCKET-KEY"])
        $iHTTPCode = 101 'Switching Protocols
        Send()
        $bWebSocketEnabled = True

        ' Raise WebSocketReady event, the application can start sending bi-directional data to it
        Raise WebSocketReady
        Return False
      Else
        $iHTTPCode = 400 'Bad Request
        Send()
        Close()
        Return False
      Endif

      Return False
    Else
      ' WebSocket has to be upgraded
      If $iProtocol = PROTOCOL_WEBSOCKET Then
        $iHTTPCode = 400 'Bad Request
        Send()
        Close()
        Return False
      Endif
    Endif
  Else
    ' A normal HTTP connection can't be upgraded
    If cHTTPHeader.Exist("UPGRADE") Or If $cHTTPConnection.Exist("UPGRADE") Then
      $iHTTPCode = 400 'Bad Request
      Send()
      Close()
      Return False
    Endif
  Endif

  ' Check for possible URL requests
  If iHTTPContentLength = 0 Then

    ' First get the first line, this is the URL and remove the HTTP/1.x
    sHTTPHeaderTemp = Trim(Left(sHTTPHeader, InStr(sHTTPHeader, Chr(13)) - 9))

    ' Check for the normal Request in URL
    If $sHTTPRequestInUrl Then
      iPos = InStr(sHTTPHeaderTemp, $sHTTPRequestInUrl)
      If iPos >= 1 Then
        sHTTPHeaderTemp = Mid(sHTTPHeaderTemp, iPos + Len($sHTTPRequestInUrl))
        Try $sDataIn = URL.Decode(sHTTPHeaderTemp)
        If Error Then
          $iHTTPCode = 400 'Bad Request
          Send()
          Close()
          Return False
        Endif
        Return True
      Endif
    Endif

    ' Check for the RAW possibility in the URL
    If $sHTTPRAWInUrl Then
      iPos = InStr(sHTTPHeaderTemp, $sHTTPRAWInUrl)
      If iPos >= 1 Then
        $sDataIn = Mid(sHTTPHeaderTemp, iPos + Len($sHTTPRAWInUrl))
        Return True
      Endif
    Endif

  Endif

  ' It is possible we didn't receive all data, so loop until we think we have it
  iPos = InStr($sDataIn, gb.CrLf & gb.CrLf) - 3
  sHTTPHeaderTemp = gb.CrLf & "0" & gb.CrLf & gb.CrLf

  For iCount = iWait To ($iReadTimeOut + 1) Step 1

    If bHTTPChunked Then
      If Right($sDataIn, Len(sHTTPHeaderTemp)) = sHTTPHeaderTemp Then Break
    Else
      iLen = Len($sDataIn) - iPos
      If iLen >= iHTTPContentLength Then Break
    Endif

    Wait 0.005
  Next

  ' Check for possible timeout
  If iCount > ($iReadTimeOut + 1) Then
    $iHTTPCode = 408 'Request Timeout
    Send()
    Close()
    Return False
  Endif

  If bHTTPChunked Then
    sHTTPHeaderTemp = Mid($sDataIn, InStr($sDataIn, gb.CrLf & gb.CrLf) + 4)
    $sDataIn = ""

    While sHTTPHeaderTemp
      iPos = InStr(sHTTPHeaderTemp, gb.CrLf)
      Try iLen = Val("&H" & Left(sHTTPHeaderTemp, iPos - 1))
      If Error Then
        $iHTTPCode = 400 'Bad Request
        Send()
        Close()
        Return False
      Endif

      sHTTPHeaderTemp = Mid(sHTTPHeaderTemp, iPos + 2)

      If iLen + 2 > Len(sHTTPHeaderTemp) Then
        $iHTTPCode = 400 'Bad Request
        Send()
        Close()
        Return False
      Endif

      ' Copy the data into our input buffer and remove it
      $sDataIn &= Left(sHTTPHeaderTemp, iLen)
      sHTTPHeaderTemp = Mid(sHTTPHeaderTemp, iLen + 3)

      ' Check if we are still inside the expected size
      If Len($sDataIn) > $iHTTPSize Then
        $iHTTPCode = 413 'Request Entity Too Large
        Send()
        Close()
        Return False
      Endif

      ' Check if the buffer still looks ok
      If sHTTPHeaderTemp And If InStr(sHTTPHeaderTemp, gb.CrLf) = 0 Then
        $iHTTPCode = 400 'Bad Request
        Send()
        Close()
        Return False
      Endif
    Wend

    If $sHTTPMethodIn = "OPTIONS" Then
      Send()
      Return False
    Endif

  Else
    If iLen < iHTTPContentLength Then
      $iHTTPCode = 500 'Internal Server Error
      Send()
      Close()
      Return False
    Endif

    $sDataIn = Mid($sDataIn, InStr($sDataIn, gb.CrLf & gb.CrLf) + 4)

    ' We received more then expected with HTTP/1.1, can be a second request
    If sHTTPProtocol = "HTTP/1.1" And If Len($sDataIn) > iHTTPContentLength Then
      $sDataInExtra = Mid($sDataIn, iHTTPContentLength + 1)
      $sDataIn = Left($sDataIn, iHTTPContentLength)
    Endif

    ' With an option we should just respond and don't send anything to the application
    If $sHTTPMethodIn = "OPTIONS" Then
      Send()
      Return False
    Endif
  Endif

  ' We are a persistent connection, start our timer
  ' We need to exclude HTTP/1.0 and upgraded connections
  If Not $cHTTPConnection.Exist("CLOSE") And Not $cHTTPConnection.Exist("UPGRADE") Then
    If $tHTTPTimer = Null Then
      $tHTTPTimer = New Timer As "HTTPTimer"
      $tHTTPTimer.Delay = $iHTTPKeepAlive
      $tHTTPTimer.Start
    Else
      $tHTTPTimer.Delay = $iHTTPKeepAlive
      $tHTTPTimer.Start
    Endif
  Endif

  Return True

End

'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
' Create HTTP data, upstream is unaware of HTTP
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Private Sub Protocol_HTTPServer_Write()

  Dim sDataOut As String
  Dim cCz As New Compress
  Dim sDeflateData As String
  Dim sStr As String
  Dim bServer As Boolean
  Dim bContentType As Boolean

  ' Check if we should respond with an error
  Select $iHTTPCode
    Case 100 ' Continue
    Case 101 ' Switching Protocols
    Case 200 ' OK
    Case 400
      sDataOut = "400 Bad Request"
    Case 401
      sDataOut = "401 Unauthorized"
    Case 405
      sDataOut = "405 Not Allowed"
    Case 408
      sDataOut = "408 Request Timeout"
    Case 411
      sDataOut = "411 Length Required"
    Case 413
      sDataOut = "413 Request Entity Too Large"
    Case 415
      sDataOut = "415 Unsupported Media Type"
    Case 417
      sDataOut = "417 Expectation Failed"
    Case 500
      sDataOut = "500 Internal Server Error"
    Case 505
      sDataOut = "505 HTTP Version Not Supported"
  End Select

  ' Something went wrong, construct output and quit
  If $iHTTPCode >= 400 Then
    sDataOut = "HTTP/1.1 " & sDataOut & gb.CrLf
    bServer = False
    For Each sStr In $cHTTPHeaders
      If InStr(UCase(sStr), "SERVER:") = 1 Then
        sDataOut &= sStr & gb.CrLf
        bServer = True
        Break
      Endif
    Next

    If Not bServer Then sDataOut &= "Server: Gambas Server" & gb.CrLf
    sDataOut &= "Connection: close" & gb.CrLf

    If $iHTTPCode = 405 And $cHTTPMethods.Count > 0 Then
      sDataOut &= "Allow: " & $cHTTPMethods.Join(", ") & gb.CrLf
    Endif

    sDataOut &= gb.CrLf
    $sDataOut = sDataOut

    ' Reset code to zero, it needs to be set with every send call
    $iHTTPCode = 0

    Return
  Endif

  ' We are upgrading to WebSocket
  If $iHTTPCode = 101 Then
    sDataOut = "HTTP/1.1 101 Switching Protocols" & gb.CrLf
    sDataOut &= "Upgrade: websocket" & gb.CrLf
    sDataOut &= "Connection: Upgrade" & gb.CrLf
    sDataOut &= "Sec-WebSocket-Accept: " & $sWebSocketHandShake & gb.CrLf
    'If $sHTTPCrossOrigin Then sDataOut &= "Sec-WebSocket-Origin: " & $sHTTPCrossOrigin & gb.CrLf
    sDataOut &= gb.CrLf
    $sDataOut = sDataOut

    ' Reset code to zero, it needs to be set with every send call
    $iHTTPCode = 0
    Return
  Endif

  ' With an Options request, just respond and don't process further
  If $sHTTPMethodIn = "OPTIONS" Then
    sDataOut = "HTTP/1.1 200 OK" & gb.CrLf
    If $sHTTPCrossOrigin Then
      sDataOut &= "Access-Control-Allow-Origin: " & $sHTTPCrossOrigin & gb.CrLf
      sDataOut &= "Access-Control-Allow-Methods: " & $cHTTPMethods.Join(", ") & gb.CrLf
      If $sHTTPAccessControlRequestHeaders Then 
        sDataOut &= "Access-Control-Allow-Headers: " & $sHTTPAccessControlRequestHeaders & gb.CrLf
      Endif
    Else
      sDataOut &= "Allow: " & $cHTTPMethods.Join(", ") & gb.CrLf
    Endif

    sDataOut &= "Content-Length: 0" & gb.CrLf
    sDataOut &= gb.CrLf
    $sDataOut = sDataOut

    ' Reset code to zero, it needs to be set with every send call
    $iHTTPCode = 0

    Return
  Endif

  ' If we *send* send a compressed stream, try to compress
  If $bHTTPDeflate Then
    cCz.Type = "zlib"
    Try sDeflateData = cCz.String($sDataOut)
    If Not Error Then
      If Len(sDeflateData) >= Len($sDataOut) Then
        ' Most likely the string/data is to small
        $bHTTPDeflate = False
      Endif
    Else
      ' don't do anything
      $bHTTPDeflate = False
    Endif
  Endif

  sDataOut = "HTTP/1.1 200 OK" & gb.CrLf
  sDataOut &= "Date: " & Util.FormatHTTPDate() & gb.CrLf

  If $cHTTPConnection.Exist("CLOSE") Then
    sDataOut &= "Connection: close" & gb.CrLf
  Else
    sDataOut &= "Connection: keep-alive" & gb.CrLf
  Endif

  If $bHTTPDeflate Then
    sDataOut &= "Content-Length: " & Len(sDeflateData) & gb.CrLf
  Else
    sDataOut &= "Content-Length: " & Len($sDataOut) & gb.CrLf
  Endif
  If $bHTTPDeflate Then sDataOut &= "Content-Encoding: deflate" & gb.CrLf
  If $sHTTPCrossOrigin Then sDataOut &= "Access-Control-Allow-Origin: " & $sHTTPCrossOrigin & gb.CrLf

  For Each sStr In $cHTTPHeaders
    sDataOut &= sStr & gb.CrLf
    sStr = UCase(sStr)
    If InStr(sStr, "SERVER:") = 1 Then bServer = True
    If InStr(sStr, "CONTENT-TYPE:") = 1 Then bContentType = True
  Next

  If Not bServer Then sDataOut &= "Server: Gambas Server" & gb.CrLf
  If Not bContentType Then sDataOut &= "Content-Type: text/plain" & gb.CrLf

  sDataOut &= gb.CrLf

  ' Writes compress data when possible
  If $bHTTPDeflate Then
    $sDataOut = sDataOut & sDeflateData
  Else
    $sDataOut = sDataOut & $sDataOut
  Endif

  ' Reset code to zero, it needs to be set with every send call
  $iHTTPCode = 0

End

'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
' Handle HTTP data in client mode and only return the body of the request upstream
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Private Sub Protocol_HTTPClient_Read() As Boolean

  Dim iWait As Integer = 1
  Dim iCount As Integer
  Dim iPos As Integer
  'Dim iLen As Integer
  Dim sHTTPHeader As String
  'Dim cHTTPHeader As New Collection
  Dim sHTTPHeaderTemp As String
  'Dim sHTTPProtocol As String
  'Dim iHTTPContentLength As Integer
  'Dim sHTTPContentType As String
  'Dim bHTTPChunked As Boolean = False
  Dim sMsg As String

  Try $tHTTPTimer.Stop
  $tHTTPTimer = Null

  ' At least wait until we retrieve the http headers
  For iCount = 1 To $iReadTimeOut Step 1
    iPos = InStr($sDataIn, gb.CrLf & gb.CrLf)
    If iPos >= 1 Then Break
    Wait 0.005
  Next

  ' Problem with reading valid http data
  If iCount > $iReadTimeOut Then
    Close()
    Return False
  Else
    iWait = iCount
  Endif

  sHTTPHeader = Left($sDataIn, iPos)
  iPos = InStr(sHTTPHeader, Chr(13))
  If iPos >= 1 Then
    sHTTPHeaderTemp = Left(sHTTPHeader, iPos - 1)
  Else
    Close()
    Return False
  Endif

  ' We are a WebSocket client, lets check if we got valid data
  If $iProtocol = PROTOCOL_WEBSOCKET Then
    If InStr(sHTTPHeaderTemp, "HTTP/1.1 101 ") <> 1 Then

      sMsg = "WebSocket handshake failed." 
      If $iReconnectRetry <= $aReconnectDelay.Max Then
        sMsg &= " Retry in " & IIf($aReConnectDelay[$iReConnectRetry] > 60000, CStr($aReConnectDelay[$iReConnectRetry] / 60000) & " minutes.", CStr($aReConnectDelay[$iReConnectRetry] / 1000) & " seconds.")
      Endif
      sMsg &= " Msg=" & sHTTPHeaderTemp

      If $bDebug Then Main.WriteDebugLog(LogLabel & "< " & $sDataIn)

      Raise Error(sMsg)
      Reconnect()
      Return False
    Endif

    ' Stop timer and reset retry
    Try tReconnect.Stop
    $iReconnectRetry = 0

    ' TODO handle headers

    $bWebSocketEnabled = True

    ' Raise Event
    Raise WebSocketReady

    ' Don't return true, because then we http headers are send upstream
    Return False
  Endif

  Return True

End

'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
' Create HTTP data, upstream is unaware of HTTP headers
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Private Sub Protocol_HTTPClient_Write()

  ' TODO

End

'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
' HTTP Timer to terminate inactive persistent connections
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Public Sub HTTPTimer_Timer()

  Close()

End

'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
' Raise a Write event if the socket is ready for writing
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Public Sub Socket_Write()

  If $bDebug Then Main.WriteDebugLog(LogLabel & "Event=Write (Encrypt=" & $iEncrypt & ")")

  If $iEncrypt <> Net.SSL Then
    Raise Write

    ' If we are in client mode and no SSL check if we use websockets
    If $cServer = Null Then

      ' Ok lets try to upgrade our socket to websockets and send it
      If ($iProtocol = PROTOCOL_WEBSOCKET And Not $bWebSocketEnabled) Then

        ' Only try to do the upgrade once
        If Not $bWebSocketInit Then
          If $bDebug Then Main.WriteDebugLog(LogLabel & "Upgrade to WebSocket")
          Protocol_WebSocket_Upgrade()
          Send()
        Endif
      Endif
    Endif
  Endif

End

'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
' Generate the handshake key for WebSocket
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Private Sub MakeWebSocketHandShake(sKey As String) As String

  Dim sSpecial As String = "258EAFA5-E914-47DA-95CA-C5AB0DC85B11"
  Dim sSum As String
  Dim iCount As Integer
  Dim sResult As String

  ' Append the uuid to the key
  sKey &= sSpecial

  ' Generate the SHA1 hash
  Shell "echo -n \"" & sKey & "\" | sha1sum" To sSum
  sSum = Left(sSum, -4)

  For iCount = 1 To Len(sSum) Step 2
   sResult &= Chr(Val("&H" & Mid(sSum, iCount, 2)))
  Next

  ' Now base64 our result
  Return Base64(sResult)

End

'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
' Handle HTTP data and only return the body of the request upstream
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Private Sub Protocol_WebSocket_Read() As Boolean

  Dim iWait As Integer = 1
  Dim iCount As Integer

  Dim lPayloadLength As Long
  Dim iPayloadOffSet As Integer
  Dim bByte1, bByte2 As Byte
  Dim iOpCode As Byte
  Dim aMask As New Byte[]
  Dim sUnmaskedPayload As String

  ' Anything less of 2, can't be a valid websocket messages
  If Len($sDataIn) < 2 Then Return False

  bByte1 = Asc(Mid($sDataIn, 1, 1))
  bByte2 = Asc(Mid($sDataIn, 2, 1))

  ' Byte1: 76543210: 7=FIN, 654=000 3210=OPCODE
  ' Byte2: 7=Mask 654321=Length if <126, 126=2 bytes length, 127=8 bytes lengh

  ' Determine FIN, OpCode and Mask
  $bWebSocketFIN = BTst(bByte1, 7)
  iOpCode = bByte1 And &H0F
  $bWebSocketMask = BTst(bByte2, 7)
  lPayloadLength = bByte2 And &H7F

  ' RSV1, 2 and 3 aren't supported, so abort according RFC 6455
  If (bByte1 And &H70) <> 0 Then
    Raise Error("WebSocket read packet has invalid RSV1/2/3 header. Received=" & (bByte1 And &H70) & ", Expected=0")
    Close()
    Return False
  Endif

  If $bWebSocketMask Then
    iPayloadOffSet = 2 + 4
  Else
    iPayloadOffSet = 2
  Endif

  If lPayloadLength = 126 Then
    ' length + 2 bytes
    iPayloadOffSet += 2
  Else If lPayloadLength = 127 Then
    ' length + 8 bytes
    iPayloadOffSet += 8
  Endif

  For iCount = iWait To $iReadTimeOut Step 1
    If Len($sDataIn) >= iPayloadOffSet Then Break
    Wait 0.005
  Next

  ' Problem with reading valid websocket data
  If iCount > $iReadTimeOut Then
    Raise Error("WebSocket read packet timeout. TimeOut=" & $iReadTimeOut * 5 & "msec")
    Close()
    Return False
  Else
    iWait = iCount
  Endif

  If lPayloadLength = 126 Then
    lPayloadLength = Asc(Mid($sDataIn, 3, 1)) * 256 + Asc(Mid($sDataIn, 4, 1))
  Else If lPayloadLength = 127 Then
    lPayloadLength = 0
    For iCount = 0 To 7
      lPayloadLength += CLong(Asc(Mid($sDataIn, 10 - iCount, 1))) * (iCount * 256)
    Next
  Endif

  ' Reject if the websocket packet is too big
  If lPayloadLength > $lWebSocketSize Then
    Raise Error("WebSocket read packet too big. Received=" & lPayloadLength & ", Allowed=" & $lWebSocketSize)
    $sWebSocketOpCode = "close"
    $iWebSocketCloseCode = 1004 'too large
    Send()

    Close()
    Return False
  Endif

  For iCount = iWait To ($iReadTimeOut + 1) Step 1
    If Len($sDataIn) >= (lPayloadLength + iPayloadOffSet) Then Break
    Wait 0.005
  Next

  ' Problem with reading valid websocket data
  If iCount > ($iReadTimeOut + 1) Then
    Raise Error("WebSocket read packet timeout. TimeOut=" & $iReadTimeOut * 5 & "msec")
    Close()
    Return False
  Endif

  Select iOpCode
    Case &H00 'Continues the payload
      $sWebSocketOpCode = "continue"
    Case &H01 'UTF-8 data
      $sWebSocketOpCode = "text"
      If $sWebSocketTextBinary = "binary" Then
        $sWebSocketOpCode = "close"
        $iWebSocketCloseCode = 1003 'unsupported
        Send()

        Raise Error("WebSocket received binary packet, only text is allowed")
        Close()
        Return False
      Endif
    Case &H02 'Binary data
      $sWebSocketOpCode = "binary"
      If $sWebSocketTextBinary = "text" Then
        $sWebSocketOpCode = "close"
        $iWebSocketCloseCode = 1003 'unsupported
        Send()

        Raise Error("WebSocket received text packet, only binary is allowed")
        Close()
        Return False
      Endif
    Case &H08 'Terminate connection
      $sWebSocketOpCode = "close"
    Case &H09 'Ping
      $sWebSocketOpCode = "ping"
    Case &H0A 'Pong
      $sWebSocketOpCode = "pong"
    Default 'Unknown frame, reject
      Raise Error("WebSocket Unknown OpCode=" & iOpCode)
      $sWebSocketOpCode = "close"
      $iWebSocketCloseCode = 1002 'protocol error
      Send()

      Close()
      Return False
  End Select

  ' According to the payload length, we have enough and check for possible extra data
  If Len($sDataIn) > (lPayloadLength + iPayloadOffSet) Then
    $sDataInExtra = Mid($sDataIn, lPayloadLength + iPayloadOffSet + 1)
  Endif

  If $bWebSocketMask Then
    ' Build-up the mask array
    For iCount = 0 To 3
      aMask.Add(Asc(Mid($sDataIn, iPayloadOffSet - 3 + iCount, 1)))
    Next

    ' Now unmask the payload with the mask with XOR
    For iCount = (iPayLoadOffset + 1) To (lPayloadLength + iPayLoadOffset)
      sUnmaskedPayload &= Chr(Asc(Mid($sDataIn, iCount, 1)) Xor aMask[(iCount - (iPayloadOffset + 1)) % 4])
    Next
    $sDataIn = sUnmaskedPayload
  Else
    $sDataIn = Mid($sDataIn, iPayloadOffset + 1, lPayloadLength) 
  Endif

  Return True

End

'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
' Create WebSocket data, upstream is unaware of WebSocket
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Private Sub Protocol_WebSocket_Write()

  Dim sDataOut As String
  Dim iPayloadLength As Integer
  Dim bByte1 As Byte
  Dim bByte2 As Byte
  Dim iCount As Integer
  Dim aMask As New Byte[]
  Dim iLength As Integer
  Dim sVal As String

' Close codes:
' 2-bytes with code + text with a reason/description
' 1000=No error
' 1001=Go away
' 1002=Protocol error
' 1003=Unsupported, e.g. receive binary while only support text
' 1004=Too large

  ' Set the opcode, also the FIN bit with &H80 (we never segment packets)
  Select $sWebSocketOpCode
    Case "continue"
      If $sWebSocketPrevOpCode = "text" Then
        bByte1 += &H81
      Else If $sWebSocketPrevOpCode = "binary" Then
        bByte1 += &H82
      Else
        bByte1 += &H80
        $sDataOut = ""
        Return
      Endif
    Case "text"
      bByte1 += &H81
    Case "binary"
      bByte1 += &H82
    Case "close"
      bByte1 += &H88
      $sDataOut = ""

      ' We got a close request, but it can be required to send a code back
      If $iWebSocketCloseCode > 0 Then
        sVal = Bin($iWebSocketCloseCode, iLength * 8)
        For iCount = 0 To Len(sVal) - 1 Step 8
          $sDataOut = Chr(Val("&X" & Mid(sVal, iCount + 1, 8)))
        Next
      Endif

      $iWebSocketCloseCode = 0
    Case "ping"
      bByte1 += &H89
    Case "pong" 'Discard a pong, we don't support it
      bByte1 += &H8A
      $sDataOut = ""
      Return
    Default 'Don't do anything if we don't have a proper opcode
      If $bDebug Then Main.WriteDebugLog(LogLabel & "WebSocket Write Requires a 'WebSocketOpCode'")
      $sDataOut = ""
      Return
  End Select

  ' Check if we are in server or client mode. According to RFC6455 
  ' we should never set mask as server, and always as client.
  If Not $cServer Then
    bByte2 = BSet(bByte2, 7)
  Endif

  iPayloadLength = Len($sDataOut)
  If iPayloadLength <= 125 Then
    bByte2 += iPayloadLength
    iLength = 0
  Else If iPayloadLength <= 65535 Then
    bByte2 += 126
    iLength = 2
  Else
    bByte2 += 127
    iLength = 8
  Endif

  ' Set the first 2 bytes of a websocket packet
  sDataOut = Chr(bByte1)
  sDataOut &= Chr(bByte2)

  ' Add the possible length
  If iLength > 0 Then
    ' Add the possible length
    sVal = Bin(iPayloadLength, iLength * 8)
    For iCount = 0 To Len(sVal) - 1 Step 8
      sDataOut &= Chr(Val("&X" & Mid(sVal, iCount + 1, 8)))
    Next
  Endif

  ' Generate random mask and mask the datapacket only if we are in client mode
  If $cServer Then
    $sDataOut = sDataOut & $sDataOut
  Else
    aMask.Resize(4)
    For iCount = 0 To 3
      aMask[iCount] = Rnd(0, 255)
      sDataOut &= Chr(aMask[iCount])
    Next

    For iCount = 1 To iPayloadLength
      sDataOut &= Chr(Asc(Mid($sDataOut, iCount, 1)) Xor aMask[(iCount - 1) Mod 4])
    Next

    $sDataOut = sDataOut
  Endif

End

'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
' In client mode, try to upgrade to WebSocket
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Private Sub Protocol_WebSocket_Upgrade()

  Dim sDataOut As String
  Dim iCount As Integer
  Dim sKey As String

  ' Generate 16 random bytes for the key
  For iCount = 0 To 15
    sKey &= Chr(Rnd(0, 255))
  Next

  ' Key has to be Base64 encoded
  sKey = Base64(sKey)

  sDataOut = "GET " & $sHTTPUrl & " HTTP/1.1" & gb.CrLf
  sDataOut &= "Host: " & MySocket.Host & IIf(MySocket.Port <> 80, ":" & MySocket.Port, "") & gb.CrLf 
  sDataOut &= "Upgrade: websocket" & gb.CrLf
  sDataOut &= "Connection: Upgrade" & gb.CrLf
  sDataOut &= "Sec-WebSocket-Key: " & sKey & gb.CrLf
  sDataOut &= "Sec-WebSocket-Version: 13" & gb.CrLf
  If $sWebSocketOrigin Then sDataOut &= "Origin: " & $sWebSocketOrigin & gb.CrLf

  sDataOut &= gb.CrLf
  $sDataOut = sDataOut

  $bWebSocketInit = True

End

'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
' Start a new line/print session
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Public Sub Begin()

  $sDataOut = ""

End

'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
' Add the line with a proper linefeed character(s)
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Public Sub Print(sData As String, Optional bEOL As Boolean = False)

  If bEOL Then
    Select $iEndOfLine
      Case gb.Unix
        $sDataOut &= sData & Chr$(10)
      Case gb.Windows
        $sDataOut &= sData & Chr$(13) & Chr$(10)
      Case gb.Mac
        $sDataOut &= sData & Chr$(13)
      Default
        $sDataOut &= sData & Chr$(10)
    End Select
  Else
    $sDataOut &= sData
  Endif

End

'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
' Drop the data stored in the internal buffer
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Public Sub Drop()

  $sDataOut = ""

End

'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
' Send the data in the internal buffer, as line/print
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Public Sub Send(Optional bProtocol As Boolean = True)

  Dim pData As Pointer
  Dim iRet As Integer
  Dim sStream As Stream

  If bProtocol Then
    If $iProtocol = PROTOCOL_HTTP Or If ($iProtocol = PROTOCOL_HTTP_WEBSOCKET And Not $bWebSocketEnabled) Or If ($iProtocol = PROTOCOL_WEBSOCKET And Not $bWebSocketEnabled) Then

      If $bDebug Then Main.WriteDebugLog(LogLabel & "< " & $sDataOut)

      If $cServer Then
        Protocol_HTTPServer_Write()
      Else
        If $iProtocol = PROTOCOL_HTTP Or $iProtocol = PROTOCOL_HTTP_WEBSOCKET Then
          Protocol_HTTPClient_Write()
        Else
          ' Do nothing for WebSocket, we got an upgrade request with all the headers ;-)
          ' bWebSocketEnabled  will be set in the Protocol_HTTPClient_Read
        Endif
      Endif

    Else
      If ($iProtocol = PROTOCOL_HTTP_WEBSOCKET And $bWebSocketEnabled) Or If ($iProtocol = PROTOCOL_WEBSOCKET And $bWebSocketEnabled) Then
        Protocol_WebSocket_Write()
      Else
      Endif
    Endif
  Endif

  If Not $sDataOut Then Return

  If $iEncrypt = Net.SSL Then

    If $pSSL = Null Then
      Error.Raise("SSL Object has Null value (SSL_write)")
      Return
    Endif 

    If Not $bSSLAcceptHandshake Then
      iRet = SSL_accept($pSSL)
      If iRet = 1 Then
        $bSSLAcceptHandshake = True

        ' Raise Ready Event anyway - shouldn't be needed really
        Raise Ready
        ' Now we can also raise Write event
        Raise Write
      Else
        If iRet = -1 Then
          Try iRet = SSL_get_error($pSSL, iRet)
          If iRet <> SSL_ERROR_WANT_READ And If iRet <> SSL_ERROR_WANT_WRITE Then
            If $pSSL <> Null Then
              Try SSL_shutdown($pSSL)
              Try SSL_free($pSSL)
              $pSSL = Null
            Endif

            Error.Raise("SSL handshake failed RC=" & iRet & " (" & Display_SSL_ERROR(iRet) & ")")
            Close()
            Return
          Endif
        Endif
      Endif
    Endif

    ' Don't continue if the handshake didn't succeed
    If Not $bSSLAcceptHandshake Then Return

    pData = Alloc(Len($sDataOut))
    sStream = Memory pData For Read Write
    Write #sStream, $sDataOut, Len($sDataOut)
    Try iRet = SSL_write($pSSL, pData, Len($sDataOut))
    Free(pData)

    If iRet <= 0 Then
      Try iRet = SSL_get_error($pSSL, iRet)
      Error.Raise("SSL Write Failed RC=" & iRet & " (" & Display_SSL_ERROR(iRet) & ")")
      Return
    Endif

  Else
    Try MySocket.Blocking = True
    Try Write #MySocket, $sDataOut, Len($sDataOut)
    Try MySocket.Blocking = False
  Endif

  $sDataOut = ""

  ' If HTTP Protocol, please run a Close() here
  If bProtocol Then
    If $iProtocol = PROTOCOL_HTTP Or If $iProtocol = PROTOCOL_HTTP_WEBSOCKET Then

      ' Close the connection if the client requested it
      If $cHTTPConnection.Exist("CLOSE") Then
        Close()
      Endif
    Else
    Endif
  Endif

End

'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
' Write data directly to socket
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Public Sub Write(vData As Variant, Optional iDataType As Integer = 0)

  Dim iCnt As Integer

  ' If we didn't get the datatype, use the previously set value
  If iDataType = 0 Then iDataType = $iDataType

  Select iDataType
    Case gb.Byte ' Byte
      $sDataOut = Chr(vData)
    Case &HFF + gb.Byte ' Byte[]
      $sDataOut = ""
      For iCnt = 1 To vData.Count
        $sDataOut &= Chr(vData[iCnt - 1])
      Next
    Default ' Also string
      $sDataOut = CStr(vData)
  End Select

  Send()

End

'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
' Socket is closed by server
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Public Sub Close()

  If $bDebug Then Main.WriteDebugLog(Loglabel & "Closing Socket")

  Try tReconnect.Stop
  tReconnect = Null

  Try $tHTTPTimer.Stop
  $tHTTPTimer = Null

  If $iEncrypt = Net.SSL Then
    If $pSSL <> Null Then
      Try SSL_shutdown($pSSL)
      Try SSL_free($pSSL)
      $pSSL = Null
    Endif
    Try Close #MySocket
  Else
    Try Close #MySocket
  Endif

  ' Set MySocket to null, otherwise it isn't freed by Gambas
  MySocket = Null

  ' Raise the closed event, if we didn't raise it before - otherwise cClients won't be released
  If Not $bEventClosedRaised Then
    Raise Closed
    $bEventClosedRaised = True
  Endif

End

'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
' Socket raises found, Hostname -> IP resolved
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Public Sub Socket_Found()

  If $bDebug Then Main.WriteDebugLog(Loglabel & "Event=Found")

  Raise Found

End

'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
' Socket is ready
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Public Sub Socket_Ready()

  Dim iRet As Integer

  If $bDebug Then Main.WriteDebugLog(Loglabel & "Event=Ready")

  ' In client mode, stop and reset retry counter
  ' Only do it for NONE websockets, because that's handled during the upgrade response
  If $cServer = Null And If $iProtocol <> PROTOCOL_WEBSOCKET Then
    Try tReconnect.Stop
    $iReconnectRetry = 0
  Endif

  ' Only raise it for none-encrypted connections
  If $iEncrypt = Net.SSL Then

    ' If we are a client, try to start the SSL negotiation. In serversocket it already happened
    If $cServer = Null Then

      ' try to do the SSL setup/negotiation
      If $pCTX = Null Then
        Raise Error("SSL CTX is NULL value")
        Close()
        Return
      Endif

      $pSSL = SSL_new($pCTX)

      If $pSSL = Null Then
        Raise Error("SSL is NULL value")
        Close()
        Return
      Endif

      iRet = SSL_set_fd($pSSL, MySocket.Handle)

      ' When <> 1, then something went wrong during set fd
      If iRet = 0 Then
        Raise Error("SSL set_fd failed")
        Close()
        Return
      Endif

      ' File-Handle assigned, now try to accept the connection
      iRet = SSL_connect($pSSL)

      ' Check return value of SSL_accept
      Select iRet
        Case 0 ' Handshake failed, stop the SSL session
          Try SSL_shutdown($pSSL)
          Try SSL_free($pSSL)
          $pSSL = Null

          Try iRet = SSL_get_error($pSSL, iRet)
          Raise Error("SSL handshake failed RC=" & iRet & " (" & Display_SSL_ERROR(iRet) & ")")
          Close()
          Return
        Case 1 ' Succesfull
          $bSSLAcceptHandshake = True

          ' Raise Ready Event
          Raise Ready

          ' Now we can also raise Write event
          Raise Write

        Default ' Error happened, maybe we should retry
          $bSSLAcceptHandshake = False
          Try iRet = SSL_get_error($pSSL, iRet)
          If iRet <> SSL_ERROR_WANT_READ Then 
            ' Something went wrong, just stop the SSL session
            Try SSL_shutdown($pSSL)
            Try SSL_free($pSSL)
            $pSSL = Null

            Try iRet = SSL_get_error($pSSL, iRet)
            Raise Error("SSL handshake failed RC=" & iRet & " (" & Display_SSL_ERROR(iRet) & ")")
            Close()
            Return
          Endif
      End Select
    Endif
  Else
    Raise Ready
  Endif

  ' If we are in client mode check if we use websockets
  If $cServer = Null Then

    ' Ok lets try to upgrade our socket to websockets and send it
    If ($iProtocol = PROTOCOL_WEBSOCKET And Not $bWebSocketEnabled) Then

      ' Only try to do the upgrade once
      If Not $bWebSocketInit Then
        If $bDebug Then Main.WriteDebugLog(LogLabel & "Upgrade to WebSocket")
        Protocol_WebSocket_Upgrade()
        Send()
      Endif
    Endif
  Endif

End

'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
' Socket has an error - try to reconnect in client mode
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Public Sub Socket_Error()

  Dim iReconnectTime As Integer
  Dim iStatus As Integer
  Dim sHost As String

  iStatus = MySocket.Status
  sHost = MySocket.Host

  If $bDebug Then Main.WriteDebugLog(Loglabel & "Event=Error, Msg=" & Log.Text_TCP_Error(iStatus, sHost))

  If $cServer = Null Then
    ' Get the possible time for reconnecting
    iReconnectTime = Reconnect()
    ' Raise the error event
    Raise Error(Log.Text_TCP_Error(iStatus, sHost) & IIf(iReconnectTime > 0, " Retry in " & (iReconnectTime / 1000) & " seconds.", ""))
  Else
    Raise Error(Log.Text_TCP_Error(iStatus, sHost))
  Endif

End

'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
' Socket is closed by client
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Public Sub Socket_Closed()

  If $bDebug Then Main.WriteDebugLog(Loglabel & "Event=Closed")

  Try $tHTTPTimer.Stop
  $tHTTPTimer = Null

  Close()

  ' In client mode we should try to reconnect for RAW and WebSocket
  If $cServer = Null Then
    If $iProtocol = PROTOCOL_NONE Or If $iProtocol = PROTOCOL_WEBSOCKET Then
      Reconnect()
    Endif
  Endif

End

'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
' Assigns the just created socket to our SSLSocket
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Public Sub AssignSocket()

  Dim sPluginName As String
  Dim iRet As Integer

  $cServer = Last
  MySocket = Last.Accept()

  Try sPluginName = Object.Parent(Me).PluginName
  If Error Then sPluginName = "Unknown"
  LogLabel = "[Socket:" & sPluginName & ":" & MySocket.RemoteHost & ":" & MySocket.RemotePort & "] "

  If $bDebug Then Main.WriteDebugLog(LogLabel & "Socket Accepted")

  $iTimeout = Last.Timeout
  $iEncrypt = Last.Encrypt
  $iDataType = Last.DataType
  $pCTX = Last.SSLCTX

  If $iEncrypt = Net.SSL Then

    If $pCTX = Null Then
      Error.Raise("SSL CTX is NULL value")
      Return
    Endif

    $pSSL = SSL_new($pCTX)

    If $pSSL = Null Then
      Error.Raise("SSL is NULL value")
      Return
    Endif

    iRet = SSL_set_fd($pSSL, MySocket.Handle)

    ' When <> 1, then something went wrong during set fd
    If iRet = 0 Then
      Error.Raise("SSL set_fd failed")
      Close()
      Return
    Endif

    ' File-Handle assigned, now try to accept the connection
    iRet = SSL_accept($pSSL)

    ' Check return value of SSL_accept
    Select iRet
      Case 0 ' Handshake failed, stop the SSL session
        Try SSL_shutdown($pSSL)
        Try SSL_free($pSSL)
        $pSSL = Null

        Try iRet = SSL_get_error($pSSL, iRet)
        Error.Raise("SSL handshake failed RC=" & iRet & " (" & Display_SSL_ERROR(iRet) & ")")
        Close()
        Return
      Case 1 ' Succesfull
        $bSSLAcceptHandshake = True

        ' Raise Ready Event
        Raise Ready
        ' Now we can also raise Write event
        Raise Write

      Default ' Error happened, maybe we should retry
        $bSSLAcceptHandshake = False
        Try iRet = SSL_get_error($pSSL, iRet)
        If iRet <> SSL_ERROR_WANT_READ Then 
          ' Something went wrong, just stop the SSL session
          Try SSL_shutdown($pSSL)
          Try SSL_free($pSSL)
          $pSSL = Null

          Try iRet = SSL_get_error($pSSL, iRet)
          Error.Raise("SSL handshake failed RC=" & iRet & " (" & Display_SSL_ERROR(iRet) & ")")
          Close()
          Return
        Endif
    End Select
  Endif

End

'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
' Connect as a client to a server
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Public Sub Connect(Optional sHostOrPath As String, Optional iPort As Integer = 0)

  Dim sPluginName As String
  Dim pMethod As Pointer

  Try sPluginName = Object.Parent(Me).PluginName
  If Error Then sPluginName = "Unknown"
  LogLabel = "[Socket:" & sPluginName & ":" & sHostOrPath & IIf(iPort, ":" & iPort, "") & "] "

  If $bDebug Then Main.WriteDebugLog(LogLabel & "Opening Socket")

  If $iProtocol = PROTOCOL_HTTP_WEBSOCKET Then
    Raise Error("Protocol HTTP & WebSocket only allowed in Server mode")
    Return
  Endif

  If sHostOrPath And iPort Then
    MySocket.Connect(sHostOrPath, iPort)
  Else If sHostOrPath Then
    MySocket.Connect(sHostOrPath)
  Else
    Raise Error("No path or host supplied for connect")
  Endif

  If $iEncrypt = Net.SSL Then
    ' Initialize the SSL connection and check certificate

    ' Check if the OpenSSL library is installed
    Try $sSSLVersion = SSLeay_version(0)
    If Error Then
      Error.Raise("Unable to initialize the OpenSSL library, 'libcrypto.so' is missing or incorrect call to 'SSLeay_version'")
      Return
    Endif

    If $sSSLVersion Then
      If InStr($sSSLVersion, "OpenSSL 0.9") Then
        $sSSLVersionId = "0.9"
      Else If InStr($sSSLVersion, "OpenSSL 1.0") Then
        $sSSLVersionId = "1.0"
      Else If InStr($sSSLVersion, "OpenSSL 1.1") Then
        $sSSLVersionId = "1.1"
      Else
        $sSSLVersionId = "NA"
      Endif
    Else
      $sSSLVersionId = "NA"
    Endif

    ' Initialize the library
    Try SSL_library_init()
    If Error Then
      Error.Raise(Error.Text)
      Return
    Endif

    ' Initialize the error strings
    Try SSL_load_error_strings()
    If Error Then
      Error.Raise("Unable to initialize the OpenSSL library, 'libssl.so' is missing or incorrect call to 'SSL_load_error_strings'")
      Return
    Endif

    ' Here we initiaze the CTX, but it is different depending on the OpenSSL version.
    ' 0.9.8/1.0.x call SSLv23_method, but 1.1.x call TLS_method
    Select $sSSLVersionId
      Case "0.9", "1.0"
        Try pMethod = SSLv23_method()
        If Error Then
          Error.Raise("Unable to initialize the OpenSSL library, 'libssl.so' is missing or incorrect call to 'SSLv23_method'")
          Return
        Endif
      Case "1.1"
        Try pMethod = TLS_method()
        If Error Then
          Error.Raise("Unable to initialize the OpenSSL library, 'libssl.so' is missing or incorrect call to 'TLS_method'")
          Return
        Endif
      Default
        ' We first try the SSLv23, if that fails, try the TLS
        Try pMethod = SSLv23_method()
        If Error Then
          Try pMethod = TLS_method()
          If Error Then
            Error.Raise("Unable to initialize the OpenSSL library, 'libssl.so' is missing or incorrect call to 'SSLv23_method' or 'TLS_method'")
            Return
          Endif
        Endif
    End Select

    If pMethod = Null Then
      Error.Raise("Unable to initialize the OpenSSL library, call to 'SSLv23_method' or 'TLS_method' returned NULL")
      Return
    Endif

    Try $pCTX = SSL_CTX_new(pMethod)
    If Error Then
      Error.Raise("Unable to initialize the OpenSSL library, 'libssl.so' is missing or incorrect call to 'SSL_CTX_new'")
      Return
    Endif

    If $pCTX = Null Then
      Error.Raise("Unable to initialize the OpenSSL library, call to 'SSL_CTX_new' returned NULL")
      Return
    Endif

    'Try lVal = SSL_CTX_set_options($pCTX, lVal)
    Try SSL_CTX_ctrl($pCTX, 32, $lSSLMethod, Null)
    If Error Then
      Error.Raise("Unable to initialize the OpenSSL library, 'libssl.so' is missing or incorrect call to 'SSL_CTX_set_options'")
      Try SSL_CTX_free($pCTX)
      Return
    Endif

  Endif

End

'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
' We try to reconnect, we return the started timer in msec
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Private Sub Reconnect() As Integer

  Dim iReconnectTime As Integer = 0

  ' Maybe something is still open/active, so kill it first
  Close()

  ' Don't overrule an already started timer
  If tReconnect And If tReconnect.Enabled Then Return

  If $bDebug Then Main.WriteDebugLog(Loglabel & "Reconnect routine")

  ' Only do it, when it is a valid variable and has 1 or more entries
  If $aReconnectDelay And If $aReconnectDelay.Count Then

    If $iReconnectRetry <= $aReconnectDelay.Max Then
      tReconnect = New Timer As "tReconnect"
      tReconnect.Delay = $aReconnectDelay[$iReconnectRetry]
      tReconnect.Start
 
      iReconnectTime = $aReconnectDelay[$iReconnectRetry]
 
      If $bDebug Then Main.WriteDebugLog(Loglabel & "Reconnect started, timer=" & $aReconnectDelay[$iReConnectRetry] & " milliseconds")
    Else
      Try tReconnect.Stop
      Raise Error("Too many reconnect failures (" & $iReconnectRetry & "), stopped trying.")
    Endif

    Inc $iReconnectRetry
  Endif

  Return iReconnectTime

End

'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
' ReConnect Timer expired
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Public Sub tReconnect_Timer()

  ' Stop timer
  Last.Stop()

  ' Raise a reconnect event, Plugin is responsible for it
  Raise Reconnect

End

'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
' Display a readable SSL_ERROR
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Private Sub Display_SSL_ERROR(iRet As Integer) As String

  Select iRet
    Case SSL_ERROR_NONE
    Case SSL_ERROR_SSL
      Return "ERROR_SSL"
    Case SSL_ERROR_WANT_READ
      Return "ERROR_WANT_READ"
    Case SSL_ERROR_WANT_WRITE
      Return "ERROR_WANT_WRITE"
    Case SSL_ERROR_WANT_X509_LOOKUP
      Return "ERROR_WANT_X509_LOOKUP"
    Case SSL_ERROR_SYSCALL
      Return "ERROR_SYSCALL"
    Case SSL_ERROR_ZERO_RETURN
      Return "ERROR_ZERO_RETURN"
    Case SSL_ERROR_WANT_CONNECT
      Return "ERROR_WANT_CONNECT"
    Case SSL_ERROR_WANT_ACCEPT
      Return "ERROR_WANT_ACCEPT"
    Default
      Return "UNKNOWN"
  End Select

End

'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
' Properties
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Function Debug_Read() As Boolean

  Return $bDebug

End

Function Debug_Write(bDebug As Boolean)

  $bDebug = bDebug

End

Function EndOfLine_Read() As Integer

  Return $iEndOfLine

End

Function EndOfLine_Write(iEndOfLine As Integer)

  Select iEndOfLine
    Case gb.Unix
      $iEndOfLine = gb.Unix
    Case gb.Windows
      $iEndOfLine = gb.Windows
    Case gb.Mac
      $iEndOfLine = gb.Mac
    Default
      $iEndOfLine = gb.Unix
  End Select

End

Function TimeOut_Read() As Integer

  Return $iTimeout

End

Function TimeOut_Write(iTimeout As Integer)

  $iTimeout = iTimeout

End

Function Tag_Read() As Variant

  Return MySocket.Tag

End

Function Tag_Write(vTag As Variant)

  MySocket.Tag = vTag

End

Function Host_Read() As String

  Return MySocket.Host

End

Function Host_Write(sHost As String)

  MySocket.Host = sHost

End

Function Port_Read() As Integer

  Return MySocket.Port

End

Function Port_Write(iPort As Integer)

  MySocket.Port = iPort

End

Function Handle_Read() As Integer

  Return MySocket.Handle

End

Function LocalHost_Read() As String

  Return MySocket.LocalHost

End


Function LocalPort_Read() As Integer

  Return MySocket.LocalPort

End

Function RemoteHost_Read() As String

  Return MySocket.RemoteHost

End

Function RemotePort_Read() As Integer

  Return MySocket.RemotePort

End

Function Status_Read() As Integer

  Return MySocket.Status

End

Function Path_Read() As String

  Return MySocket.Path

End

Function Path_Write(sPath As String)

  MySocket.Path = sPath

End

Function Protocol_Read() As Integer

  Return $iProtocol

End

Function Protocol_Write(iProtocol As Integer)

  $iProtocol = iProtocol

End

Function HTTPCode_Read() As Integer

  Return $iHTTPCode

End

Function HTTPCode_Write(iHTTPCode As Integer)

  $iHTTPCode = iHTTPCode

End

Function HTTPSize_Read() As Integer

  Return $iHTTPSize

End

Function HTTPSize_Write(iHTTPSize As Integer)

  $iHTTPSize = iHTTPSize

End

Function HTTPMethods_Read() As String[]

  Return $cHTTPMethods

End

Function HTTPMethods_Write(cHTTPMethods As String[])

  $cHTTPMethods = cHTTPMethods

End

Function HTTPContentTypes_Read() As String[]

  Return $cHTTPContentTypes

End

Function HTTPContentTypes_Write(cHTTPContentTypes As String[])

  $cHTTPContentTypes = cHTTPContentTypes

End

Function HTTPHeaders_Read() As String[]

  Return $cHTTPHeaders

End

Function HTTPHeaders_Write(cHTTPHeaders As String[])

  $cHTTPHeaders = cHTTPHeaders

End

Function HTTPRequestInUrl_Read() As String

  Return $sHTTPRequestInUrl

End

Function HTTPRequestInUrl_Write(sHTTPRequestInUrl As String)

  $sHTTPRequestInUrl = sHTTPRequestInUrl

End

Function HTTPRAWInUrl_Read() As String

  Return $sHTTPRAWInUrl

End

Function HTTPRAWInUrl_Write(sHTTPRAWInUrl As String)

  $sHTTPRAWInUrl = sHTTPRAWInUrl

End

Function ReadTimeOut_Read() As Integer

  Return $iReadTimeOut * 5

End

Function ReadTimeOut_Write(iReadTimeOut As Integer)

  $iReadTimeOut = iReadTimeOut / 5

End

Function HTTPKeepAlive_Read() As Integer

  Return $iHTTPKeepAlive

End

Function HTTPKeepAlive_Write(iHTTPKeepAlive As Integer)

  $iHTTPKeepAlive = iHTTPKeepAlive

End

Function HTTPMethod_Read() As String

  Return $sHTTPMethod

End

Function HTTPMethod_Write(sHTTPMethod As String)

  $sHTTPMethod = sHTTPMethod

End

Function HTTPUrl_Read() As String

  Return $sHTTPUrl

End

Function HTTPUrl_Write(sHTTPUrl As String)

  $sHTTPUrl = sHTTPUrl

End

Function WebSocketOpcode_Read() As String

  Return $sWebSocketOpCode

End

Function WebSocketOpCode_Write(sWebSocketOpCode As String)

  $sWebSocketOpCode = sWebSocketOpCode

End

Function WebSocketTextBinary_Read() As String

  Return $sWebSocketTextBinary

End

Function WebSocketTextBinary_Write(sWebSocketTextBinary As String)

  Select LCase(sWebSocketTextBinary)
    Case "text"
      $sWebSocketTextBinary = "text"
    Case "binary"
      $sWebSocketTextBinary = "binary"
    Default ' support both text/binary
      $sWebSocketTextBinary = ""
  End Select

End

Function WebSocketOrigin_Read() As String

  Return $sWebSocketOrigin

End

Function WebSocketOrigin_Write(sWebSocketOrigin As String)

  $sWebSocketOrigin = sWebSocketOrigin

End

Function Server_Read() As Object

  Return $cServer

End

Function Server_Write(cServSock As Object)

  $cServer = cServSock

End

Function DataType_Read() As Integer

  Return $iDataType

End

Function DataType_Write(iDataType As Integer)

  $iDataType = iDataType

End

Function ReconnectRetry_Read() As Integer

  Return $iReconnectRetry

End

Function ReconnectRetry_Write(iReconnectRetry As Integer)

  $iReConnectRetry = iReconnectRetry

End

Function Encrypt_Read() As Integer

  Return $iEncrypt

End

Function Encrypt_Write(iEncrypt As Integer)

  $iEncrypt = iEncrypt

End

