' Gambas class file

' Description:
' COnkyo.class
' Support for Onkyo/Integra receiver control.

' Development Status:
' Beta. Needs Testing.

' DomotiGa - an open source home automation program.
' Copyright (C) Ron Klinkien, The Netherlands.

' Read file called COPYING for license details.

'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
' Module/Class specific variables
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Public PluginName As String = "Onkyo"
Public PluginFriendlyName As String = "Onkyo/Integra Receiver"
Public PluginVersion As String = "1.91"
Public PluginAuthor As String = "Ron Klinkien"
Public PluginProtocols As String[]
Public PluginMaxInstances As Integer = 1

Public KeyName As String
Public LogLabel As String = "[Onkyo] "
Public Instance As Integer
Public IsRunning As Boolean
Public ErrorText As String
Public ErrorWhere As String

'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
' Private Variables
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Private $bEnabled As Boolean
Private $sTCPHost As String
Private $iTCPPort As String
Private $bDebug As Boolean
Private $sInterface As String
Private $sSerPort As String
Private $sBaud As String

' Command buffer
Private $tQueueDelay As New Timer As "QueueDelay"
Private $cQueue As New Collection

' Interface objects
Public hMySocket As CSocket
Public hMySerial As CSerialPort

Private $sBuffer As String

Public hBroadcastUDP As UdpSocket

'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
' Mandatory subroutine for each Module/Class to initialize:
' - The cPlugin[x].Settings are copied into local variables
' - Port/Connection will be started (any errors caught)
' - Any other code per Class
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Public Sub StartPlugin(cPl As CPluginEntry)

  KeyName = cPl.KeyName
  Instance = cPl.Instance
  If Instance <> 1 Then LogLabel = Replace(LogLabel, "] ", "#" & Instance & "] ")

  ' Copy configuration items locally
  $bEnabled = cPl.Settings["enabled"]
  $sTCPHost = cPl.Settings["tcphost"]
  $iTCPPort = cPl.Settings["tcpport"]
  $sInterface = cPl.Settings["type"]
  $sSerPort = cPl.Settings["serialport"]
  $sBaud = cPl.Settings["baudrate"]
  $bDebug = cPl.Settings["debug"]
 
  ' Connect/Initialize connection
  If InStr($sInterface, "tcp") Then
    ConnectTCP()
  Else
    ConnectSerial()
  Endif

End

'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
' Mandatory sub for each Module/Class to stop
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Public Sub StopPlugin()

  Try Disconnect()

End

'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
' Easy helper for WriteLog
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Private Sub WriteLog(sLog As String)

  Main.WriteLog(LogLabel & sLog)
  If $bDebug Then Main.WriteDebugLog(LogLabel & sLog)

End

'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
' Easy helper for WriteDebugLog
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Private Sub WriteDebugLog(sLog As String)

  If $bDebug Then Main.WriteDebugLog(LogLabel & sLog)

End

'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
' connect to the tcp host:port
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Private Sub ConnectTCP()

  Dim iReconnectRetry As Integer = 0
  Dim sIP As String
  Dim sMsg As String

  ' try to close the connection
  Try hMySocket.Close
  Try iReconnectRetry = hMySocket.ReconnectRetry

  ' get a new one - but also pass on our previous reconnect counter
  hMySocket = New CSocket(iReconnectRetry) As "MySocket"

  hMySocket.DataType = &HFF + gb.Byte
  hMySocket.Connect($sTCPHost, $iTCPPort)

  ' Write to main logfile we are trying to connect
  WriteLog(PluginFriendlyName & " TCP interface connecting to " & $sTCPHost & ":" & $iTCPPort)

  ' try to close the connection
  Try hBroadcastUDP.Close

  ' In debug mode: Broadcast Device Search Message for auto discovery
  ' Should work for newer 2011 AV receivers models
  If $bDebug Then
    ' get a new one
    hBroadcastUDP = New UdpSocket As "BroadcastUDP"

  ' Set own port to 0, and destination port to fixed port 60128
    hBroadcastUDP.Port = 0
    hBroadcastUDP.TargetPort = 60128

    ' Now try to bind to the port
    hBroadcastUDP.Bind()

    ' sMsg is a specific ISCP message - "!xECNQSTN" is discovery, still need to add the packet info
    sMsg = "ISCP\x00\x00\x00\x10\x00\x00\x00" & Chr(Len("!xECNQSTN") + 1) & "\x01\x00\x00\x00" & "!xECNQSTN" & gb.Cr

    ' Now broadcast it to add addresses in our network
    ' Maybe it can be handier to use '239.255.255.250'?
    For Each sIP In Main.aBroadcastAddr
      WriteDebugLog("Sending UDP discovery to AV devices (model 2011 and newer) to broadcast address '" & sIP & "' on port 60128")
      hBroadcastUDP.TargetHost = sIP

      ' try 3 times, lets see what happens
      Try Write #hBroadcastUDP, sMsg, Len(sMsg)
      Try Write #hBroadcastUDP, sMsg, Len(sMsg)
      Try Write #hBroadcastUDP, sMsg, Len(sMsg)
    Next

  Endif

Catch ' some errors
  WriteLog("ERROR: " & PluginFriendlyName & " TCP interface FAILED to connect to " & $sTCPHost & ":" & $iTCPPort)
  WriteLog("ERROR: " & Error.Text)
  IsRunning = False
  ErrorText = Error.Text
  ErrorWhere = Error.Where

End

'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
' open serial port
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Private Sub ConnectSerial()

  Dim iReconnectRetry As Integer = 0

  ' try to close the port
  Try hMySerial.Close
  Try iReconnectRetry = hMySerial.ReconnectRetry

  ' get a new one
  hMySerial = New CSerialPort(iReconnectRetry) As "MySerial"

  With hMySerial
    .DataType = &HFF + gb.Byte
    .PortName = $sSerPort
    .Speed = $sBaud
    .Parity = 0
    .DataBits = 8
    .StopBits = 1
    .FlowControl = 0
    .Open()
 End With

  ' Write to main logfile we connected successfully
  WriteLog(PluginFriendlyName & " serial interface connected to port " & $sSerPort)
  IsRunning = True

  ' Initialize variables
  Run()

Catch ' some errors
  WriteLog("ERROR: " & PluginFriendlyName & " serial interface FAILED to connect to port " & $sSerPort)
  WriteLog("ERROR: " & Error.Text)
  IsRunning = False
  ErrorText = Error.Text
  ErrorWhere = Error.Where

End

'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
' close port
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Private Sub Disconnect()

  ' try to close the connection
  Try hMySocket.Close
  Try hMySerial.Close

  ' close a possible broadcast server
  Try hBroadcastUDP.Close

  ' try stop running timers
  StopTimers()

  WriteLog(PluginFriendlyName & IIf($sInterface = "tcp", " TCP connection closed.", " Port closed."))

Finally
  IsRunning = False
  ErrorText = ""
  ErrorWhere = ""

Catch
  WriteLog("ERROR: '" & Error.Text & "' at '" & Error.Where & "'")

End

'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
'
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Private Sub StopTimers()

  Try $tQueueDelay.Stop

End

'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
' Run after succesfull connect
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Private Sub Run()

  ' Empty internal buffer
  $sBuffer = ""

  ' Stop timer for Interface delay/busy
  $tQueueDelay.Stop

  ' Kick off the queue, this can be needed after a reconnect
  DoQueue()

End

'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
' peer closed tcp socket
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Public Sub MySocket_Closed()

  WriteLog("ERROR: TCP socket closed by peer.")

  IsRunning = False
  ErrorText = "TCP socket closed by peer"

  StopTimers()

End

'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
' error while connected/connecting to tcp host
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Public Sub MySocket_Error(sMsg As String)

  WriteLog("ERROR: " & sMsg)

  IsRunning = False
  ErrorText = sMsg

  StopTimers()

End

'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
' host ip address found
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Public Sub MySocket_Found()

  Log.Plugin_DNS_Found(LogLabel, $sTCPHost)

End

'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
' tcp socket is connected
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Public Sub MySocket_Ready()

  WriteLog("TCP interface connected.")
  IsRunning = True

  Run()

End

'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
' Called when we should reconnect to the tcp host
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Public Sub MySocket_Reconnect()

  ConnectTCP()

End

'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
' received data from the tcp port. vVar is gb.String
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Public Sub MySocket_Read(vVar As Variant)

  Dim bData As Byte

  If vVar Then
    For Each bData In vVar
      ProcessReceivedChar(bData)
    Next
  Endif

End

'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
' Handle errors
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Public Sub MySerial_Error(sMsg As String)

  WriteLog("ERROR: " & sMsg)

End

'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
' read data char for char
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Public Sub MySerial_Read(vVar As Variant)

  Dim bData As Byte

  If vVar Then
    For Each bData In vVar
      ProcessReceivedChar(bData)
    Next
  Endif

End

'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
' Handle reconnect(s)
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Public Sub MySerial_Reconnect()

  ' ReConnect/Initialize connection
  ConnectSerial()

End


'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
' send command via serial port or tcp socket
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Private Sub WriteCommand(sCmd As String, sKey As String)

  Dim sOut As String

  ' Don't try to do something if we are in error state
  If Not IsRunning Then
    WriteLog("ERROR: Can't send command, because plugin is in error state!")
    Return
  Endif

  ' The output format for serial and tcp are different
  If $sInterface = "tcp" Then
    ' the length is !1 + sCmd + gb.Cr
    sOut = "ISCP\x00\x00\x00\x10\x00\x00\x00" & Chr(Len(sCmd) + 3) & "\x01\x00\x00\x00!1" & sCmd & gb.Cr
    If $bDebug Then WriteDebugLog("> " & StringToHex(sOut))
  Else
    sOut = "!1" & sCmd & gb.Cr
    If $bDebug Then WriteDebugLog("> " & StringToHex(sOut))
  Endif

  ' IF $bDebug THEN Main.WriteDebugLog(LogLabel & "Sending '") & sCmd & ("' to Receiver."))

  ' Write to serial, but we read as byte[] and write as string
  If $sInterface = "tcp" Then
    hMySocket.Write(sOut, gb.String)
  Else
    hMySerial.Write(sOut, gb.String)
  Endif

  If $bDebug Then
    WriteDebugLog("> " & sCmd)
    WriteDebugLog("  Queue Count: " & ($cQueue.Count - 1))
  Endif

  ' remove sent command from queue
  $cQueue.Remove(sKey)

  ' start timer to wait before sending next command
  $tQueueDelay.Delay = 50 ' 50msec based on Onkyo documentation
  $tQueueDelay.Start

End

'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
' to switch unit with device control
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Public Sub SendCommand(sAddress As String, sValue As String)

  Dim aCmd As String[]

  ' ignore sAddress, only fixed unit 1?
  Select Case LCase(sValue)
    Case "on"
      SetCommand("power", "on", sAddress)
    Case "off"
      SetCommand("power", "off", sAddress)
    Case Else
      aCmd = Split(sValue, " ")
      If aCmd.Count = 2 Then
        SetCommand(aCmd[0], aCmd[1], sAddress)
      Else
        If $bDebug Then WriteDebugLog("Unsupported command received: " & sValue)
      Endif
      SetCommand(sValue, sAddress)
  End Select

End

'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
' to control from json-rpc or music page buttons
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Public Sub SetCommand(sCmd As String, sValue As String, sAddress As String)

  Dim sTmp As String

  ' commands here are for Integra DTR-40.1
  ' ignore sAddress, only fixed unit 1
  sAddress = sAddress
  Select LCase(sCmd)
    Case "power"
      ' 00 - Off, 01 - On
      QueueCommand(IIf(sValue == "on", "PWR01", "PWR00"))
    Case "volume"
      Select LCase(sValue)
        Case "up"
          QueueCommand("MVLUP")
        Case "down"
          QueueCommand("MVLDOWN")
        Case "up1"
          QueueCommand("MVLUP1")
        Case "down1"
          QueueCommand("MVLDOWN1")
        Case Else
          ' 0-100 (0-64 Hex)
          QueueCommand("MVL" & Hex(Val(sValue), 2))
      End Select
    Case "mute"
      ' 00 - Off, 01 - On, TG - Toggle
      Select LCase(sValue)
        Case "on"
          QueueCommand("AMT01")
        Case "off"
          QueueCommand("AMT00")
        Case "toggle"
          QueueCommand("AMTTG")
      End Select
    Case "input", "z2input"
      sTmp = IIf(sCmd == "input", "SLI", "SLZ")
      Select LCase(sValue)
        Case "vcr", "dvr", "video1"
          QueueCommand(sTmp & "00")
        Case "cbl/sat", "video2"
          QueueCommand(sTmp & "01")
        Case "game/tv", "game", "video3"
          QueueCommand(sTmp & "02")
        Case "aux1", "aux", "video4"
          QueueCommand(sTmp & "03")
        Case "aux2", "video5"
          QueueCommand(sTmp & "04")
        Case "video6"
          QueueCommand(sTmp & "05")
        Case "video7"
          QueueCommand(sTmp & "06")
        Case "dvd"
          QueueCommand(sTmp & "10")
        Case "tv/tape", "tape", "tape1"
          QueueCommand(sTmp & "20")
        Case "tape2"
          QueueCommand(sTmp & "21")
        Case "phono"
          QueueCommand(sTmp & "22")
        Case "cd"
          QueueCommand(sTmp & "23")
        Case "fm"
          QueueCommand(sTmp & "24")
        Case "am"
          QueueCommand(sTmp & "25")
        Case "tuner"
          QueueCommand(sTmp & "26")
        Case "net", "server"
          QueueCommand(sTmp & "27")
        Case "inet radio"
          QueueCommand(sTmp & "28")
        Case "usb front"
          QueueCommand(sTmp & "29")
        Case "usb rear"
          QueueCommand(sTmp & "2A")
        Case "port"
          QueueCommand(sTmp & "40")
        Case "up"
          QueueCommand(sTmp & "UP")
        Case "down"
          QueueCommand(sTmp & "DOWN")
        Case "off"
          QueueCommand(sTmp & "7F")
      End Select
    Case "cli"
      QueueCommand(sValue)
    Case "z2power"
      ' 00 - Off, 01 - On
      QueueCommand(IIf(sValue == "on", "ZPW01", "ZPW00"))
    Case "z2mute"
      ' 00 - Off, 01 - On, TG - Toggle
      Select LCase(sValue)
        Case "on"
          QueueCommand("ZMT01")
        Case "off"
          QueueCommand("ZMT00")
        Case "toggle"
          QueueCommand("ZMTTG")
      End Select
    Case "z2volume"
      Select Case LCase(sValue)
        Case "up"
          QueueCommand("ZVLUP")
        Case "down"
          QueueCommand("ZVLDOWN")
        Case "up1"
          QueueCommand("ZVLUP1")
        Case "down1"
          QueueCommand("ZVLDOWN1")
        Case Else
          ' 0-100 (0-64 Hex)
          QueueCommand("ZVL" & Hex(Val(sValue), 2))
      End Select
    Case Else
      If $bDebug Then WriteDebugLog("Unsupported set command received: " & sCmd & " " & sValue)
  End Select

End

Public Sub GetCommand(sCmd As String, sAddress As String)

  ' ignore sAddress, only fixed unit 1
  sAddress = sAddress
  Select Case LCase(sCmd)
    Case "power"
      QueueCommand("PWRQSTN")
    Case Else
      If $bDebug Then WriteDebugLog("Unsupported get value received: " & sCmd)
  End Select

End

'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
'
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Private Sub ProcessReceivedChar(bTemp As Byte)

  If bTemp = 26 Then ' buffer until linefeed then parse
    If Len($sBuffer) > 1 Then ProcessReceivedPacket($sBuffer)
    $sBuffer = ""
  Else
    ' Append only if the string is not empty, and not gb.Cr or gb.Lf
    If Len($sBuffer) Then
      $sBuffer &= Chr(bTemp)
    Else
      If bTemp <> &H0D And If bTemp <> &H0A Then
        $sBuffer &= Chr(bTemp)
      Endif
    Endif
  Endif

End

'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
' parse received data
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Private Sub ProcessReceivedPacket(sBuf As String)

  Dim sStr As String
  Dim iHdrSize As Integer
  Dim iDataSize As Integer

  If $bDebug Then WriteDebugLog("< " & StringToHex(sBuf))

  ' Data received on serial and tcp is different
  If $sInterface = "tcp" Then
    If Len(sBuf) < 22 Then
      If $bDebug Then WriteDebugLog("ERROR: Invalid packet received, minimal length is 22 bytes")
      Return
    Endif

    If InStr(sBuf, "ISCP") <> 1 Then
      If $bDebug Then WriteDebugLog("ERROR: Invalid packet received, doesn't start with 'ISCP'")
      Return
    Endif
    
    If InStr(sBuf, "!1") = 0 Then
      If $bDebug Then WriteDebugLog("ERROR: Invalid packet received, doesn't contain '!1'")
      Return
    Endif

    ' All looks good, lets extract the command

    iHdrSize = Val("&H" & Hex$(Asc(sBuf, 5), 2) & Hex$(Asc(sBuf, 6), 2) & Hex$(Asc(sBuf, 7), 2) & Hex$(Asc(sBuf, 8), 2))
    iDataSize = Val("&H" & Hex$(Asc(sBuf, 9), 2) & Hex$(Asc(sBuf, 10), 2) & Hex$(Asc(sBuf, 11), 2) & Hex$(Asc(sBuf, 12), 2))

    If $bDebug Then
      WriteDebugLog("  Header Size=" & iHdrSize)
      WriteDebugLog("  Data Size=" & iDataSize)
      WriteDebugLog("  Version=" & CInt(Asc(sBuf, 13)))
      WriteDebugLog("  eISCP 1-5=" & Mid(sBuf, iHdrSize + 1, 5))
      WriteDebugLog("  iSCP Msg=" & Mid(sBuf, iHdrSize + 6))
    Endif

    sStr = Mid(sBuf, InStr(sBuf, "!1") + 2, 5)

  Else

    If Len(sBuf) < 5 Then
      If $bDebug Then WriteDebugLog("ERROR: Invalid packet received, minimal length is 5 bytes")
      Return
    Endif

    If InStr(sBuf, "!1") <> 1 Then
      If $bDebug Then WriteDebugLog("ERROR: Invalid packet received, doesn't contain '!1'")
      Return
    Endif

    If $bDebug Then
      WriteDebugLog("  eISCP 1-5=" & Mid(sBuf, 1, 5))
      WriteDebugLog("  SCP Msg=" & Mid(sBuf, 6))
    Endif

    sStr = Mid(sBuf, InStr(sBuf, "!1") + 2, 5)

  Endif

  If $bDebug Then WriteDebugLog("< " & sStr)

  ' Currently we do exact matching for power on/off
  Select sStr
    Case "PWR00"
      OnkyoSetValue("Power", "Off")
    Case "PWR01"
      OnkyoSetValue("Power", "On")
  End Select

End

'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
' save received values
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Private Sub OnkyoSetValue(sItem As String, vValue As Variant)

  Main.SetGlobalVar("Onkyo_" & sItem, vValue)
  If $bDebug Then WriteDebugLog("Received Item: " & sItem & " Value: " & vValue)

End

'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
' Add command to queue
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Private Sub QueueCommand(sCmd As String)

  ' add command to queue
  $cQueue.Add(sCmd, Rnd)

  ' if bus is Not busy process it
  If Not $tQueueDelay.Enabled Then DoQueue()

End

'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
' Process next item in queue
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Private Sub DoQueue()

  Dim sCmd As String

  For Each sCmd In $cQueue
    WriteCommand(sCmd, $cQueue.Key)
    Break ' only do first one
  Next

End

'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
' Interface busy timer
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Public Sub QueueDelay_Timer()

  $tQueueDelay.Stop

  If $cQueue.Count Then ' if there are more commands left in queue, send next one
    If $bDebug Then WriteDebugLog("Sending command from Queue (count = " & $cQueue.Count & ")")
    DoQueue()
  Endif

End

'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
' received data from the udp port on our previous discovery
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Public Sub BroadcastUDP_Read()

  Dim sStr As String

  sStr = Read #Last, Lof(Last)

  If $bDebug Then
    WriteDebugLog("< UDP Discovery: " & StringToHex(sStr) & "(" & sStr & ")")
  Endif

End

Public Sub StringToHex(sStr As String, Optional bSpace As Boolean = True) As String

  Dim sOut As String
  Dim iLen As Integer

  If bSpace Then
    ' Add a space between hex values
    For iLen = 1 To Len(sStr)
      sOut &= IIf(sOut, " ", "") & Hex$(Asc(sStr, iLen), 2)
    Next
  Else
    For iLen = 1 To Len(sStr)
      sOut &= Hex$(Asc(sStr, iLen), 2)
    Next
  Endif

  Return sOut

End
