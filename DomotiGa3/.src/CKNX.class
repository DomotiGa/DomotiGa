' Gambas class file

' Description:
' CKNX.class
' Provide support for KNX using eibd.

' Development Status:
' Just started developing this one.

' Links:
' http://www.auto.tuwien.ac.at/~mkoegler/index.php/eibd

' DomotiGa - an open source home automation program.
' Copyright (C) Ron Klinkien, The Netherlands.

' This module is written by Timo Sariwating in 2009.
' Updated by Ron Klinkien in 2014.

' Read file called COPYING for license details.

'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
' Module/Class specific variables
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Public PluginName As String = "KNX"
Public PluginType As Integer = Plugin.Type_Class
Public PluginFriendlyName As String = "KNX"
Public PluginVersion As String = "1.00"
Public PluginAuthor As String = "Timo Sariwating, Ron Klinkien"
Public PluginProtocols As String[]
Public PluginMaxInstances As Integer = 1

Public KeyName As String
Public LogLabel As String = "[KNX] "
Public Instance As Integer
Public IsRunning As Boolean
Public ErrorText As String
Public ErrorWhere As String

'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
' Private Variables
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Private $bEnabled As Boolean
Private $sTCPHost As String
Private $iTCPPort As Integer
Private $bKNXDebug As Boolean

Public hKNX As New Socket
Public tKNX As Timer

Private Const CmdOn As Byte = &H81
Private Const CmdOff As Byte = &H80

'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
' Mandatory subroutine for each Module/Class to initialize:
' - The cPlugin[x].Settings are copied into local variables
' - Port/Connection will be started (any errors caught)
' - Any other code per Class
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Public Sub StartPlugin(cPl As CPluginEntry)

  KeyName = cPl.KeyName
  Instance = cPl.Instance
  If Instance <> 1 Then LogLabel = Replace(LogLabel, "] ", "#" & Instance & "] ")

  ' Copy configuration items locally
  $bEnabled = cPl.Settings["enabled"]
  $sTCPHost = cPl.Settings["tcphost"]
  $iTCPPort = cPl.Settings["tcpport"]
  $bKNXDebug = cPl.Settings["debug"]
 
  ' Connect/Initialize connection
  Connect()

End

'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
' Mandatory sub for each Module/Class to stop
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Public Sub StopPlugin()

  Try Disconnect()

End

'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
' connect to the host:port
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Public Function Connect() As Boolean

  ' try to close the connection
  Try hKNX.Close

  ' get a new one
  hKNX = New Socket As "KNX"
  hKNX.Connect($sTCPHost, $iTCPPort)

  ' start poll timer for KNX status LED
  tKNX = New Timer As "tKNXLED"
  tKNX.Delay = 250
  tKNX.Stop

  ' Write to main logfile we are trying to connect
  Main.WriteLog(LogLabel & "TCP interface connecting to Server " & $sTCPHost & ":" & $iTCPPort)

  ' Don't set IsRunning=True, this has to be done in _Ready 

  ' All went ok
  Return True

Catch ' some errors
  Main.WriteLog(LogLabel & "ERROR: " & PluginFriendlyName & " TCP interface FAILED to connect to Server " & $sTCPHost & ":" & $iTCPPort)
  Main.WriteLog(LogLabel & "ERROR: " & Error.Text)
  IsRunning = False
  ErrorText = Error.Text
  ErrorWhere = Error.Where

  Return False

End

'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
' after connecting open a group socket for group communication
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Public Sub KNX_Ready()

  Dim bCommand As Byte[] = [CByte(&H00), CByte(&H26), CByte(&H00), CByte(&H00), CByte(&H00)]

  Main.WriteLog(LogLabel & "TCP interface connected.")
  IsRunning = True

  If $bKNXDebug Then Main.WriteDebugLog(LogLabel & "Sending command to open a Group Socket.")
  TX(bCommand)

End

Public Sub KNX_Error()

  Dim sMsg As String

  sMsg = Log.Text_TCP_Error(Last.Status, $sTCPHost)
  Main.WriteLog(LogLabel & "ERROR: " & sMsg)

  IsRunning = False
  ErrorText = sMsg

End

'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
' remote end closed socket
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Public Sub KNX_Closed()

  Main.WriteLog(LogLabel & "TCP socket closed.")

End

'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
' get KNX devicelist and query their status
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Public Sub GroupRead()

  Dim rDevices As Result

  ' get a list of KNX devices
  rDevices = Devices.FindDevicesForInterface(Devices.FindInterface("KNX Interface"))
  If rDevices.Count = 0 Then
    If $bKNXDebug Then Main.WriteDebugLog(LogLabel & "No devices found to send Group Read request to.")
    Return
  Endif
  For Each rDevices
    If $bKNXDebug Then Main.WriteDebugLog(LogLabel & "Sending Group Read request to device '" & rDevices!name & "' with address '" & rDevices!address & "'.")
    SendGroup(rDevices!address)
  Next

End

'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
' blink led
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Public Sub tKNXLED_Timer()

  Main.ControlLed("KNX", "Off")
  tKNX.Stop

End

'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
' send a packet to the KNX interface
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Private Sub TX(bCommand As Byte[])

  Dim bData As Byte
  Dim iLen As Integer = bCommand.Count

  If hKNX.Status <> Net.Connected Then
    Main.WriteDebugLog(LogLabel & "Not connected to " & PluginFriendlyName & " gateway: " & ERROR.Text & " at " & ERROR.Where)
    Return
  Endif

  bCommand.Add(&H00, 0)
  bCommand.Add(Hex(iLen), 1)
  bCommand.Write(hKNX, 0, bCommand.Length)

  If Not $bKNXDebug Then Return
  Main.WriteDebugLog(LogLabel & ">", True)
  For Each bData In bCommand
    Main.WriteRFXDebugLog(" " & Hex(bData, 2), True)
  Next
  Main.WriteRFXDebugLog("\n", True)

Catch
  Main.WriteDebugLog(LogLabel & "Error while trying to send: " & ERROR.Text & " at " & ERROR.Where)

End

'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
' disconnect from the host
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Public Function Disconnect() As Boolean

  ' try to close the connection
  Try hKNX.Close

  Main.WriteLog(LogLabel & "TCP Server closed.")

  ' all ok
  Return True

Finally
  IsRunning = False
  ErrorText = ""
  ErrorWhere = ""

Catch
  Main.WriteLog(LogLabel & "ERROR: " & Error.Text)
  Return False

End

'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
' Read KNX socket data
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Public Sub KNX_Read()

  Dim bMyBuf As New Byte[512]
  Dim iCnt As Integer
  Dim sDevice, sAddress As String
  Dim sReceived As New String[0]

  If hKNX.Status <> Net.Connected Then
    Main.WriteDebugLog(LogLabel & "Not connected to " & PluginFriendlyName & " gateway: '" & ERROR.Text & "' at '" & ERROR.Where & "'")
    Return
  Endif

  bMyBuf[0] = Read #hKNX As Byte ' read the first byte
  Main.ControlLed("KNX", "On")
  If Main.bServer Then tKNX.Start

  Select bMyBuf[0]
    Case 0
      bMyBuf[1] = Read #hKNX As Byte ' read the length byte
      For iCnt = 0 To bMyBuf[1] - 1 ' read the rest of the frame
        bMyBuf[2 + iCnt] = Read #hKNX As Byte
      Next
  End Select

  ' display raw data first
  If $bKNXDebug Then
    Main.WriteDebugLog(LogLabel & "<", True)
    For iCnt = 0 To bMyBuf[1] + 2
      Main.WriteRFXDebugLog(" " & Hex(bMyBuf[iCnt], 2), True)
    Next
    Main.WriteRFXDebugLog("\n", True)
  Endif

  Select Hex$(bMyBuf[3])
    Case 26 ' open group socket reply
      If $bKNXDebug Then Main.WriteDebugLog(LogLabel & "Received a Group Socket reply packet.")

      ' request status of all known devices
      GroupRead()

    Case 27 ' group packet
      sDevice = Addr2Str((Hex$(bMyBuf[4], 2)) & (Hex(bMyBuf[5], 2)), False)
      sAddress = Addr2Str((Hex$(bMyBuf[6], 2)) & (Hex$(bMyBuf[7], 2)), True)
      If $bKNXDebug Then Main.WriteDebugLog(LogLabel & "Received packet from physical device address '" & sDevice & "' to '" & sAddress & "'")
      For iCnt = 9 To bMyBuf.Length - 1
        sReceived.Add(Hex(bMyBuf[iCnt], 2))
      Next
      LookupEIS(sAddress, sReceived)

      ' TODO: check need for this
      ' also update switch which sends status change
      ' If InStr(sDevice <> "0.0.0" Then
      '   LookupEIS(sDevice, sReceived)
      ' Endif
      Case Else
        If $bKNXDebug Then Main.WriteDebugLog(LogLabel & "Received unknown packet type '" & Hex$(bMyBuf[3]) & "'")
  End Select

Catch
  Main.WriteDebugLog(LogLabel & "ERROR: '" & Error.Text & "' at '" & Error.Where & "'")

End

'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
' lookup the EIS type for received data
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Private Sub LookupEIS(sAddress As String, sReceived As String[])

  Dim iDeviceId As Integer = Devices.FindRegExp(sAddress, Devices.FindInterface("KNX Interface"))

  ' EIS1: DPT 1.001, EIS 1, Switches
  ' EIS2: NA, EIS 2, Dimmers
  ' EIS3: DPT 10.000, EIS 3, Time
  ' EIS4: DPT 11.000, EIS 4, Date
  ' EIS5: DPT 9.000, EIS 5, Values(weather stations etc)
  ' EIS6: DPT 5.001, EIS 6, Scaling(0 - 100%)
  ' EIS7: NA, EIS 7, Motor drives
  ' EIS8: DPT 2.001, EIS 8, forced control 2 bit
  ' EIS9: DPT 14.00 x, EIS 9, 32 - bit float
  ' EIS10: DPT 7.001, EIS 10, 16 - bit unsigned integer
  ' EIS10_1: DPT 8.001, EIS 10.001, 16 - bit signed integer
  ' EIS11: DPT 12.001, EIS 11, 32 - bit unsigned integer
  ' EIS11_1: DPT 13.001, EIS 11.001, 32 - bit signed integer
  ' EIS14: DPT 6.001, EIS 14, 8 - bit signed integer
  ' EIS14_1: DPT 5.010, EIS 14.1; 8 - bit unsigned integer
  ' EIS15: DPT 16.000, EIS 15, 14 byte text messages      

  If iDeviceId Then
    Select Case Devices.FindDescrForDeviceType(Devices.FindDeviceTypeForDevice(iDeviceId))
      ' TESTED
      Case "EIS 1" ' 1Bit value (for example on/off)
        ProcessEIS1(iDeviceId, sReceived)

      ' NOT TESTED
      Case "EIS 2" ' Dim
        ProcessEIS2(iDeviceId, sReceived)
      Case "EIS 3" ' 3Byte time value
        ProcessEIS3(iDeviceId, sReceived)
      Case "EIS 4" ' 3Byte date value
        ProcessEIS4(iDeviceId, sReceived)

      ' TESTED
      Case "EIS 5" ' 2Byte float value (for example 8.89V)
        ProcessEIS5(iDeviceId, sReceived)
      Case "EIS 6" ' 1Byte relative value (for example 21%)
        ProcessEIS6(iDeviceId, sReceived)
      Case "EIS 11" ' 32bit counter value (4Byte) (for example serial no 31442211)
        ProcessEIS11(iDeviceId, sReceived)
      Case Else
        Main.WriteDebugLog(LogLabel & "The KNX devicetype used for device with address '" & sAddress & "' and data '" & sReceived & "' is not yet supported, please report.")
    End Select
  Endif

End

'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
' handle received commands for EIS1 devices (switch on/off)
' address format is 0/1/2
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Private Sub ProcessEIS1(iDeviceId As Integer, sReceived As String[])

  Dim sCmd As String

  Select Case sReceived[0]
    Case "40", "80"
      sCmd = "Off"
    Case "41", "81"
      sCmd = "On"
    Case Else
      If $bKNXDebug Then Main.WriteDebugLog(LogLabel & "Unknown value '" & sReceived[0] & "' received for EIS1 type data packet!")
      Return
  End Select
  Devices.ValueUpdate(iDeviceId, 1, sCmd)
  If $bKNXDebug Then Main.WriteDebugLog(LogLabel & "EIS1 packet for device '" & Devices.FindNameForDevice(iDeviceId) & "' Value = '" & sCmd & "'")

End

'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
' handle received commands for EIS2 devices (dim)
' address format is 0/1/2|0/1/3|0/1/4
' first address is used for on/off, second start/stop, third dim value
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Private Sub ProcessEIS2(iDeviceId As Integer, sReceived As String[])

  Dim iPercentage As Integer

  Select Case sReceived[0]
    Case "40"
      Devices.ValueUpdate(iDeviceId, 1, "Off")
      iPercentage = Val("&H" & sReceived[1]) / 255 * 100
      If iPercentage = 0 Then
        Devices.ValueUpdate(iDeviceId, 1, "Off")
      Else If iPercentage = 100 Then
        Devices.ValueUpdate(iDeviceId, 1, "On")
      Else
        Devices.ValueUpdate(iDeviceId, 1, "Dim " & CStr(iPercentage))
      Endif
    Case "41"
      If $bKNXDebug Then Main.WriteDebugLog(LogLabel & "EIS2 packet for device '" & Devices.FindNameForDevice(iDeviceId) & "' Value = 'On'")
        Devices.ValueUpdate(iDeviceId, 1, "On")
        iPercentage = Val("&H" & sReceived[1]) / 255 * 100
        If iPercentage <> "0" And iPercentage <> "100" Then
          If $bKNXDebug Then Main.WriteDebugLog(LogLabel & "EIS2 packet for device '" & Devices.FindNameForDevice(iDeviceId) & "' Value = 'Dim " & CStr(iPercentage) & "%'")
          Devices.ValueUpdate(iDeviceId, 1, "Dim " & CStr(iPercentage))
      Endif
    Case "80"
      If sReceived[1] <> "00" Then
        iPercentage = Val("&H" & sReceived[1]) / 255 * 100
        If iPercentage = 0 Then
          Devices.ValueUpdate(iDeviceId, 1, "Off")
        Else If iPercentage = 100 Then
          Devices.ValueUpdate(iDeviceId, 1, "On")
        Else
          Devices.ValueUpdate(iDeviceId, 1, "Dim " & CStr(iPercentage))
        Endif
        If $bKNXDebug Then Main.WriteDebugLog(LogLabel & "EIS2 packet for device '" & Devices.FindNameForDevice(iDeviceId) & "' Value = 'Dim " & CStr(iPercentage) & "%'")
      Else
        If $bKNXDebug Then Main.WriteDebugLog(LogLabel & "EIS2 packet for device '" & Devices.FindNameForDevice(iDeviceId) & "' Value = 'Off'")
        Devices.ValueUpdate(iDeviceId, 1, "Off")
      Endif
    Case "81"
      If $bKNXDebug Then Main.WriteDebugLog(LogLabel & "EIS2 packet for device '" & Devices.FindNameForDevice(iDeviceId) & "' Value = 'On'")
      Devices.ValueUpdate(iDeviceId, 1, "On")
    Case "89"
      If $bKNXDebug Then Main.WriteDebugLog(LogLabel & "EIS2 packet for device '" & Devices.FindNameForDevice(iDeviceId) & "' Value = 'Dim'")
    Case Else
      If $bKNXDebug Then Main.WriteDebugLog(LogLabel & "Unknown value '" & sReceived[0] & "' received for EIS2 type data packet!")
      Return
  End Select

End

'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
' handle received commands for EIS3 devices (time)
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Private Sub ProcessEIS3(iDeviceId As Integer, sReceived As String[])

  Dim sAddressSplit As String[]
  Dim bCommand As New Byte[9]
  Dim sTime As String

  Select Case sReceived[0]
    Case "80"
      sTime = DecodeEIS3(sReceived)
      If $bKNXDebug Then Main.WriteDebugLog(LogLabel & "EIS3 decoded for device '" & Devices.FindNameForDevice(iDeviceId) & " Value = '" & sTime & "'")
      Devices.ValueUpdate(iDeviceId, 1, sTime)
    Case "00"
      sAddressSplit = Split(Devices.FindAddressForDevice(iDeviceId), "/")
      bCommand[0] = &H00
      bCommand[1] = &H27
      bCommand[2] = Hex$(Val(sAddressSplit[0]) & Val(sAddressSplit[1]))
      bCommand[3] = Val(sAddressSplit[2])
      bCommand[4] = &H00
      bCommand[5] = &H80
      bCommand[6] = Hex$(Hour(Now))
      bCommand[7] = Hex$(Minute(Now))
      bCommand[8] = Hex$(Second(Now))
      TX(bCommand)
      If $bKNXDebug Then Main.WriteDebugLog(LogLabel & "EIS3: Time '" & Time(Now) & "' send to the bus.")
  End Select

End

' DTP10 / EIS3
'
' ## 3 Byte Time
' ## DDDHHHHH RRMMMMMM RRSSSSSS
' ## R Reserved
' ## D WeekDay
' ## H Hour
' ## M Minutes
' ## S Seconds

Public Sub DecodeEIS3(sReceived As String[]) As String

  Dim aWeekDays As String[] = ["", "Mo", "Tu", "We", "Th", "Fr", "Sa", "Su"]
  Dim iWeekDay As Integer = Lsr((sReceived[1] And &HE0), 5)
  Dim iHour, iMin, iSec As Integer

  iHour = Val("&H" & sReceived[1]) And &H1F
  iMin = Val("&H" & sReceived[2])
  iSec = Val("&H" & sReceived[3])

  Return aWeekdays[iWeekday] & " " & Format(iHour, "00") & ":" & Format(iMin, "00") & ":" & Format(iSec, "00")

End

'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
' handle received commands for EIS4 devices (date)
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Private Sub ProcessEIS4(iDeviceId As Integer, sReceived As String[])

  Dim sAddressSplit As String[]
  Dim bCommand As New Byte[9]
  Dim sDate As String

  Select Case sReceived[0]
    Case "80"
      sDate = DecodeEIS4(sReceived)
      If $bKNXDebug Then Main.WriteDebugLog(LogLabel & "EIS4: " & Devices.FindNameForDevice(iDeviceId) & " " & sDate)
      Devices.ValueUpdate(iDeviceId, 1, sDate)
    Case "00"
      sAddressSplit = Split(Devices.FindAddressForDevice(iDeviceId), "/")
      bCommand[0] = &H00
      bCommand[1] = &H27
      bCommand[2] = Hex$(Val(sAddressSplit[0]) & Val(sAddressSplit[1]))
      bCommand[3] = Val(sAddressSplit[2])
      bCommand[4] = &H00
      bCommand[5] = &H80
      bCommand[6] = Hex$(Day(Now))
      bCommand[7] = Hex$(Month(Now))
      bCommand[8] = Hex$(Right$(CStr(Year(Now)), 2))
      TX(bCommand)
      If $bKNXDebug Then Main.WriteDebugLog(LogLabel & "EIS4: Date '" & Day(Now) & "/" & Month(Now) & "/" & Year(Now) & "' send to the bus.")
  End Select

End

' DTP11 / EIS4
'
' ## 3 byte Date
' ## RRRDDDDD RRRRMMMM RYYYYYYY
' ## R Reserved
' ## D Day
' ## M Month
' ## Y Year

Public Sub DecodeEIS4(sReceived As String[]) As String

  Dim iDay, iMonth, iYear As Integer

  iDay = Val("&H" & sReceived[1])
  iMonth = Val("&H" & sReceived[2])
  iYear = Val("&H" & sReceived[3]) + 2000

  Return Format(iDay, "00") & "-" & Format(iMonth, "00") & "-" & Format(iYear, "####")

End

'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
' handle received for EIS5 devices (values)
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Private Sub ProcessEIS5(iDeviceId As Integer, sReceived As String[])

  Dim fValue As Float

  Select Case sReceived[0] ' receive
    Case "80", "40"
      fValue = DecodeEIS5(sReceived[1] & sReceived[2])
      If $bKNXDebug Then Main.WriteDebugLog(LogLabel & "EIS5 packet for device '" & Devices.FindNameForDevice(iDeviceId) & "' Value = '" & fValue & "'")
      Devices.ValueUpdate(iDeviceId, 1, fValue)
    Case Else
      If $bKNXDebug Then Main.WriteDebugLog(LogLabel & "Unknown value '" & sReceived[0] & "' received for EIS5 type data packet!")
      Return
  End Select

End

' DTP9 / EIS5
'
' ## 2 Byte Float
' ## SEEEEMMM MMMMMMMM
' ## S Sign (0 / 1)
' ## E Exponent (0..15)
' ## M Mantisse (-2048...2047)
' ## For all Datapoint Types 9.xxx, the encoded value 7 FFFh shall always be used to denote invalid data.

Public Sub DecodeEIS5(sValue As String) As Float

  Dim iExp, iMant, iVal As Integer = Val("&H" & sValue)

  iMant = iVal And &H07FF
  If (iVal And &H08000&) Then
    iMant = iMant Or &HFFFFF800&
    iMant = - iMant
  Endif
  iExp = Lsr((iVal And &H07800&), 11)
  If (iVal And &H08000&) Then iMant = - iMant
  Return (iMant * Lsl(1, iExp) / 100)

End

'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
' decode and update EIS6 values
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Private Sub ProcessEIS6(iDeviceId As Integer, sReceived As String[])

  Dim iValue As Float

  Select Case sReceived[0] ' receive
    Case "80", "40"
      iValue = DecodeEIS6(sReceived[1])
      If $bKNXDebug Then Main.WriteDebugLog(LogLabel & "EIS6 packet for device '" & Devices.FindNameForDevice(iDeviceId) & "' Value = '" & iValue & "'")
      Devices.ValueUpdate(iDeviceId, 1, iValue)
    Case Else
      If $bKNXDebug Then Main.WriteDebugLog(LogLabel & "Unknown value '" & sReceived[0] & "' received for EIS6 type data packet!")
      Return
  End Select

End

Public Sub DecodeEIS6(sValue As String) As Integer

  Return Val("&H" & sValue)

End

'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
' decode and update EIS11 values
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Private Sub ProcessEIS11(iDeviceId As Integer, sReceived As String[])

  Dim sValue As String

  Select Case sReceived[0] ' receive
    Case "80", "40"
      sValue = DecodeEIS11(sReceived)
      If $bKNXDebug Then Main.WriteDebugLog(LogLabel & "EIS11 packet for device '" & Devices.FindNameForDevice(iDeviceId) & "' Value = '" & sValue & "'")
      Devices.ValueUpdate(iDeviceId, 1, sValue)
    Case Else
      If $bKNXDebug Then Main.WriteDebugLog(LogLabel & "Unknown value '" & sReceived[0] & "' received for EIS11 type data packet!")
      Return
  End Select

End

Public Sub DecodeEIS11(sBuffer As String[]) As Integer

  'Return Val("&H" & sBuffer[1]) & Val("&H" & sBuffer[2]) & Val("&H" & sBuffer[3]) & Val("&H" & sBuffer[4])
  Return Val(sBuffer[1]) & Val(sBuffer[2]) & Val(sBuffer[3]) & Val(sBuffer[4])
  'Return sBuffer[1] & sBuffer[2] & sBuffer[3] & sBuffer[4]

End

'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
' prepare a command for sending status request to KNX interface
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Private Sub SendGroup(sAddress As String)

  Dim sAddressSplit As String[]
  Dim sAddr As String
  Dim bCommand As New Byte[5]

  If $bKNXDebug Then Main.WriteDebugLog(LogLabel & "Requesting status packet for device with address '" & sAddress & "'")
  sAddressSplit = Split(sAddress, "/")
  If sAddressSplit.Count = 3 Then
    sAddr = Str2Addr(sAddressSplit[0], sAddressSplit[1], sAddressSplit[2])
    bCommand[0] = &H00
    bCommand[1] = &H27
    bCommand[2] = Val("&H" & Left(sAddr, 2))
    bCommand[3] = Val("&H" & Right(sAddr, 2))
    bCommand[4] = &H00
    bCommand.Add(&H00)
    TX(bCommand)
  Else
    sAddressSplit = Split(sAddress, "|" "/")
    If sAddressSplit.Count = 9 Then
      sAddr = Str2Addr(sAddressSplit[3], sAddressSplit[4], sAddressSplit[5])
      bCommand[0] = &H00
      bCommand[1] = &H27
      bCommand[2] = Val("&H" & Left(sAddr, 2))
      bCommand[3] = Val("&H" & Right(sAddr, 2))
      bCommand[4] = &H00
      bCommand.Add(&H00)
      TX(bCommand)
    Endif
  Endif

End

'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
' extract correct address from given string and prepare for sending the KNX interface
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Private Sub CreateAddr(sAddress As String, iMin As Integer, Optional iPos As Integer = 1) As String

  Dim aAddresses, aAddress As String[]

  ' did we got the minimum no. of group addresses?
  aAddresses = Split(sAddress, "|")
  If aAddresses.Count < (iMin - 1) Then
    Select Case iMin
      Case 1
        Main.WriteDebugLog(LogLabel & "Invalid address format used '" & sAddress & "', should be in format '0/1/2'")
      Case 2
        Main.WriteDebugLog(LogLabel & "Invalid address format used '" & sAddress & "', should be in format '0/1/2|0/1/3'")
      Case 3
        Main.WriteDebugLog(LogLabel & "Invalid address format used '" & sAddress & "', should be in format '0/1/2|0/1/3|0/1/4'")
    End Select
  Else
    ' extract and convert the one we need
    aAddress = Split(sAddress, "|" "/")
    If aAddress.Count >= 3 * iPos Then
      Select Case iPos
        Case 1
          Return Str2Addr(aAddress[0], aAddress[1], aAddress[2])
        Case 2
          Return Str2Addr(aAddress[3], aAddress[4], aAddress[5])
        Case 3
          Return Str2Addr(aAddress[6], aAddress[7], aAddress[8])
        Case Else
          Main.WriteDebugLog(LogLabel & "Invalid address format used '" & sAddress & "', should be in format '0/1/2' or '0/1/2|0/1/3' or '0/1/2|0/1/3|0/1/4'")
      End Select
    Else
      Main.WriteDebugLog(LogLabel & "Invalid address format used '" & sAddress & "', should be in format '0/1/2' or '0/1/2|0/1/3' or '0/1/2|0/1/3|0/1/4'")
    Endif
  Endif
  
End

'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
' prepare a command for sending to the KNX interface
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Public Sub SendCommand(sAddress As String, sValue As String)

  Dim sAddr, sModule As String
  Dim iBrightness As Integer
  Dim bCommand As New Byte[5]

  sValue = UCase(sValue)
  sModule = Devices.FindDescrForDeviceType(Devices.FindDeviceTypeForDevice(Devices.Find(Instance, sAddress, Devices.FindInterface("KNX Interface"))))
 
  Select Case sModule
    Case "EIS 1"  ' EIS1 on/off switch with one or two addresses (control or control|feedback)
      sAddr = CreateAddr(sAddress, 1, 1)
      If Len(sAddr) <> 4 Then Return

      bCommand[0] = &H00
      bCommand[1] = &H27
      bCommand[2] = Val("&H" & Left(sAddr, 2))
      bCommand[3] = Val("&H" & Right(sAddr, 2))
      bCommand[4] = &H00
      Select Case sValue
        Case "ON"
          bCommand.Add(CmdOn)
          TX(bCommand)
        Case "OFF"
          bCommand.Add(CmdOff)
          TX(bCommand)
      End Select 

    Case "EIS 2"
      ' EIS type 2. Dimmer switch item
      ' An KNX dimmer consists of three different items, (command/control/value)
      ' Command is for switching the light on/off (EIS1), control is for start/stop dimming and brightening
      ' And value is for setting a specific brightness level(0 - 100)
      ' If you have a dimmer which doesn't support start/stop specify -/-/- as middle address

      bCommand[0] = &H00
      bCommand[1] = &H27
      bCommand[4] = &H00

      Select Case sValue
        Case "ON"
          sAddr = CreateAddr(sAddress, 1, 3)
          If Len(sAddr) <> 4 Then Return

          bCommand[2] = Val("&H" & Left(sAddr, 2))
          bCommand[3] = Val("&H" & Right(sAddr, 2))
          bCommand.Add(CmdOn)
          TX(bCommand)
        Case "OFF"
          sAddr = CreateAddr(sAddress, 1, 3)
          If Len(sAddr) <> 4 Then Return

          bCommand[2] = Val("&H" & Left(sAddr, 2))
          bCommand[3] = Val("&H" & Right(sAddr, 2))
          bCommand.Add(CmdOff)
          TX(bCommand)
        Case "STOP"
          If InStr(sAddress, "-/-/-") Then 
            If $bKNXDebug Then Main.WriteDebugLog(LogLabel & "Dimmer 'startstop' address of '-/-/-' specified, skipping command.")  
            Return
          Endif
          sAddr = CreateAddr(sAddress, 2, 3)
          If Len(sAddr) <> 4 Then Return

          bCommand[2] = Val("&H" & Left(sAddr, 2))
          bCommand[3] = Val("&H" & Right(sAddr, 2))
          bCommand.Add(&H80)
          TX(bCommand)
        Case Else
          If InStr(sValue, "DIM ") Then ' DIM 0-100
            iBrightness = Val(Replace(sValue, "DIM ", ""))
            sAddr = CreateAddr(sAddress, 3, 3)
            If Len(sAddr) <> 4 Then Return

            bCommand[2] = Val("&H" & Left(sAddr, 2))
            bCommand[3] = Val("&H" & Right(sAddr, 2))
            bCommand.Add(&H80)
            bCommand.Add(CInt(iBrightness * 2.55))
            TX(bCommand)
          Endif
      End Select

  End Select

End

Public Function Addr2Str(sAddress As String, bGroupAddress As Boolean) As String

  If bGroupAddress Then
    ' convert to group address
    Return (Lsr((Val("&H" & sAddress)), 11) And &HF) & "/" & (Lsr((Val("&H" & sAddress)), 8) And &H7) & "/" & ((Val("&H" & sAddress)) And &HFF)
  Else
    ' convert to physical address
    Return (Lsr((Val("&H" & sAddress)), 12)) & "." & (Lsr((Val("&H" & sAddress)), 8) And &HF) & "." & ((Val("&H" & sAddress)) And &HFF)
  Endif

End

Public Function Str2Addr(sA1 As String, sA2 As String, sA3 As String) As String

  Dim sString As String = Lsl(Val(sA1), 11) Or Lsl(Val(sA2), 8) Or Val(sA3)

  Return Hex$(sString, 4)

End

