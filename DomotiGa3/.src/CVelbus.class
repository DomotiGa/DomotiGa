' Gambas class file

' Description:
' CVelbus.class
' Connect to Velbus interface via TCP socket or serial port.

' Development Status:
' Work in progress
'
' Code currently supports Velbus modules
'
'   VMB2BLE  - 2 channel blind module
'   VMB4RY   - 4 Relay module
'   VMB4RYNO - 4 channel relay module with normal open contacts
'   VMB4RYLD - 4 channel relay module with direct load connections
'   VMB4DC   - 0/1 - 10V dimmer controller
'   VMB7IN   - 7 Channel input module
'   VMB8PN   - 8 Push button module
'   VMBDME   - Dimmer module
'   VMBGPO   - Oled touch panel (Black or White)
'   VMBDMI   - Velbus dimmer for resistive or inductive load
'
' To add support for additional modules make these changes
'
'  1. Write a "<moduletype>_Receive" sub routine
'  2. Write a "<moduletype>_Send" sub routine
'  3. Add the <moduletype> to the "ProcessReceivedPacket" routine
'  4. Add the <moduletype> to the "GetModuleType" routine
'  5. Append in the "SendCommand" routine the calls to the "<moduletype>_Send" sub routine
'
' Credits: BreFra (Frank van Breugel)

' DomotiGa - an open source home automation program.
' Copyright (C) Ron Klinkien, The Netherlands.

' Read file called COPYING for license details.

'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
' Module/Class specific variables
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Public PluginName As String = "Velbus"
Public PluginFriendlyName As String = "Velleman Velbus"
Public PluginVersion As String = "1.02"
Public PluginAuthor As String = "BreFra"
Public PluginProtocols As String[]
Public PluginMaxInstances As Integer = 1

Public KeyName As String
Public LogLabel As String = "[Velbus] "
Public InterfaceId As Integer
Public Instance As Integer
Public IsRunning As Boolean
Public ErrorText As String
Public ErrorWhere As String

'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
' Private Variables
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Private $bEnabled As Boolean
Private $sInterface As String
Private $sSerPort As String
Private $sBaud As String
Private $sTCPHost As String
Private $iTCPPort As Integer
Private $bRelayEnabled As Boolean
Private $iRelayPort As Integer
Private $bDebug As Boolean

' Command buffer
Private tVelbusBusy As Timer
Private bBusBusy As Boolean
Private cQueue As New Collection

' Scan buffer
Private tVelbusScan As Timer
Private cScanQueue As New Collection

' Interface objects
Public hMySocket As CSocket
Public hMySerial As CSerialPort
Public tVelbus As Timer
Public hVelbusRelay As New ServerSocket
Public hRelayVelbusClient As Object[]
Public hRelayVBSocket As New Socket

' Velbus module types
Const VMUNKNOWN As Byte = &H00
Const VMB8PB As Byte = &H01
Const VMB1RY As Byte = &H02
Const VMB1BL As Byte = &H03
Const VMB6IN As Byte = &H05
Const VMB1DM As Byte = &H07
Const VMB4RY As Byte = &H08
Const VMB2BL As Byte = &H09
Const VMB8IR As Byte = &H0A
Const VMB4PD As Byte = &H0B
Const VMB1TS As Byte = &H0C
Const VMB1TH As Byte = &H0D
Const VMB1TC As Byte = &H0E
Const VMB1LED As Byte = &H0F
Const VMB4RYLD As Byte = &H10
Const VMB4RYNO As Byte = &H11
Const VMB4DC As Byte = &H12
Const VMBMPD As Byte = &H13
Const VMBDME As Byte = &H14
Const VMBDMI As Byte = &H15
Const VMB8PBU As Byte = &H16
Const VMB6PBN As Byte = &H17
Const VMB2PBN As Byte = &H18
Const VMB6PBB As Byte = &H19
Const VMB4RF As Byte = &H1A
Const VMB1RYNO As Byte = &H1B
Const VMB1BLE As Byte = &H1C
Const VMB2BLE As Byte = &H1D
Const VMBGP1 As Byte = &H1E
Const VMBGP2 As Byte = &H1F
Const VMBGP4 As Byte = &H20
Const VMBGPO As Byte = &H21
Const VMB7IN As Byte = &H22
'Const VMB??? As Byte = &H23
'Const VMB??? As Byte = &H24
Const VMBGPTC As Byte = &H25
'Const VMB??? As Byte = &H26
'Const VMB??? As Byte = &H27
Const VMBGPOD As Byte = &H28
Const VMB1RYNOS As Byte = &H29
Const VMBPIRM As Byte = &H2A
Const VMBPIRC As Byte = &H2B
Const VMBPIRO As Byte = &H2C
Const VMBPP4PIR As Byte = &H2D
Const VMBDMIR As Byte = &H2E
Const VMBRF8RXS As Byte = &H30

' Velbus data packet
Const VB_STX As Byte = &H0F     'Start of packet
Const VB_ETX As Byte = &H04     'End of packet
Const VB_HPRIO As Byte = &HF8   'High priority
Const VB_LPRIO As Byte = &HFB   'Low priority

' Velbus commands (source: http://forum.velleman.eu/viewtopic.php?f=26&t=1738&p=9254&hilit=command+codes#p9215)
Const VB_STATUS As Byte = &H00
Const VB_SWITCH_OFF As Byte = &H01
Const VB_SWITCH_ON As Byte = &H02
Const VB_RELAY_TIMER As Byte = &H03
Const VB_BLIND_OFF As Byte = &H04
Const VB_BLIND_UP As Byte = &H05
Const VB_BLIND_DOWN As Byte = &H06
Const VB_DIMMER_SET As Byte = &H07
Const VB_DIMMER_TIMER As Byte = &H08
Const VB_BUS_OFF As Byte = &H09
Const VB_BUS_ACTIVE As Byte = &H0A
Const VB_RS232_BUFFER_FULL As Byte = &H0B
Const VB_RS232_BUFFER_EMPTY As Byte = &H0C
Const VB_REALY_TIMER_BLINK As Byte = &H0D
Const VB_INTERFACE_STATUS As Byte = &H0E
Const VB_SLIDER_STATUS As Byte = &H0F
Const VB_LAST_SLIDER_STATUS As Byte = &H11
Const VB_FORCED_OFF As Byte = &H12 ' COMMAND_FORCED_OFF
Const VB_CANCEL_FORCED_OFF As Byte = &H13 ' COMMAND_CANCEL_FORCED_OFF
Const VB_FORCED_ON As Byte = &H14 ' COMMAND_FORCED_ON
Const VB_CANCEL_FORCED_ON As Byte = &H15 ' COMMAND_CANCEL_FORCED_ON
Const VB_INHIBIT As Byte = &H16 ' COMMAND_INHIBIT
Const VB_CANCEL_INHIBIT As Byte = &H17 ' COMMAND_CANCEL_INHIBIT
Const VB_BLIND_SET As Byte = &H1C
Const VB_FIRMWARE_UPDATE As Byte = &H60
Const VB_FIRMWARE_INFO As Byte = &H61
Const VB_FIRMWARE_UPGRADE_ENTER As Byte = &H62
Const VB_FIRMWARE_UPGRADE_ABORT As Byte = &H63
Const VB_FIRMWARE_UPGRADE_EXIT As Byte = &H64
Const VB_FIRMWARE_UPGRADE_START As Byte = &H65
Const VB_FIRMWARE_MEM_WRITE As Byte = &H66
Const VB_FIRMWARE_MEM As Byte = &H67
Const VB_FIRMWARE_MEM_WRITE_CONFIRM As Byte = &H68
Const VB_FIRMWARE_MEM_READ As Byte = &H69
Const VB_DISABLE_PROGRAM As Byte = &HB1 ' COMMAND_DISABLE_PROGRAM
Const VB_ENABLE_PROGRAM As Byte = &HB2 ' COMMAND_ENABLE_PROGRAM
Const VB_SELECT_PROGRAM As Byte = &HB3 ' COMMAND_SELECT_PROGRAM
Const VB_CLR_LEARN_MODE As Byte = &HB5 ' COMMAND_SET_CLR_LEARN_CODE
Const VB_RF_CODE_STATUS As Byte = &HB6 ' COMMAND_RF_CODE_STATUS
Const VB_DATE As Byte = &HB7 ' COMMAND_DATE_STATUS / COMMAND_SET_REALTIME_DATE 
Const VB_DIMMER_CONTROLLER_STATUS As Byte = &HB8
Const VB_ENERGY_COUNTER As Byte = &HBE
Const VB_ALARM_CLOCK As Byte = &HC3 ' COMMAND_SET_ALARM_CLOCK
Const VB_TEMP_SETTINGS_3 As Byte = &HC6
Const VB_STATISTICS_REQUEST As Byte = &HC7
Const VB_STATISTICS As Byte = &HC8
Const VB_MEM_READ As Byte = &HC9 ' COMMAND_READ_MEMORY_BLOCK
Const VB_MEM_WRITE As Byte = &HCA ' COMMAND_WRITE_MEMORY_BLOCK
Const VB_MEM_DUMP As Byte = &HCB ' COMMAND_MEMORY_DUMP_REQUEST
Const VB_MEM_BLOCK As Byte = &HCC ' COMMAND_MEMORY_DATA_BLOCK
Const VB_LCD_1 As Byte = &HCD
Const VB_LCD_2 As Byte = &HCE
Const VB_LCD_3 As Byte = &HCF
Const VB_LCD_REQUEST As Byte = &HD0
Const VB_TIMER_ENABLE As Byte = &HD1
Const VB_BACKLIGHT_RESET As Byte = &HD2
Const VB_BACKLIGHT_BUTTON_RESET As Byte = &HD3
Const VB_BACKLIGHT_BUTTON_SET As Byte = &HD4
Const VB_BACKLIGHT_STATUS As Byte = &HD5
Const VB_BACKLIGHT As Byte = &HD6
Const VB_CLOCK_REQUEST As Byte = &HD7 ' COMMAND_REALTIME_CLOCK_STATUS_REQUEST
Const VB_CLOCK As Byte = &HD8 ' COMMAND_REALTIME_CLOCK_STATUS
Const VB_ERROR_COUNT_REQUEST As Byte = &HD9 ' COMMAND_BUS_ERROR_COUNTER_STATUS_REQUEST
Const VB_ERROR_COUNT As Byte = &HDA ' COMMAND_BUSERROR_COUNTER_STATUS
Const VB_TEMP_COMFORT As Byte = &HDB
Const VB_TEMP_DAY As Byte = &HDC
Const VB_TEMP_NIGHT As Byte = &HDD
Const VB_TEMP_SAFE As Byte = &HDE
Const VB_TEMP_COOLING As Byte = &HDF
Const VB_TEMP_HEATING As Byte = &HE0
Const VB_TEMP_LOCK As Byte = &HE1
Const VB_TEMP_UNLOCK As Byte = &HE2
Const VB_TIMER_SLEEP As Byte = &HE3
Const VB_TEMP_SET As Byte = &HE4
Const VB_TEMP_REQUEST As Byte = &HE5
Const VB_TEMP As Byte = &HE6
Const VB_TEMP_SETTINGS_REQUEST As Byte = &HE7
Const VB_TEMP_SETTINGS_1 As Byte = &HE8
Const VB_TEMP_SETTINGS_2 As Byte = &HE9
Const VB_TEMP_STATUS As Byte = &HEA
Const VB_IR_STATUS As Byte = &HEB
Const VB_BLIND_STATUS As Byte = &HEC
Const VB_INPUT_STATUS As Byte = &HED
Const VB_DIMMER_STATUS As Byte = &HEE
Const VB_MODULE_NAME_REQUEST As Byte = &HEF ' COMMAND_CHANNEL_NAME_REQUEST / COMMAND_DIMMER_NAME_REQUEST
Const VB_MODULE_NAME_1 As Byte = &HF0 ' COMMAND_CHANNEL_NAME_PART1 
Const VB_MODULE_NAME_2 As Byte = &HF1 ' COMMAND_CHANNEL_NAME_PART2
Const VB_MODULE_NAME_3 As Byte = &HF3 ' COMMAND_CHANNEL_NAME_PART3
Const VB_BLACKLIGHT_SET As Byte = &HF3
Const VB_LED_STATUS As Byte = &HF4 ' COMMAND_UPDATE_LED_STATUS
Const VB_LED_CLEAR As Byte = &HF5 ' COMMAND_CLEAR_LED
Const VB_LED_SET As Byte = &HF6 ' COMMAND_SET_LED
Const VB_LED_BLINK_SLOW As Byte = &HF7 ' COMMAND_SLOW_BLINKING_LED
Const VB_LED_BLINK_FAST As Byte = &HF8 ' COMMAND_FAST_BLINK_LED
Const VB_LED_BLINK_VERY_FAST As Byte = &HF9 ' COMMAND_VERY_FAST_BLINK_LED
Const VB_MODULE_STATUS As Byte = &HFA ' COMMAND_MODULE_STATUS_REQUEST / COMMAND_DIMMER_STATUS_REQUEST
Const VB_RELAY_STATUS As Byte = &HFB
Const VB_EEPROM_WRITE As Byte = &HFC ' COMMAND_WRITE_DATA_TO_MEMORY
Const VB_EEPROM_READ As Byte = &HFD ' COMMAND_READ_DATA_FROM_MEMORY
Const VB_EEPROM_STATUS As Byte = &HFE ' COMMAND_MEMORY_DATA
Const VB_MODULE_TYPE As Byte = &HFF

' Velbus package details
Private $bMsgPrev As Byte
Private $aMsgData As New Byte[]

Private bMsgRelayStart As Boolean = False
Private iMsgRelayPart As Integer
Private bMsgRelaySize As Byte
Private bMsgRelayData As New Byte[0]

' Array to store addresses of unsupported Velbus modules
Private VB_Modules_Unsupported As New Byte[0]

Const bExtraDebug As Boolean = False

'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
' Mandatory subroutine for each Module/Class to initialize:
' - The cPlugin[x].Settings are copied into local variables
' - Port/Connection will be started (any errors caught)
' - Any other code per Class
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Public Sub StartPlugin(cPl As CPluginEntry)

  Dim sStr As String

  KeyName = cPl.KeyName
  Instance = cPl.Instance
  If Instance <> 1 Then LogLabel = Replace(LogLabel, "] ", "#" & Instance & "] ")

  ' Copy configuration items locally
  $bEnabled = cPl.Settings["enabled"]
  $sInterface = cPl.Settings["type"]
  $sSerPort = cPl.Settings["serialport"]
  $sBaud = cPl.Settings["baudrate"]
  $sTCPHost = cPl.Settings["tcphost"]
  $iTCPPort = cPl.Settings["tcpport"]
  $bRelayEnabled = cPl.Settings["relayenabled"]
  $iRelayPort = cPl.Settings["relayport"]
  $bDebug = cPl.Settings["debug"]

  If $bDebug Then
    WriteDebugLog("*** Start Plugin: " & PluginFriendlyName & " ***")
    WriteDebugLog("  Plugin Version: " & PluginVersion)
  Endif

  If $bDebug Then
    For Each sStr In cPl.Settings
      WriteDebugLog("  [Settings] " & cPl.Settings.Key & ": " & sStr)
    Next
  Endif

  InterfaceId = Devices.FindInterface("Velbus Interface")
  If InterfaceId = 0 Then
    ErrorText = "Required InterfaceId can't be retrieved from the database!"
    Main.WriteLog(LogLabel & "ERROR: " & ErrorText)
    IsRunning = False
    Return
  Endif

  ' Connect/Initialize connection
  If InStr($sInterface, "tcp") Then
    ConnectTCP()
  Else
    ConnectSerial()
  Endif

  ' Start Velbus Relaying
  If $bRelayEnabled Then
    If StartRelay() Then
      Main.WriteLog(LogLabel & "Relay listening for client on port " & $iRelayPort)
    Else
      Main.WriteLog(LogLabel & "ERROR: Relay FAILED to listen on port " & $iRelayPort)
    Endif
  Else
    Main.WriteLog(LogLabel & "Relay disabled.")
  Endif

End

'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
' Mandatory sub for each Module/Class to stop
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Public Sub StopPlugin()

  Try Disconnect()

End

'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
' Easy helper for WriteLog
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Private Sub WriteLog(sLog As String)

  Main.WriteDebugLog(LogLabel & sLog)

End

'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
' Easy helper for WriteDebugLog
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Private Sub WriteDebugLog(sLog As String)

  If $bDebug Then Main.WriteDebugLog(LogLabel & sLog)

End

'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
' Connect to the host:port
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Public Sub ConnectTCP() As Boolean

  Dim iReconnectRetry As Integer = 0

  ' try to close the connection
  Try hMySocket.Close
  Try iReconnectRetry = hMySocket.ReconnectRetry

  ' get a new one - but also pass on our previous reconnect counter
  hMySocket = New CSocket(iReconnectRetry) As "MySocket"

  hMySocket.DataType = gb.Byte & &HFF ' Byte[]
  hMySocket.Connect($sTCPHost, $iTCPPort)

  ' Write to main logfile we are trying to connect
  Main.WriteLog(LogLabel & PluginFriendlyName & " TCP interface connecting to " & $sTCPHost & ":" & $iTCPPort)

  ' Don't set IsRunning=True, this has to be done in _Ready
  IsRunning = False

  ' All went ok
  Return True

Catch ' some errors
  Main.WriteLog(LogLabel & "ERROR: " & PluginFriendlyName & " TCP interface FAILED to connect to " & $sTCPHost & ":" & $iTCPPort)
  Main.WriteLog(LogLabel & "ERROR: " & Error.Text)
  IsRunning = False
  ErrorText = Error.Text
  ErrorWhere = Error.Where

  Return False

End

'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
' connect to the serial port
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Public Sub ConnectSerial() As Boolean

  Dim iReconnectRetry As Integer = 0

  ' try to close the port
  Try hMySerial.Close
  Try iReconnectRetry = hMySerial.ReconnectRetry

  ' get a new one - but store the retry counter between new instances
  hMySerial = New CSerialPort(iReconnectRetry) As "MySerial"

  With hMySerial
    .DataType = &HFF + gb.Byte ' Byte[]
    .PortName = $sSerPort
    .Speed = $sBaud
    .Parity = 0
    .DataBits = 8
    .StopBits = 1
    .FlowControl = 0
    .Open()
    .RTS = 1
    .DTR = 0
  End With

  ' write to main logfile we connected successfully
  Main.WriteLog(LogLabel & PluginFriendlyName & " serial interface connected to port " & $sSerPort)
  IsRunning = True

  ' request current status of all connected velbus modules
  Run()

  ' all went ok
  Return True

Catch ' some errors
  Main.WriteLog(LogLabel & "ERROR: " & PluginFriendlyName & " serial interface FAILED to connect to port " & $sSerPort)
  Main.WriteLog(LogLabel & "ERROR: " & Error.Text)
  IsRunning = False
  ErrorText = Error.Text
  ErrorWhere = Error.Where

  Return False

End


'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
' disconnect from the tcp host or serialport
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Public Sub Disconnect() As Boolean

  ' try to close the connection
  Try hMySocket.Close
  Try hMySerial.Close

  ' try stop running timers
  Try tVelbusBusy.Stop
  Try tVelbusScan.Stop

  Try hVelbusRelay.Close

  If InStr($sInterface, "tcp") Then
    Main.WriteLog(LogLabel & PluginFriendlyName & " TCP connection closed.")
  Else
    Main.WriteLog(LogLabel & PluginFriendlyName & " Port closed.")
  Endif

  ' all ok
  Return True

Catch ' some errors
  IsRunning = False
  ErrorText = ""
  ErrorWhere = ""

End

'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
' Run after succesfull connect
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Private Sub Run()

  Dim aData As New Byte[]

  ' define timer for Interface busy
  tVelbusBusy = New Timer As "tVelbusBusy"
  tVelbusBusy.Stop

  ' define timer for scan requests
  tVelbusScan = New Timer As "tVelbusScan"
  tVelbusScan.Stop

  ' request current status of all connected velbus modules
  GetCurrentModuleStatus()

  ' Request date/time from modules
  aData.Add(VB_CLOCK_REQUEST)
  QueueCommand(CreateVelbusPackage(VB_LPRIO, &H00, aData.Count, aData, False))

End

'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
' Socket closed by remote
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Public Sub MySocket_Closed()

  Main.WriteLog(LogLabel & "ERROR: TCP socket closed by peer.")

End

'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
' host ip address found
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Public Sub MySocket_Found()

  Log.Plugin_DNS_Found(LogLabel, $sTCPHost)

End

'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
' error while connected/connecting to tcp host
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Public Sub MySocket_Error(sMsg As String)

  Main.WriteLog(LogLabel & "ERROR: " & sMsg)

  IsRunning = False
  ErrorText = sMsg

End

'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
' received data from the tcp port
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Public Sub MySocket_Read(vVar As Variant)

  Dim bData As Byte

  If vVar Then
    For Each bData In vVar
      ProcessReceivedChar(bData)
    Next
  Endif

End

'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
' tcp socket is connected
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Public Sub MySocket_Ready()

  Main.WriteLog(LogLabel & "TCP interface connected.")
  IsRunning = True

  Run()

End

'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
' Called when we should reconnect to the tcp host
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Public Sub MySocket_Reconnect()

  ConnectTCP()

End

'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
' Handle errors
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Public Sub MySerial_Error(sMsg As String)

  Main.WriteDebugLog(LogLabel & "ERROR: " & sMsg)

End

'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
' got data from serialport
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Public Sub MySerial_Read(vVar As Variant)

  Dim bData As Byte

  If vVar Then
    For Each bData In vVar
      ProcessReceivedChar(bData)
    Next
  Endif

End

'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
' Handle reconnect(s)
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Public Sub MySerial_Reconnect()

  ' ReConnect/Initialize connection
  ConnectSerial()

End

'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
' Start relay port
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Public Function StartRelay() As Boolean

  hVelbusRelay = New ServerSocket As "VelbusRelay"
  hVelbusRelay.Type = Net.Internet
  hVelbusRelay.Port = $iRelayPort
  ' we start listening for max 1 connection
  hVelbusRelay.Listen(1)

  If hVelbusRelay.Status = Net.Active Then
    hRelayVelbusClient = New Object[]
    ' all ok
    Return True
  Else
    Return False
  End If

End

'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
' Start relay port
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Public Sub VelbusRelay_Connection(sHost As String)

  hRelayVBSocket = New Socket As "RelayVBSocket"
  ' accept client
  If hVelbusRelay.Status <= Net.Inactive Then Return
  If $bDebug Then Main.WriteDebugLog(LogLabel & "Relay connection request from client " & sHost)

  hRelayVBSocket = hVelbusRelay.Accept()
  hRelayVelbusClient.Add(hRelayVBSocket)
  If $bDebug Then
    If hRelayVBSocket.Status = Net.Connected Then Main.WriteLog(LogLabel & "Relay client connection from ip address " & hRelayVBSocket.RemoteHost & " (" & DNS.ResolveHost(hRelayVBSocket.RemoteHost) & ") accepted.")
  Endif

End

'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
' TCP relay socket error while client is connected/connecting
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Public Sub VelbusRelay_Error()

  ' handle errors
  Select hVelbusRelay.Status
    Case Net.CannotCreateSocket
      Main.WriteDebugLog(LogLabel & "Relay The system does not allow to create a socket.")
    Case Net.CannotBindSocket
      Main.WriteDebugLog(LogLabel & "Relay Cannot bind socket.")
    Case Net.CannotListen
      Main.WriteDebugLog(LogLabel & "Relay Cannot listen on port.")
  End Select

End

'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
' Close relay socket
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Public Sub VelbusRelay_Closed()

  Main.WriteLog(LogLabel & ("Velbus TCP relay socket closed."))

End

'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
' Receive data from TCP relay socket
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Public Sub Socket_Read()

  Dim bData, bDataPart As Byte
  Dim sData As String
  Dim bTempData As New Byte[]

  If Last.Status <> Net.Connected Then Return

  Do While Lof(Last) > 0
    Try Read #Last, sData, 1
    If Error Then
      Main.WriteDebugLog(LogLabel & "Error reading data from relay client! -> " & Error.Text)
      Return
    Endif

    bData = CByte(Asc(sData))

    If (bData = VB_STX) And (bMsgRelayStart = False) Then
      bMsgRelayStart = True
      iMsgRelayPart = 0
      bMsgRelayData.Clear
    Endif
    If bMsgRelayStart Then
      bMsgRelayData.Add(bData)
      Inc iMsgRelayPart 
      If iMsgRelayPart = 4 Then
        If (bData = &H40) Then
          'Scan (Module Type) packet
          bMsgRelaySize = &H00
        Else
          bMsgRelaySize = bData
        Endif
      Endif
      If (iMsgRelayPart = (6 + CInt(bMsgRelaySize))) Then
        bMsgRelayStart = False
        If $bDebug Then Main.WriteDebugLog(LogLabel & "< " & Util.ByteToHex(bDataPart))

        'create new array object to prevent the cQueue collection pointing to same reference for all items
        bTempData.Clear
        For Each bDataPart In bMsgRelayData
          bTempData.Add(bDataPart)
        Next 
        QueueCommand(bTempData)
        Return
      Endif
    Endif
  Loop
  
End

'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
'
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Public Sub Socket_Closed()

  Main.WriteLog(LogLabel & "Relay client connection closed.")
  hRelayVelbusClient.Remove(hRelayVelbusClient.Find(Last))

End

'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
' Get current status of all known Velbus modules
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Private Sub GetCurrentModuleStatus()

  Dim rResult As Result
  Dim bInList As Boolean
  Dim sGetStatusModules As New String[]
  Dim sModuleAddress As String

  Try rResult = Devices.FindDevicesForInterface(InterfaceId, Instance)
  If Not IsNull(rResult) Then
    If rResult.Count Then
      For Each rResult
        'check if scan is not already sent
        bInList = False
        If Not IsNull(sGetStatusModules) Then
          For Each sModuleAddress In sGetStatusModules
            If sModuleAddress = Left(rResult!address, Len(sModuleAddress)) Then
              bInList = True
              Break
            Endif
          Next
        End If
        If Not bInList Then
          sModuleAddress = IIf(InStr(rResult!address, "|") > 0, UCase(Left(rResult!address, (InStr(rResult!address, "|") - 1))), rResult!address)
          sGetStatusModules.Add(sModuleAddress)
          SendCommand(sModuleAddress, "STATUS", rResult!id)
        Endif
      Next
    Endif
  Endif

Catch
  WriteDebugLog("ERROR: Get current state of modules: " & ErrorText & " at " & ErrorWhere)

End

'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
' Add command to queue
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Private Sub QueueCommand(bPacket As Byte[])

  ' add command to queue
  cQueue.Add(bPacket, Rnd)

  ' if bus is Not busy process it
  If bBusBusy = False Then DoQueue()

End

'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
' Process next item in queue
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Private Sub DoQueue()

  Dim bPacket As Byte[]

  For Each bPacket In cQueue
    WriteCommand(bPacket, cQueue.Key)
    Break ' only do first one
  Next

End

'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
' Sent data to velbus
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Private Sub WriteCommand(sData As Byte[], sKey As String)

  If $bDebug Then Main.WriteDebugLog(LogLabel & "> " & Util.ByteToHex(sData))

  ' Write the complete string - not byte-for-byte
  If InStr($sInterface, "tcp") Then
    hMySocket.Write(sData)
  Else
    hMySerial.Write(sData)
  Endif

  ' remove sent command from queue
  cQueue.Remove(sKey)

  ' start timer to wait before sending next command
  tVelbusBusy.Delay = 60 ' 60mS based on: http://forum.velleman.eu/viewtopic.php?f=26&t=8795#p33958
  bBusBusy = True
  tVelbusBusy.Start

End

'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
' Velbus busy reset
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Public Sub tVelbusBusy_Timer()

  tVelbusBusy.Stop

  If cQueue.Count Then ' if there are more commands left in queue, send next one
    If $bDebug Then Main.WriteDebugLog(LogLabel & "Sending command from Queue (count = " & cQueue.Count & ")")
    DoQueue()
  Else
    bBusBusy = False
  Endif

End

'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
' Assemble valid data package to be sent onto velbus
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Private Function CreateVelbusPackage(bPriority As Byte, bAddress As Byte, bDataSize As Byte, bData As Byte[], Optional bScan As Byte) As Byte[]

  Dim bPacket As New Byte[]
  Dim icnt As Integer
  Dim bCHK As Byte

  'STX
  bPacket.Add(VB_STX)

  'Priority
  bPacket.Add(bPriority)

  'Address
  bPacket.Add(bAddress)

  'RTR & Data Size
  bPacket.Add(IIf(bScan, &H40, bDataSize))

  'Data bytes
  If Not bScan Then
    For icnt = 0 To CInt(bDataSize) - 1
      bPacket.Add(bData[icnt])
    Next
  End If

  'Calc checksum
  bCHK = CalculateCRC(bPacket)
  bPacket.Add(bCHK)

  'ETX
  bPacket.Add(VB_ETX)

  Return bPacket

End

'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
' Catch data received from velbus
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Private Sub ProcessReceivedChar(bTemp As Byte)

  Dim iSize As Integer

  'Example data packet
  ' +---------------------------- STX,  Start of packet
  ' |  +------------------------- PRIO, Priority, High=F8 / Low=FB
  ' |  |  +---------------------- ADDR, Address (0 - 255)
  ' |  |  |  +------------------- RTR,  Scan request (=4h)
  ' |  |  |  |+------------------ SIZE, # data bytes
  ' |  |  |  || +---------------- DATA, Data 1 (Command byte)
  ' |  |  |  || |  +------------- DATA, Data 2
  ' |  |  |  || |  |  +---------- DATA, Data 3
  ' |  |  |  || |  |  |  +------- DATA, Data 4
  ' |  |  |  || |  |  |  |  +---- CHK,  Checksum
  ' |  |  |  || |  |  |  |  |  +- ETX,  End of packet
  ' |  |  |  || |  |  |  |  |  |
  ' 0F F8 00 04 01 02 03 04 XX 04

  Main.ControlLed("Velbus", "On")

  ' Relay incoming databyte to relay port
  If $bRelayEnabled Then
    If hRelayVBSocket.Status = Net.Connected Then Try Write #hRelayVBSocket, bTemp As Byte
  Endif

  If $aMsgData.Count >= 1 Then

    $aMsgData.Add(bTemp)

    Select $aMsgData.Count
      Case 1 ' Do nothing
      Case 2 ' Priority
        If $aMsgData[1] <> VB_LPRIO And If $aMsgData[1] <> VB_HPRIO Then
          ' Invalid priority
          WriteDebugLog("< " & Util.ByteToHex($aMsgData) & " (INVALID PRIORITY)")
          $aMsgData.Clear()
          $bMsgPrev = bTemp
          Return
        Endif
      Case 3 ' Address
      Case 4 ' RTR / Size
      Default ' check for length / checksum / EOL

        iSize = ($aMsgData[3] And &H0F)
        If iSize > 8 Then
          WriteDebugLog("< " & Util.ByteToHex($aMsgData) & " (INVALID SIZE: RECEIVED '" & iSize & "', MAX IS '8')")
          $aMsgData.Clear()
          $bMsgPrev = bTemp
        Endif

        ' Check if we didn't receive too much data
        If $aMsgData.Count > (iSize + 6) Then
          WriteDebugLog("< " & Util.ByteToHex($aMsgData) & " (INVALID PACKET: NO EOL FOUND)")
          $aMsgData.Clear()
          $bMsgPrev = bTemp
          Return
          Return
        Endif

        ' Check if we received exact amount of bytes
        If $aMsgData.Count = (iSize + 6) Then
          ' Current byte needs to be VB_ETX
          If bTemp = VB_ETX Then
            ' Do checksum - includes VB_STX until CRC byte
            If CalculateCRC($aMsgData.Copy(0, $aMsgData.Count - 2)) = $aMsgData[$aMsgData.Count - 2] Then
              ' Parse data - if it is NOT a scan packet only

              If $bDebug Then
                WriteDebugLog("< " & Util.ByteToHex($aMsgData))
                WriteDebugLog("  Priority: " & IIf($aMsgData[1] = VB_HPRIO, "HIGH", "LOW"))
                WriteDebugLog("  Address: " & $aMsgData[2])
                WriteDebugLog("  RTR: " & IIf(($aMsgData[3] And &HF40) = &HF40, "ON", "OFF"))
                WriteDebugLog("  Data Length: " & iSize)
              Endif

              If iSize > 0 Then
                ProcessReceivedPacket($aMsgData[2], $aMsgData.Copy(4, iSize)) 
              Endif
            Else
              WriteDebugLog("< " & Util.ByteToHex($aMsgData) & " (INVALID CRC: EXPECTED '" & Hex(CalculateCRC($aMsgData.Copy(0, $aMsgData.Count - 2)), 2) & "', RECEIVED '" & Hex($aMsgData[$aMsgData.Count - 2], 2) & "')")
            Endif

            $aMsgData.Clear()
            $bMsgPrev = bTemp
          Else
            WriteDebugLog("< " & Util.ByteToHex($aMsgData) & " (INVALID PACKET: NO EOL FOUND)")
            $aMsgData.Clear()
            $bMsgPrev = bTemp
            Return
          Endif
        Endif

    End Select

  Else
    If bTemp = VB_STX Then
      $aMsgData.Add(bTemp)
    Else
      $aMsgData.Add(bTemp)
      WriteDebugLog("< " & Util.ByteToHex($aMsgData) & " (INVALID START PACKET)")
      If $bDebug Then WriteDebugLog("ERROR: Invalid data")
      $aMsgData.Clear()
      $bMsgPrev = bTemp
      Return
    Endif 
  Endif

  $bMsgPrev = bTemp

  Main.ControlLed("Velbus", "Off")

End

'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
' Calculate package checksum
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Private Sub CalculateCRC(bPacket As Byte[]) As Byte

  Dim icnt As Integer
  Dim iChcksum As Integer = 0
  Dim bCHK As Byte

  For icnt = 0 To bPacket.length - 1
    iChcksum = iChcksum + CInt(bPacket[icnt])
  Next
  While iChcksum > 256
    iChcksum = iChcksum - 256
  Wend
  bCHK = CByte(iChcksum)

  For icnt = 0 To 7
    bCHK = BChg(bCHK, icnt)
  Next
  bCHK = bCHK + 1
  Return bCHK

End

'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
' Decode received data packet from velbus
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Private Sub ProcessReceivedPacket(bAddress As Byte, bData As Byte[])

  Dim bModuleType, bScanAddress As Byte
  Dim sModuleType As String
  Dim bSupported, bIgnoreModule As Boolean

  ' Temp only
  If $bDebug Then
    WriteDebugLog("  ### Address: " & bAddress)
    WriteDebugLog("  ### Data: " & Util.ByteToHex(bData))
  Endif

  If $bDebug Then WriteDebugLog("  Command: " & DisplayCommandType(bData[0]))

  ' velbus module type detection during scan
  If bData[0] = VB_MODULE_TYPE Then
    bModuleType = bData[1]
  Else
    ' Retrieve the moduletype from the DB, or do a scan for it
    ' &HFF = Scan, &H00 = Ignore
    bModuleType = GetModuleType(bAddress)
  Endif

  bSupported = False
  sModuleType = DisplayModuleType(bModuleType)

  ' Report module type, if we have an idea
  If bModuleType <> &H00 And If bModuleType <> &HFF Then
    If $bDebug Then WriteDebugLog("  ModuleType: " & sModuleType)
  Else
    If $bDebug Then WriteDebugLog("  ModuleType: UNKNOWN")
  Endif

  Select bModuleType
    Case VMB8PB
      bSupported = True
      VMB8PB_Receive(bAddress, bData)
    Case VMB4RY
      bSupported = True
      VMB4RY_Receive(bAddress, bData)
    Case VMB4RYLD
      bSupported = True
      VMB4RYLD_Receive(bAddress, bData)
    Case VMB4RYNO
      bSupported = True
      VMB4RYNO_Receive(bAddress, bData)
    Case VMB4DC
      bSupported = True
      VMB4DC_Receive(bAddress, bData)
    Case VMBDME
      bSupported = True
      VMBDME_Receive(bAddress, bData)
    Case VMB2BLE
      bSupported = True
      VMB2BLE_Receive(bAddress, bData)
    Case VMBGPO
      bSupported = True
      VMBGPO_Receive(bAddress, bData)
    Case VMB7IN
      bSupported = True
      VMB7IN_Receive(bAddress, bData)
    Case VMBDMI
      bSupported = True
      VMBDMI_Receive(bAddress, bData)
    Case VMBPIRC
      bSupported = True
      VMBPIRC_Receive(bAddress, bData)
    Case &H99 ' Unknown module type, do nothing as scan request is scheduled to be sent
      bSupported = True
    Case Else
      sModuleType = "<unknown type> (" & Hex(bModuleType) & ")"
      bSupported = False
  End Select

  If Not bSupported Then

    If bModuleType = VMUNKNOWN Then
      WriteDebugLog("  Packet received from module with address " & bAddress & ", device isn't discovered or configured yet")
    Else
      WriteDebugLog("  Packet received from module " & sModuleType & " with address " & bAddress & " which is not (yet) supported by DomotiGa code")
    Endif

    bIgnoreModule = False
    For Each bScanAddress In VB_Modules_Unsupported
      If bScanAddress = bAddress Then
        bIgnoreModule = True
        Break
      Endif
    Next

    If Not bIgnoreModule Then
      VB_Modules_Unsupported.Add(bAddress)
      If $bDebug Then Main.WriteDebugLog(LogLabel & "Ignoring future messages of unsupported module " & sModuleType & " with address " & Hex(bAddress))
    Endif

  Endif

Catch
  WriteLog("ERROR: Failed to decode packet '" & Error.Text & "' at '" & Error.Where & "'")

End

'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
' Convert hex formatted string to byte
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Private Function HexStringToByte(sValue As String) As Byte

  Dim iValue As Integer = 0
  Dim icnt As Integer

  If Len(sValue) = 4 Then sValue = Right(sValue, 2)

  For icnt = 1 To 2
    Select UCase(Mid(sValue, icnt, 1))
      Case "1"
        iValue += 1
      Case "2"
        iValue += 2
      Case "3"
        iValue += 3
      Case "4"
        iValue += 4
      Case "5"
        iValue += 5
      Case "6"
        iValue += 6
      Case "7"
        iValue += 7
      Case "8"
        iValue += 8
      Case "9"
        ivalue += 9
      Case "A"
        ivalue += 10
      Case "B"
        ivalue += 11
      Case "C"
        ivalue += 12
      Case "D"
        ivalue += 13
      Case "E"
        ivalue += 14
      Case "F"
        ivalue += 15
    End Select
    If icnt = 1 Then ivalue = ivalue * 16
  Next
  Return CByte(ivalue)

End

'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
' Return velbus module type based on known module addresses
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Private Function GetModuleType(Address As Byte, Optional DeviceId As Integer) As Byte

  Dim iDeviceId As Integer
  Dim bIgnoreModule As Boolean
  Dim rResult As Result
  Dim bScanAddress As Byte
  Dim sDeviceType As String

  If DeviceId Then
    iDeviceId = DeviceId
  Else
    Try rResult = Devices.FindDevicesForInterface(InterfaceId, Instance)
    If Not IsNull(rResult) Then
      If rResult.Count Then
        For Each rResult
          If InStr(rResult!address, "|") > 0 Then
            If HexStringToByte(UCase(Left(rResult!address, (InStr(rResult!address, "|") - 1)))) = Address Then
              iDeviceId = rResult!id
              Break
            Endif
          Else
            If UCase(rResult!address) = Hex(Address, 2) Then
              iDeviceId = rResult!id
              Break
            Endif
          Endif
        Next
      Endif
    Endif
  Endif

  If iDeviceId Then
    sDeviceType = UCase(Devices.FindDeviceTypeNameForDeviceId(iDeviceId))
    Select sDeviceType 
      Case "VMB4RY"
        Return VMB4RY
      Case "VMB4RYNO"
        Return VMB4RYNO
      Case "VMB4DC"
        Return VMB4DC
      Case "VMB7IN"
        Return VMB7IN
      Case "VMBGPO"
        Return VMBGPO
      Case "VMBDME"
        Return VMBDME
      Case "VMB4RYLD"
        Return VMB4RYLD
      Case "VMB2BLE"
        Return VMB2BLE
      Case "VMB8PB"
        Return VMB8PB
      Case Else
        Main.WriteDebugLog(LogLabel & "Unsupported velbus module '" & UCase(Devices.FindDeviceTypeNameForDeviceId(iDeviceId)) & "'")
        Return &H00
    End Select
  Else
    If $bDebug Then Main.WriteDebugLog(LogLabel & "Unknown moduletype with address " & Hex(Address))
    bIgnoreModule = False
    'To prevent scan broadcaststorms ignore scheduled scan if it's already in queue 
    For Each bScanAddress In cScanQueue
      If bScanAddress = Address Then bIgnoreModule = True
    Next
    'ignore scan request for unsupported modules
    For Each bScanAddress In VB_Modules_Unsupported
      If bScanAddress = Address Then bIgnoreModule = True
    Next
    If Not bIgnoreModule Then
      If $bDebug Then Main.WriteDebugLog(LogLabel & "Send discover (SCAN) request onto velbus to request module type at address " & Hex(Address))
      QueueScanCommand(Address)
      Return &H99
    Else
      Return &H00
    Endif
  Endif

End

'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
' Velbus scan reset
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Public Sub tVelbusScan_Timer()

  tVelbusScan.Stop

  If cScanQueue.Count Then ' if there are more scan commands left in queue, send next one
    If $bDebug Then Main.WriteDebugLog(LogLabel & "Sending scan request from Queue (count = " & cQueue.Count & ")")
    DoScanQueue()
  Endif

End

Private Sub QueueScanCommand(bAddress As Byte)

  ' add scanrequest to queue
  cScanQueue.Add(bAddress, Rnd)
  tVelbusScan.Delay = 10000 'wait 10 sec to send scan request to prevent broadcast storm of scan requests
  tVelbusScan.Start

End

'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
' Process next item in queue
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Private Sub DoScanQueue()

  Dim bAddress As Byte

  For Each bAddress In cScanQueue
     QueueCommand(CreateVelbusPackage(VB_LPrio, bAddress, &H00, Null, True))
    Break ' only do first one. Timer will trigger next command
  Next

  cScanQueue.Remove(cScanQueue.Key)
  If cScanQueue.Count > 0 Then
    tVelbusScan.Delay = 10000 'wait 10 sec to send scan request to prevent broadcast storm of scan requests
    tVelbusScan.Start
  Endif

End

'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
' Control velbus modules
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Public Sub SendCommand(sAddress As String, sCmd As String, Optional DeviceId As Integer)

  Dim bAddress, bModuleType As Byte

  bAddress = HexStringToByte(Left(sAddress, 2))
  If DeviceId Then
    bModuleType = GetModuleType(bAddress, DeviceId)
  Else
    bModuleType = GetModuleType(bAddress)
  Endif

  Select bModuleType
    Case VMB4RY
      If UCase(sCmd) = "STATUS" Then
        VMB4RY_Send(bAddress, 1, sCmd)
        VMB4RY_Send(bAddress, 2, sCmd)
        VMB4RY_Send(bAddress, 3, sCmd)
        VMB4RY_Send(bAddress, 4, sCmd)
      Else
        VMB4RY_Send(bAddress, CInt(Right(sAddress, 1)), sCmd)
      Endif
    Case VMB4RYNO
      If UCase(sCmd) = "STATUS" Then
        VMB4RYNO_Send(bAddress, 1, sCmd)
        VMB4RYNO_Send(bAddress, 2, sCmd)
        VMB4RYNO_Send(bAddress, 3, sCmd)
        VMB4RYNO_Send(bAddress, 4, sCmd)
        VMB4RYNO_Send(bAddress, 5, sCmd)
      Else
        VMB4RYNO_Send(bAddress, CInt(Right(sAddress, 1)), sCmd)
      Endif
    Case VMB4RYLD
      If UCase(sCmd) = "STATUS" Then
        VMB4RYLD_Send(bAddress, 1, sCmd)
        VMB4RYLD_Send(bAddress, 2, sCmd)
        VMB4RYLD_Send(bAddress, 3, sCmd)
        VMB4RYLD_Send(bAddress, 4, sCmd)
        VMB4RYLD_Send(bAddress, 5, sCmd)
      Else
        VMB4RYLD_Send(bAddress, CInt(Right(sAddress, 1)), sCmd)
      Endif
    Case VMB4DC
      If UCase(sCmd) = "STATUS" Then
        VMB4DC_Send(bAddress, 1, sCmd)
        VMB4DC_Send(bAddress, 2, sCmd)
        VMB4DC_Send(bAddress, 3, sCmd)
        VMB4DC_Send(bAddress, 4, sCmd)
      Else
        VMB4DC_Send(bAddress, CInt(Right(sAddress, 1)), sCmd)
      Endif
    Case VMBGPO
      VMBGPO_Send(bAddress, sCmd)
    Case VMBDME
      VMBDME_Send(bAddress, sCmd)
    Case VMB7IN
      VMB7in_Send(bAddress, sCmd)
    Case VMB2BLE
      VMB2BLE_Send(bAddress, sCmd)
    Case VMB8PB
      VMB8PB_Send(bAddress, sCmd)
    Case Else
      If $bDebug Then Main.WriteDebugLog(LogLabel & "Unable to send command to unknown or not (yet) unsupported Velbus module at address " & sAddress)
      Return
  End Select

End

'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
' Support for VMB4RY module
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Private Sub VMB4RY_Receive(bAddress As Byte, aData As Byte[])

  Dim iChannel As Integer
  Dim iDeviceId As Integer
  Dim sRelayStatus As String

  Select aData[0]
    Case VB_STATUS ' Do nothing
    Case VB_MODULE_TYPE
      ' If we got enough info, report build info
      If aData.Count = 8 Then
      WriteDebugLog("  Build: " & Format(aData[6], "00") & Format(aData[7], "00"))
      Endif
    Case VB_SWITCH_OFF
      For iChannel = 1 To 4
        If BTst(aData[1], iChannel - 1) Then
          iDeviceId = Devices.Find(Instance, Hex(bAddress, 2) & "|" & iChannel, InterfaceId, "VMB4RY Channel " & iChannel)
          If $bDebug Then WriteDebugLog("  Relay channel: " & iChannel & " switched off status received")
          Devices.ValueUpdate(iDeviceId, 1, "Off", Devices.ValueType_Switch)
        Endif
      Next
    Case VB_SWITCH_ON
      For iChannel = 1 To 4
        If BTst(aData[1], iChannel - 1) Then
          iDeviceId = Devices.Find(Instance, Hex(bAddress, 2) & "|" & iChannel, InterfaceId, "VMB4RY Channel " & iChannel)
          If $bDebug Then WriteDebugLog("  Relay channel: " & iChannel & " switched on status received")
          Devices.ValueUpdate(iDeviceId, 1, "On", Devices.ValueType_Switch)
        Endif
      Next
    Case VB_LED_BLINK_FAST, VB_LED_BLINK_SLOW, VB_LED_BLINK_VERY_FAST, VB_LED_CLEAR, VB_LED_SET
      For iChannel = 1 To 4
        If BTst(aData[1], iChannel - 1) Then
          iDeviceId = Devices.Find(Instance, Hex(bAddress, 2) & "|" & iChannel, InterfaceId, "VMB4RY Channel " & iChannel)
          Update_LED_Status(iDeviceId, aData[0]) 
        Endif
      Next
    Case VB_RELAY_STATUS
      For iChannel = 1 To 4
        If BTst(aData[1], iChannel - 1) Then
          iDeviceId = Devices.Find(Instance, Hex(bAddress, 2) & "|" & iChannel, InterfaceId, "VMB4RY Channel " & iChannel)
          If $bDebug Then WriteDebugLog("  Relay channel: " & iChannel & " changed")
          sRelayStatus = IIf(BTst(aData[3], iChannel), "On", "Off")
          Devices.ValueUpdate(iDeviceId, 1, sRelayStatus, Devices.ValueType_Switch)

          If BTst(aData[5], 7) Then
            update_LED_Status(iDeviceId, VB_LED_SET)
          Else
            update_LED_Status(iDeviceId, VB_LED_CLEAR)
          Endif
          If BTst(aData[5], 6) Then update_LED_Status(iDeviceId, VB_LED_BLINK_SLOW)
          If BTst(aData[5], 5) Then update_LED_Status(iDeviceId, VB_LED_BLINK_FAST)
          If BTst(aData[5], 4) Then Update_LED_Status(iDeviceId, VB_LED_BLINK_VERY_FAST)
        Endif
      Next
    Case Else
      WriteDebugLog("  *** Unsupported Command ***")
  End Select

End

'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
' Support for VMB4RY module
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Private Sub VMB4RY_Send(ModuleAddress As Byte, iChannel As Integer, sAction As String)

  Dim bTempData As New Byte[]
  Dim bPrio As Byte

  If (iChannel >= 1) And (iChannel <= 4) Then
    Select UCase(sAction)
      Case "ON"
        bTempData.Add(VB_SWITCH_ON)
        bTempData.Add(BSet(&H00, (iChannel - 1)))
        bPrio = VB_HPrio
      Case "OFF"
        bTempData.Add(VB_SWITCH_OFF)
        bTempData.Add(BSet(&H00, (iChannel - 1)))
        bPrio = VB_HPrio
      Case "STATUS"
        bPrio = VB_LPrio
        bTempData.Add(VB_MODULE_STATUS)
        bTempData.Add(BSet(&H00, (iChannel - 1)))
      Case "CHANNEL_NAME"
        bPrio = VB_LPrio
        bTempData.Add(VB_MODULE_NAME_REQUEST)
        bTempData.Add(BSet(&H00, (iChannel - 1)))
      Case Else
        If $bDebug Then Main.WriteDebugLog(LogLabel & "Unsupported action '" & sAction & "' for VMB4RY module!")
    End Select
    QueueCommand(CreateVelbusPackage(bPrio, ModuleAddress, bTempData.Count, bTempData, False))
  Endif

End

'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
' Support for VMB4RYNO module
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Private Sub VMB4RYNO_Receive(bAddress As Byte, aData As Byte[])

  Dim iChannel As Integer
  Dim iDeviceId As Integer
  Dim sRelayStatus As String

  Select aData[0]
    Case VB_STATUS ' Do nothing
    Case VB_MODULE_TYPE
      If $bDebug Then
        WriteDebugLog("  SerialNumber: " & CInt(aData[2]) * 256 + aData[3])
        WriteDebugLog("  MemoryMap: " & aData[4])
        WriteDebugLog("  Build: " & Format(aData[5], "00") & Format(aData[6], "00"))
      Endif
    Case VB_SWITCH_OFF
      For iChannel = 1 To 5
        If BTst(aData[1], iChannel - 1) Then
          iDeviceId = Devices.Find(Instance, Hex(bAddress, 2) & "|" & iChannel, InterfaceId, "VMB4RYNO Channel " & iChannel)
          If $bDebug Then WriteDebugLog("  Relay channel: " & iChannel & " switched off status received")
          Devices.ValueUpdate(iDeviceId, 1, "Off", Devices.ValueType_Switch)
        Endif
      Next
    Case VB_SWITCH_ON
      For iChannel = 1 To 5
        If BTst(aData[1], iChannel - 1) Then
          iDeviceId = Devices.Find(Instance, Hex(bAddress, 2) & "|" & iChannel, InterfaceId, "VMB4RYNO Channel " & iChannel)
          If $bDebug Then WriteDebugLog("  Relay channel: " & iChannel & " switched on status received")
          Devices.ValueUpdate(iDeviceId, 1, "On", Devices.ValueType_Switch)
        Endif
      Next
    Case VB_LED_BLINK_FAST, VB_LED_BLINK_SLOW, VB_LED_BLINK_VERY_FAST, VB_LED_CLEAR, VB_LED_SET
      For iChannel = 1 To 5
        If BTst(aData[1], iChannel - 1) Then
          iDeviceId = Devices.Find(Instance, Hex(bAddress, 2) & "|" & iChannel, InterfaceId, "VMB4RYNO Channel " & iChannel)
          If $bDebug Then WriteDebugLog("  Relay channel: " & iChannel & " LED status received")
          Update_LED_Status(iDeviceId, aData[0]) 
        Endif
      Next
    Case VB_RELAY_STATUS
      For iChannel = 1 To 5
        If BTst(aData[1], iChannel - 1) Then
          iDeviceId = Devices.Find(Instance, Hex(bAddress, 2) & "|" & iChannel, InterfaceId, "VMB4RYNO Channel " & iChannel)
          sRelayStatus = IIf(BTst(aData[3], 0), "On", "Off")
          If $bDebug Then WriteDebugLog("  Relay channel: " & iChannel & ", switched " & sRelayStatus)
          Devices.ValueUpdate(iDeviceId, 1, sRelayStatus, Devices.ValueType_Switch)
          If BTst(aData[4], 7) Then
            update_LED_Status(iDeviceId, VB_LED_SET)
          Else
            update_LED_Status(iDeviceId, VB_LED_CLEAR)
          Endif
          If BTst(aData[4], 6) Then update_LED_Status(iDeviceId, VB_LED_BLINK_SLOW)
          If BTst(aData[4], 5) Then update_LED_Status(iDeviceId, VB_LED_BLINK_FAST)
          If BTst(aData[4], 4) Then Update_LED_Status(iDeviceId, VB_LED_BLINK_VERY_FAST)
        Endif
      Next
    Case Else
      WriteDebugLog("  *** Unsupported Command ***")
  End Select
End

'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
' Support for VMB4RYNO module
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Private Sub VMB4RYNO_Send(ModuleAddress As Byte, iChannel As Integer, sAction As String)

  Dim bTempData As New Byte[]
  Dim bPrio As Byte

  If (iChannel >= 1) And (iChannel <= 5) Then
    Select UCase(sAction)
      Case "ON"
        bTempData.Add(VB_SWITCH_ON)
        bTempData.Add(BSet(&H00, (iChannel - 1)))
        bPrio = VB_HPrio
      Case "OFF"
        bTempData.Add(VB_SWITCH_OFF)
        bTempData.Add(BSet(&H00, (iChannel - 1)))
        bPrio = VB_HPrio
      Case "STATUS"
        bTempData.Add(VB_MODULE_STATUS)
        bTempData.Add(BSet(&H00, (iChannel - 1)))
        bPrio = VB_LPrio
      Case Else
        If $bDebug Then Main.WriteDebugLog(LogLabel & "Unsupported action '" & sAction & "' for VMB4RYNO module!")
    End Select
    QueueCommand(CreateVelbusPackage(bPrio, ModuleAddress, bTempData.Count, bTempData, False))
  Endif

End

'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
' Support for VMB4RYLD module
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Private Sub VMB4RYLD_Receive(bAddress As Byte, aData As Byte[])

  Dim iChannel As Integer
  Dim iDeviceId As Integer
  Dim sRelayStatus As String

  Select aData[0]
    Case VB_STATUS ' Do nothing
    Case VB_MODULE_TYPE
      If $bDebug Then
        WriteDebugLog("  SerialNumber: " & CInt(aData[2]) * 256 + aData[3])
        WriteDebugLog("  MemoryMap: " & aData[4])
        WriteDebugLog("  Build: " & Format(aData[5], "00") & Format(aData[6], "00"))
      Endif
    Case VB_SWITCH_OFF
      For iChannel = 1 To 5
        If BTst(aData[1], iChannel - 1) Then
          iDeviceId = Devices.Find(Instance, Hex(bAddress, 2) & "|" & iChannel, InterfaceId, "VMB4RYLD Channel " & iChannel)
          If $bDebug Then Main.WriteDebugLog(LogLabel & "  Relay channel: " & iChannel & " switched off status received")
          Devices.ValueUpdate(iDeviceId, 1, "Off", Devices.ValueType_Switch)
        Endif
      Next
    Case VB_SWITCH_ON
      For iChannel = 1 To 5
        If BTst(aData[1], iChannel - 1) Then
          iDeviceId = Devices.Find(Instance, Hex(bAddress, 2) & "|" & iChannel, InterfaceId, "VMB4RYLD Channel " & iChannel)
          If $bDebug Then WriteDebugLog("  Relay channel: " & iChannel & " switched on status received")
          Devices.ValueUpdate(iDeviceId, 1, "On", Devices.ValueType_Switch)
        Endif
      Next
    Case VB_LED_BLINK_FAST, VB_LED_BLINK_SLOW, VB_LED_BLINK_VERY_FAST, VB_LED_CLEAR, VB_LED_SET
      For iChannel = 1 To 5
        If BTst(aData[1], iChannel - 1) Then
          iDeviceId = Devices.Find(Instance, Hex(bAddress, 2) & "|" & iChannel, InterfaceId, "VMB4RYLD Channel " & iChannel)
          If $bDebug Then WriteDebugLog("  Relay channel: " & iChannel & " LED status received")
          Update_LED_Status(iDeviceId, aData[0]) 
        Endif
      Next
    Case VB_RELAY_STATUS
      For iChannel = 1 To 5
        If BTst(aData[1], iChannel - 1) Then
          iDeviceId = Devices.Find(Instance, Hex(bAddress, 2) & "|" & iChannel, InterfaceId, "VMB4RYLD Channel " & iChannel)
          sRelayStatus = IIf(BTst(aData[3], 0), "On", "Off")
          If $bDebug Then WriteDebugLog("  Relay channel: " & iChannel & " switched " & sRelayStatus)
          Devices.ValueUpdate(iDeviceId, 1, sRelayStatus, Devices.ValueType_Switch)
          If BTst(aData[4], 7) Then
            update_LED_Status(iDeviceId, VB_LED_SET)
          Else
            update_LED_Status(iDeviceId, VB_LED_CLEAR)
          Endif
          If BTst(aData[4], 6) Then update_LED_Status(iDeviceId, VB_LED_BLINK_SLOW)
          If BTst(aData[4], 5) Then update_LED_Status(iDeviceId, VB_LED_BLINK_FAST)
          If BTst(aData[4], 4) Then Update_LED_Status(iDeviceId, VB_LED_BLINK_VERY_FAST)
        Endif
      Next
    Case Else
      WriteDebugLog("  *** Unsupported Command ***")
  End Select
End

'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
' Support for VMB4RYLD module
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Private Sub VMB4RYLD_Send(ModuleAddress As Byte, iChannel As Integer, sAction As String)

  Dim bTempData As New Byte[]
  Dim bPrio As Byte

  If (iChannel >= 1) And (iChannel <= 5) Then
    Select Case UCase(sAction)
      Case "ON"
        bTempData.Add(VB_SWITCH_ON)
        bTempData.Add(BSet(&H00, (iChannel - 1)))
        bPrio = VB_HPrio
      Case "OFF"
        bTempData.Add(VB_SWITCH_OFF)
        bTempData.Add(BSet(&H00, (iChannel - 1)))
        bPrio = VB_HPrio
      Case "STATUS"
        bTempData.Add(VB_MODULE_STATUS)
        bTempData.Add(BSet(&H00, (iChannel - 1)))
        bPrio = VB_LPrio
      Case Else
        If $bDebug Then Main.WriteDebugLog(LogLabel & "Unsupported action '" & sAction & "' for VMB4RYLD module!")
    End Select
    QueueCommand(CreateVelbusPackage(bPrio, ModuleAddress, bTempData.Count, bTempData, False))
  Endif

End

'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
' Support for VMB2BLE module
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Private Sub VMB2BLE_Receive(bAddress As Byte, aData As Byte[])

  Dim iChannel As Integer
  Dim iDeviceId As Integer
  Dim sValue As String

  Select Case aData[0]
    Case VB_STATUS ' Do nothing
    Case VB_MODULE_TYPE
      If $bDebug Then
        WriteDebugLog("  SerialNumber: " & CInt(aData[2]) * 256 + aData[3])
        WriteDebugLog("  MemoryMap: " & aData[4])
        WriteDebugLog("  Build: " & Format(aData[5], "00") & Format(aData[6], "00"))
      Endif
    Case VB_LED_BLINK_FAST, VB_LED_BLINK_SLOW, VB_LED_BLINK_VERY_FAST, VB_LED_CLEAR, VB_LED_SET
      If BTst(aData[1], 0) Then
        iChannel = 1 ' fixed?
        iDeviceId = Devices.Find(Instance, Hex(bAddress, 2) & "|" & iChannel, InterfaceId, " VMB2BLE Blind " & iChannel)
        Update_LED_Status(iDeviceId, aData[0])
      Endif
    Case VB_BLIND_STATUS
      For iChannel = 1 To 2
        If BTst(aData[1], iChannel - 1) Then
          iDeviceId = Devices.Find(Instance, Hex(bAddress, 2) & "|" & iChannel, InterfaceId, " VMB2BLE Blind " & iChannel)

          If BTst(aData[3], 0) Then
            sValue = "Blind up"
          Else
            If BTst(aData[3], 1) Then
              sValue = "Blind down"
            Else
              sValue = "Blinds off"
            Endif
          Endif

          If $bDebug Then WriteDebugLog("  Blind Status:" & sValue)
          Devices.ValueUpdate(iDeviceId, 2, sValue)

          Select aData[5]
            Case &H64 '100%, blind is down
              sValue = "Off"
            Case &H00 '0%, blind is up
              sValue = "On"
            Case Else
              sValue = "Dim " & Str(aData[2])
          End Select

          If $bDebug Then WriteDebugLog("  Dim Status: " & sValue)
          Devices.ValueUpdate(iDeviceId, 1, sValue, Devices.ValueType_Blinds)
        Endif
      Next
    Case VB_CLOCK
      If $bDebug Then
        WriteDebugLog("  Weekday: " & Util.DisplayWeekday(aData[1]))
        WriteDebugLog("  Hour: " & Format(aData[2], 00))
        WriteDebugLog("  Minute: " & Format(aData[3], 00))
      Endif
    Case VB_DATE
      If $bDebug Then
        WriteDebugLog("  Day: " & Format(aData[1], 00))
        WriteDebugLog("  Month: " & Format(aData[2], 00))
        WriteDebugLog("  Year: " & CInt(aData[3]) * 256 + aData[4])
      Endif
    Case Else
      WriteDebugLog("  *** Unsupported Command ***")
  End Select

End

'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
' Support for VMB2BLE module
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Private Sub VMB2BLE_Send(ModuleAddress As Byte, iChannel As Integer, sAction As String)

  Dim bTempData As New Byte[]
  Dim bPrio As Byte
  Dim sCommand As String
  Dim iDim As Integer

  If InStr(sAction, " ") Then
    sCommand = Left(sAction, InStr(sAction, " ") - 1)
    iDim = Right(sAction, Len(sAction) - InStr(sAction, " "))
  Else
    sCommand = sAction
  Endif
  
  If (iChannel >= 1) And (iChannel <= 2) Then
    Select Case UCase(sCommand)
      Case "ON"                 'Blind up
        bTempData.Add(VB_BLIND_UP)
        bTempData.Add(BSet(&H00, (iChannel - 1)))
        bTempData.Add(&H00)    'high byte of time out
        bTempData.Add(&H00)    'mid byte of time out
        bTempData.Add(&H00)    'low byte of time out
        bPrio = VB_HPrio
      Case "OFF"                'Blind down
        bTempData.Add(VB_BLIND_DOWN)
        bTempData.Add(BSet(&H00, (iChannel - 1)))
        bTempData.Add(&H00)    'high byte of time out
        bTempData.Add(&H00)    'mid byte of time out
        bTempData.Add(&H00)    'low byte of time out
        bPrio = VB_HPrio
      Case "DIM"
        bTempData.Add(VB_BLIND_SET)
        bTempData.Add(BSet(&H00, (iChannel - 1)))
        bPrio = VB_HPrio
      Case "STATUS"
        bPrio = VB_LPrio
        bTempData.Add(VB_MODULE_STATUS)
        bTempData.Add(BSet(&H00, (iChannel - 1)))
      Case Else
        If $bDebug Then Main.WriteDebugLog(LogLabel & "Unsupported action '" & sAction & "' for VMB2BLE module!")
    End Select
    QueueCommand(CreateVelbusPackage(bPrio, ModuleAddress, bTempData.Count, bTempData, False))
  Endif

End

'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
' Support for VMBDME module
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Private Sub VMBDME_Receive(bAddress As Byte, aData As Byte[])

  Dim iDeviceId As String
  Dim sValue As String

  Select aData[0]
    Case VB_STATUS ' Do nothing
    Case VB_MODULE_TYPE
      If $bDebug Then
        WriteDebugLog("  Build: " & Format(aData[5], "00") & Format(aData[6], "00"))
      Endif
    Case VB_LED_BLINK_FAST, VB_LED_BLINK_SLOW, VB_LED_BLINK_VERY_FAST, VB_LED_CLEAR, VB_LED_SET
      If BTst(aData[1], 0) Then
        iDeviceId = Devices.Find(Instance, Hex(bAddress, 2), InterfaceId, "VMBDME")
        Update_LED_Status(iDeviceId, aData[0])
      Endif
    Case VB_SLIDER_STATUS, VB_DIMMER_STATUS
      iDeviceId = Devices.Find(Instance, Hex(bAddress, 2), InterfaceId, "VMBDME")
      Select Case aData[2]
        Case &H64 '100%
          sValue = "On"
        Case &H00 '0%
          sValue = "Off"
        Case Else
          sValue = "Dim " & Str(aData[2])
      End Select

      If $bDebug Then WriteDebugLog("  Dim Status: " & sValue)
      Devices.ValueUpdate(iDeviceId, 1, sValue, Devices.ValueType_Blinds)
    Case Else
      WriteDebugLog("  *** Unsupported Command ***")
  End Select

End

'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
' Support for VMBDME module
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Private Sub VMBDME_Send(ModuleAddress As Byte, sAction As String)

  Dim bTempData As New Byte[]
  Dim bPrio As Byte
  Dim sCommand As String
  Dim iDim As Integer

  If InStr(sAction, " ") Then
    sCommand = Left(sAction, InStr(sAction, " ") - 1)
    iDim = Right(sAction, Len(sAction) - InStr(sAction, " "))
  Else
    sCommand = sAction
  Endif

  Select UCase(sCommand)
    Case "ON"
      bPrio = VB_HPrio
      bTempData.Add(VB_DIMMER_SET)
      bTempData.Add(BSet(&H00, 0))
      bTempData.Add(&H64)   '100 %
      bTempData.Add(&H00)   'high byte of dim speed in seconds
      bTempData.Add(&H05)   'low byte of dim speed in seconds
    Case "OFF"
      bPrio = VB_HPrio
      bTempData.Add(VB_DIMMER_SET)
      bTempData.Add(BSet(&H00, 0))
      bTempData.Add(&H00)   ' 0 %
      bTempData.Add(&H00)   'high byte of dim speed in seconds
      bTempData.Add(&H05)   'low byte of dim speed in seconds
    Case "STATUS"
      bPrio = VB_LPrio
      bTempData.Add(VB_MODULE_STATUS)
      bTempData.Add(BSet(&H00, 0))
    Case "LAST"
      bPrio = VB_LPrio
      bTempData.Add(VB_LAST_SLIDER_STATUS)
      bTempData.Add(BSet(&H00, 0))
      bTempData.Add(&H00)
      bTempData.Add(&H00)
      bTempData.Add(&H05)
    Case "DIM"
      bPrio = VB_HPrio
      bTempData.Add(VB_DIMMER_SET)
      bTempData.Add(BSet(&H00, 0))
      bTempData.Add(CByte(iDim))
      bTempData.Add(&H00)
      bTempData.Add(&H05)
    Case Else
      If $bDebug Then Main.WriteDebugLog((LogLabel & "Unsupported action '" & sAction & "' for VMB4DC module!"))
  End Select
  If bTempData.Count > 1 Then
    QueueCommand(CreateVelbusPackage(bPrio, ModuleAddress, bTempData.Count, bTempData, False))
  Endif

End

'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
' Support for VMB4DC module
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Private Sub VMB4DC_Receive(bAddress As Byte, aData As Byte[])

  Dim iChannel, iDimmerValue As Integer
  Dim iDeviceId As Integer
  Dim sValue As String

  Select aData[0]
    Case VB_STATUS ' Do nothing
    Case VB_MODULE_TYPE
      If $bDebug Then
        WriteDebugLog("  SerialNumber: " & CInt(aData[2]) * 256 + aData[3])
        WriteDebugLog("  MemoryMap: " & aData[4])
        WriteDebugLog("  Build: " & Format(aData[5], "00") & Format(aData[6], "00"))
      Endif
    Case VB_LED_BLINK_FAST, VB_LED_BLINK_SLOW, VB_LED_BLINK_VERY_FAST, VB_LED_CLEAR, VB_LED_SET
      For iChannel = 1 To 4
        If BTst(aData[1], iChannel - 1) Then
          iDeviceId = Devices.Find(Instance, Hex(bAddress, 2) & "|" & iChannel, InterfaceId, "VMB4DC Channel " & iChannel)
          Update_LED_Status(iDeviceId, aData[0])
        Endif
      Next
    Case VB_SLIDER_STATUS
      For iChannel = 1 To 4
        If BTst(aData[1], iChannel - 1) Then
          iDeviceId = Devices.Find(Instance, Hex(bAddress, 2) & "|" & iChannel, InterfaceId, "VMB4DC Channel " & iChannel)
          Select aData[2]
            Case &H64 '100%
              sValue = "On"
            Case &H00 '0%
              sValue = "Off"
            Case Else
              sValue = "Dim " & aData[2]
          End Select

          If $bDebug Then
            WriteDebugLog("  Dim Channel: " & iChannel & " Dim Status: " & sValue)
          Endif

          Devices.ValueUpdate(iDeviceId, 1, sValue, Devices.ValueType_Blinds)
        Endif
      Next
    Case VB_DIMMER_STATUS
      For iChannel = 1 To 4
        If BTst(aData[1], iChannel - 1) Then
          iDeviceId = Devices.Find(Instance, Hex(bAddress, 2) & "|" & iChannel, InterfaceId, "VMB4DC Channel " & iChannel)
          iDimmerValue = Round((CInt(aData[2]) / 2.56), 0)
          If $bDebug Then WriteDebugLog("  Dim Status: " & iDimmerValue)
          Devices.ValueUpdate(iDeviceId, 1, iDimmerValue)
        Endif
      Next
    Case VB_DIMMER_CONTROLLER_STATUS
      For iChannel = 1 To 4
        If BTst(aData[1], iChannel - 1) Then
          iDeviceId = Devices.Find(Instance, Hex(bAddress, 2) & "|" & iChannel, InterfaceId, "VMB4DC Channel " & iChannel)
          If $bDebug Then WriteDebugLog("  Dim Status: " & aData[3])
          devices.ValueUpdate(iDeviceId, 1, "Dim " & aData[3])
        Endif
      Next
    Case Else
      WriteDebugLog("  *** Unsupported Command ***")
  End Select

End

'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
' Support for VMB4DC module
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Private Sub VMB4DC_Send(ModuleAddress As Byte, iChannel As Integer, sAction As String)

  Dim bTempData As New Byte[]
  Dim bPrio As Byte
  Dim sCommand As String
  Dim iDim As Integer

  If InStr(sAction, " ") Then
    sCommand = Left(sAction, InStr(sAction, " ") - 1)
    iDim = Right(sAction, Len(sAction) - InStr(sAction, " "))
  Else
    sCommand = sAction
  Endif
  
  If (iChannel >= 1) And (iChannel <= 4) Then
    Select UCase(sCommand)
      Case "ON"
        bPrio = VB_HPrio
        bTempData.Add(VB_DIMMER_SET)
        bTempData.Add(BSet(&H00, (iChannel - 1)))
        bTempData.Add(&H64)   '100 %
        bTempData.Add(&H00)   'high byte of dim speed in seconds
        bTempData.Add(&H05)   'low byte of dim speed in seconds
      Case "OFF"
        bPrio = VB_HPrio
        bTempData.Add(VB_DIMMER_SET)
        bTempData.Add(BSet(&H00, (iChannel - 1)))
        bTempData.Add(&H00)   ' 0 %
        bTempData.Add(&H00)   'high byte of dim speed in seconds
        bTempData.Add(&H05)   'low byte of dim speed in seconds
      Case "STATUS"
        bPrio = VB_LPrio
        bTempData.Add(VB_MODULE_STATUS)
        bTempData.Add(BSet(&H00, (iChannel - 1)))
      Case "LAST"
        bPrio = VB_LPrio
        bTempData.Add(VB_LAST_SLIDER_STATUS)
        bTempData.Add(BSet(&H00, (iChannel - 1)))
        bTempData.Add(&H00)
        bTempData.Add(&H00)
        bTempData.Add(&H05)
      Case "DIM"
        bPrio = VB_HPrio
        bTempData.Add(VB_DIMMER_SET)
        bTempData.Add(BSet(&H00, (iChannel - 1)))
        bTempData.Add(CByte(iDim))
        bTempData.Add(&H00)
        bTempData.Add(&H05)
      Case Else
        If $bDebug Then Main.WriteDebugLog((LogLabel & "Unsupported action '" & sAction & "' for VMB4DC module!"))
    End Select
    QueueCommand(CreateVelbusPackage(bPrio, ModuleAddress, bTempData.Count, bTempData, False))
  Endif

End

'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
' Support for VMB7IN module
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Private Sub VMB7IN_Receive(bAddress As Byte, aData As Byte[])

  Dim iChannel As Integer
  Dim iDeviceId As Integer
  Dim iPulses, iPulseWidth, iEnergyCounter, iEnergyUse As Integer

  Select aData[0]
    Case VB_MODULE_TYPE
      If $bDebug Then
        WriteDebugLog("  SerialNumber: " & CInt(aData[2]) * 256 + aData[3])
        WriteDebugLog("  MemoryMap: " & aData[4])
        WriteDebugLog("  Build: " & Format(aData[5], "00") & Format(aData[6], "00"))
      Endif
    Case VB_STATUS
      For iChannel = 1 To 7
        iDeviceId = Devices.Find(Instance, Hex(bAddress, 2) & "|" & iChannel, InterfaceId, "VMB7IN Channel " & iChannel)
        If BTst(aData[1], iChannel - 1) Then
          If $bDebug Then WriteDebugLog("  Status: Pressed")
          Devices.ValueUpdate(iDeviceId, 1, "Pressed")
        Endif
        If BTst(aData[2], iChannel - 1) Then
          If $bDebug Then WriteDebugLog("  Status: Released")
          Devices.ValueUpdate(iDeviceId, 1, "Released")
        Endif
        If BTst(aData[3], iChannel - 1) Then
          If $bDebug Then WriteDebugLog("  Status: Pressed (long)")
          Devices.ValueUpdate(iDeviceId, 1, "Pressed (long)")
        Endif
      Next
    Case VB_INPUT_STATUS
      For iChannel = 1 To 7
        iDeviceId = Devices.Find(Instance, Hex(bAddress, 2) & "|" & iChannel, InterfaceId, "VMB7IN Channel " & iChannel)
        If BTst(aData[1], iChannel - 1) Then 
          If $bDebug Then WriteDebugLog("  Input Status: Pressed")
          Devices.ValueUpdate(iDeviceId, 1, "Pressed") 
        Else
          If $bDebug Then WriteDebugLog("  Input Status: Released")
          Devices.ValueUpdate(iDeviceId, 1, "Released")
        Endif
      Next
    Case VB_ENERGY_COUNTER
      If aData.Count = 8 Then
        iChannel = IIf(BTst(aData[1], 0), 2, 1)
        iChannel += IIf(BTst(aData[1], 1), 2, 0)
        iPulses = IIf(BTst(aData[1], 2), 1, 0)
        iPulses += IIf(BTst(aData[1], 3), 2, 0)
        iPulses += IIf(BTst(aData[1], 4), 4, 0)
        iPulses += IIf(BTst(aData[1], 5), 8, 0)
        iPulses += IIf(BTst(aData[1], 6), 16, 0)
        iPulses += IIf(BTst(aData[1], 7), 32, 0)
        iEnergyCounter = (16777216 * CInt(aData[2])) + (65536 * CInt(aData[3])) + (256 * CInt(aData[4])) + CInt(aData[5])
        iPulseWidth = (256 * CInt(aData[6])) + CInt(aData[7])

        If iPulseWidth < 65535 Then
          iEnergyUse = 3600000000 / (iPulses * iPulseWidth)
        Else
          iEnergyUse = 0
        Endif

        iDeviceId = Devices.Find(Instance, Hex(bAddress, 2) & "|" & iChannel, InterfaceId, "VMB7IN Channel " & iChannel)
        If $bDebug Then 
          WriteDebugLog("  Energy Use: " & iEnergyUse)
          WriteDebugLog("  Energy Counter: " & iEnergyCounter)
        Endif
        Devices.ValueUpdate(iDeviceId, 2, iEnergyUse, Devices.ValueType_Undefined)
        Devices.ValueUpdate(iDeviceId, 3, iEnergyCounter, Devices.ValueType_Undefined)
      Endif
    Case VB_CLOCK
      If $bDebug Then
        WriteDebugLog("  Weekday: " & Util.DisplayWeekday(aData[1]))
        WriteDebugLog("  Hour: " & Format(aData[2], 00))
        WriteDebugLog("  Minute: " & Format(aData[3], 00))
      Endif
    Case VB_DATE
      If $bDebug Then
        WriteDebugLog("  Day: " & Format(aData[1], 00))
        WriteDebugLog("  Month: " & Format(aData[2], 00))
        WriteDebugLog("  Year: " & CInt(aData[3]) * 256 + aData[4])
      Endif
    Case Else
      WriteDebugLog("  *** Unsupported Command ***")
  End Select

End

'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
' Support for VMB7IN module
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Private Sub VMB7IN_Send(ModuleAddress As Byte, sAction As String)

  Dim bTempData As New Byte[]
  Dim bPrio As Byte
  Dim sCommand As String
  Dim iDim As Integer

  If InStr(sAction, " ") Then
    sCommand = Left(sAction, InStr(sAction, " ") - 1)
    iDim = Right(sAction, Len(sAction) - InStr(sAction, " "))
  Else
    sCommand = sAction
  Endif
  
  Select UCase(sCommand)
    Case "STATUS"
      bPrio = VB_LPrio
      bTempData.Add(VB_MODULE_STATUS)
      bTempData.Add(BSet(&H00, 0))
    Case Else
      If $bDebug Then Main.WriteDebugLog((LogLabel & "Unsupported action '" & sAction & "' for VMB7IN module!"))
  End Select
  QueueCommand(CreateVelbusPackage(bPrio, ModuleAddress, bTempData.Count, bTempData, False))

End

'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
' Support for VMBGPO module
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Private Sub VMBGPO_Receive(bAddress As Byte, aData As Byte[])

  Dim iTemperature As Integer
  Dim iDeviceId As Integer

  Select aData[0]
    Case VB_STATUS ' Todo
    Case VB_MODULE_TYPE
      If $bDebug Then
        WriteDebugLog("  SerialNumber: " & CInt(aData[2]) * 256 + aData[3])
        WriteDebugLog("  MemoryMap: " & aData[4])
        WriteDebugLog("  Build: " & Format(aData[5], "00") & Format(aData[6], "00"))
      Endif
    Case VB_TEMP
      If aData.Count = 7 Then

        iDeviceId = Devices.Find(Instance, Hex(bAddress, 2), InterfaceId, "Velbus VMBGPO panel")

        If BTst(aData[2], 0) And BTst(aData[2], 1) And BTst(aData[2], 2) And BTst(aData[2], 3) And BTst(aData[2], 4) Then
          iTemperature = -0.0625
          If Not BTst(aData[2], 5) Then iTemperature -= 0.0625
          If Not BTst(aData[2], 6) Then iTemperature -= 0.125
          If Not BTst(aData[2], 7) Then iTemperature -= 0.25
          If Not BTst(aData[1], 0) Then iTemperature -= 0.5
          If Not BTst(aData[1], 1) Then iTemperature -= 1
          If Not BTst(aData[1], 2) Then iTemperature -= 2
          If Not BTst(aData[1], 3) Then iTemperature -= 4
          If Not BTst(aData[1], 4) Then iTemperature -= 8
          If Not BTst(aData[1], 5) Then iTemperature -= 16
          If Not BTst(aData[1], 6) Then iTemperature -= 32
        Else
          iTemperature = 0
          If BTst(aData[2], 5) Then iTemperature += 0.0625
          If BTst(aData[2], 6) Then iTemperature += 0.125
          If BTst(aData[2], 7) Then iTemperature += 0.25
          If BTst(aData[1], 0) Then iTemperature += 0.5
          If BTst(aData[1], 1) Then iTemperature += 1
          If BTst(aData[1], 2) Then iTemperature += 2
          If BTst(aData[1], 3) Then iTemperature += 4
          If BTst(aData[1], 4) Then iTemperature += 8
          If BTst(aData[1], 5) Then iTemperature += 16
          If BTst(aData[1], 6) Then iTemperature += 32
        Endif
        If $bDebug Then WriteDebugLog("  Temperature: " & iTemperature)
        Devices.ValueUpdate(iDeviceId, 1, iTemperature, Devices.ValueType_Temperature)
      Else
        If $bDebug Then WriteDebugLog("  *** Received unsupported Temperature message ****")
      Endif
    Case VB_CLOCK
      If $bDebug Then
        WriteDebugLog("  Weekday: " & Util.DisplayWeekday(aData[1]))
        WriteDebugLog("  Hour: " & Format(aData[2], 00))
        WriteDebugLog("  Minute: " & Format(aData[3], 00))
      Endif
    Case VB_DATE
      If $bDebug Then
        WriteDebugLog("  Day: " & Format(aData[1], 00))
        WriteDebugLog("  Month: " & Format(aData[2], 00))
        WriteDebugLog("  Year: " & CInt(aData[3]) * 256 + aData[4])
      Endif
    Case Else
      WriteDebugLog("  *** Unsupported Command ***")
  End Select

End

'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
' Support for VMBGPO module
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Private Sub VMBGPO_Send(ModuleAddress As Byte, sAction As String)

  Dim bTempData As New Byte[]
  Dim bPrio As Byte

  Select UCase(sAction)
    Case "STATUS"
      bPrio = VB_LPrio
      bTempData.Add(VB_MODULE_STATUS)
    Case Else
      If $bDebug Then Main.WriteDebugLog(LogLabel & "Unsupported action '" & sAction & "' for VMB4RY module!")
  End Select
  QueueCommand(CreateVelbusPackage(bPrio, ModuleAddress, bTempData.Count, bTempData, False))

End

'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
' Support for VMB8PB module
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Private Sub VMB8PB_Receive(bAddress As Byte, aData As Byte[])

  Dim iChannel As Integer
  Dim iDeviceId As Integer

  Select aData[0]
    Case VB_MODULE_TYPE
      ' If we got enough info, report build info
      If aData.Count = 7 Then
        WriteDebugLog("  Build: " & Format(aData[5], "00") & Format(aData[6], "00"))
      Endif

    Case VB_STATUS
      For iChannel = 1 To 8
        iDeviceId = Devices.Find(Instance, Hex(bAddress, 2) & "|" & iChannel, InterfaceId, "VMB8PB Channel " & iChannel)
        If BTst(aData[1], iChannel - 1) Then
          If $bDebug Then WriteDebugLog("  Status: Pressed")
          Devices.ValueUpdate(iDeviceId, 1, "Pressed")
        Endif
        If BTst(aData[2], iChannel - 1) Then
          If $bDebug Then WriteDebugLog("  Status: Released")
          Devices.ValueUpdate(iDeviceId, 1, "Released")
        Endif
        If BTst(aData[3], iChannel - 1) Then
          If $bDebug Then WriteDebugLog("  Status: Pressed (long)")
          Devices.ValueUpdate(iDeviceId, 1, "Pressed (long)")
        Endif
      Next
    Case VB_INPUT_STATUS
      For iChannel = 1 To 8
        iDeviceId = Devices.Find(Instance, Hex(bAddress, 2) & "|" & iChannel, InterfaceId, "VMB8PB Channel " & iChannel)
        If BTst(aData[1], iChannel - 1) Then 
          If $bDebug Then WriteDebugLog("  Input Status: Pressed")
          Devices.ValueUpdate(iDeviceId, 1, "Pressed") 
        Else
          If $bDebug Then WriteDebugLog("  Input Status: Released")
          Devices.ValueUpdate(iDeviceId, 1, "Released")
        Endif
      Next
    Case Else
      WriteDebugLog("  *** Unsupported Command ***")
  End Select

End

'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
' Support for VMB8PB module
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Private Sub VMB8PB_Send(ModuleAddress As Byte, sAction As String)

  Dim bTempData As New Byte[]
  Dim bPrio As Byte
  Dim sCommand As String
  Dim iDim As Integer

  If InStr(sAction, " ") Then
    sCommand = Left(sAction, InStr(sAction, " ") - 1)
    iDim = Right(sAction, Len(sAction) - InStr(sAction, " "))
  Else
    sCommand = sAction
  Endif

  Select UCase(sCommand)
    Case "STATUS"
      bPrio = VB_LPrio
      bTempData.Add(VB_MODULE_STATUS)
      bTempData.Add(BSet(&H00, 0))
    Case Else
      If $bDebug Then Main.WriteDebugLog((LogLabel & "Unsupported action '" & sAction & "' for VMB8PB module!"))
  End Select
  QueueCommand(CreateVelbusPackage(bPrio, ModuleAddress, bTempData.Count, bTempData, False))

End

'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
' Support for VMBDMI: Velbus dimmer for resistive or inductive load
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Private Sub VMBDMI_Receive(bAddress As Byte, aData As Byte[])

  Dim iDeviceId As Integer
  Dim sValue As String

  Select aData
    Case VB_STATUS ' Do nothing
    Case VB_MODULE_TYPE
      If $bDebug Then
        WriteDebugLog("  SerialNumber: " & CInt(aData[2]) * 256 + aData[3])
        WriteDebugLog("  MemoryMap: " & aData[4])
        WriteDebugLog("  Build: " & Format(aData[5], "00") & Format(aData[6], "00"))
      Endif
    Case VB_DIMMER_CONTROLLER_STATUS
      iDeviceId = Devices.Find(Instance, Hex(bAddress, 2), InterfaceId, "VMBDMI")

      Select aData[2]
        Case &H64 ' 100%
          sValue = "On"
        Case &H00 ' 0%
          sValue = "Off"
        Case Else
          sValue = "Dim " & Str(aData[2])
      End Select

      If $bDebug Then WriteDebugLog(LogLabel & "  Dim Status: " & sValue)
      Devices.ValueUpdate(iDeviceId, 1, sValue)

    Case Else
      WriteDebugLog("  *** Unsupported Command ***")
  End Select

End

'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
' Support for VMBPIRC: Ceiling PIR detector module
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Private Sub VMBPIRC_Receive(bAddress As Byte, aData As Byte[])

  'Dim iDeviceId As Integer

  Select aData
    Case VB_STATUS ' Do nothing
    Case VB_MODULE_TYPE
      If $bDebug Then
        WriteDebugLog("  SerialNumber: " & CInt(aData[2]) * 256 + aData[3])
        WriteDebugLog("  MemoryMap: " & aData[4])
        WriteDebugLog("  Build: " & Format(aData[5], "00") & Format(aData[6], "00"))
      Endif
    Case VB_CLOCK
      If $bDebug Then
        WriteDebugLog("  Weekday: " & Util.DisplayWeekday(aData[1]))
        WriteDebugLog("  Hour: " & Format(aData[2], 00))
        WriteDebugLog("  Minute: " & Format(aData[3], 00))
      Endif
    Case VB_DATE
      If $bDebug Then
        WriteDebugLog("  Day: " & Format(aData[1], 00))
        WriteDebugLog("  Month: " & Format(aData[2], 00))
        WriteDebugLog("  Year: " & CInt(aData[3]) * 256 + aData[4])
      Endif

    Case Else
      WriteDebugLog("  *** Unsupported Command ***")
  End Select

End

'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
' Update LED status of push button
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Private Sub Update_LED_Status(iDeviceId As Integer, bLedStatus As Byte)

  Select bLedStatus
    Case VB_LED_CLEAR
      If $bDebug Then WriteDebugLog("  Update LED Status: Off")
      Devices.ValueUpdate(iDeviceId, 2, "Off")
    Case VB_LED_SET
      If $bDebug Then WriteDebugLog("  Update LED Status: On")
      Devices.ValueUpdate(iDeviceId, 2, "On")
    Case VB_LED_BLINK_SLOW
      If $bDebug Then WriteDebugLog("  Update LED Status: Blink slow")
      Devices.ValueUpdate(iDeviceId, 2, "Blink slow")
    Case VB_LED_BLINK_FAST
      If $bDebug Then WriteDebugLog("  Update LED Status: Blink fast")
      Devices.ValueUpdate(iDeviceId, 2, "Blink fast")
    Case VB_LED_BLINK_VERY_FAST
      If $bDebug Then WriteDebugLog("  Update LED Status: Blink very fast")
      Devices.ValueUpdate(iDeviceId, 2, "Blink very fast")
  End Select

End

'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
' Display module type
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Private Sub DisplayModuleType(bModule As Byte) As String

  Select bModule
    Case VMUNKNOWN
      Return "VMUNKNOWN"
    Case VMB8PB
      Return "VMB8PB"
    Case VMB1RY
      Return "VMB1RY"
    Case VMB1BL
      Return "VMB1BL"
    Case VMB6IN
      Return "VMB6IN"
    Case VMB1DM
      Return "VMB1DM"
    Case VMB4RY
      Return "VMB4RY"
    Case VMB2BL
      Return "VMB2BL"
    Case VMB8IR
      Return "VMB8IR"
    Case VMB4PD
      Return "VMB4PD"
    Case VMB1TS
      Return "VMB1TS"
    Case VMB1TH
      Return "VMB1TH"
    Case VMB1TC
      Return "VMB1TC"
    Case VMB1LED
      Return "VMB1LED"
    Case VMB4RYLD
      Return "VMB4RYLD"
    Case VMB4RYNO
      Return "VMB4RYNO"
    Case VMB4DC
      Return "VMB4DC"
    Case VMBMPD
      Return "VMBMPD"
    Case VMBDME
      Return "VMBDME"
    Case VMBDMI
      Return "VMBDMI"
    Case VMB8PBU
      Return "VMB8PBU"
    Case VMB6PBN
      Return "VMB6PBN"
    Case VMB2PBN
      Return "VMB2PBN"
    Case VMB6PBB
      Return "VMB6PBB"
    Case VMB4RF
      Return "VMB4RF"
    Case VMB1RYNO
      Return "VMB1RYNO"
    Case VMB1BLE
      Return "VMB1BLE"
    Case VMB2BLE
      Return "VMB2BLE"
    Case VMBGP1
      Return "VMBGP1"
    Case VMBGP2
      Return "VMBGP2"
    Case VMBGP4
      Return "VMBGP4"
    Case VMBGPO
      Return "VMBGPO"
    Case VMB7IN
      Return "VMB7IN"
    Case VMBGPTC
      Return "VMBGPTC"
    Case VMBGPOD
      Return "VMBGPOD"
    Case VMB1RYNOS
      Return "VMB1RYNOS"
    Case VMBPIRM
      Return "VMBPIRM"
    Case VMBPIRC
      Return "VMBPIRC"
    Case VMBPIRO
      Return "VMBPIRO"
    Case VMBPP4PIR
      Return "VMBPP4PIR"
    Case VMBDMIR
      Return "VMBDMIR"
    Case VMBRF8RXS
      Return "VMBRF8RXS"
    Case &HFF
      Return ""
    Default
      Return "Unknown (" & Hex(bModule, 2) & ")"
  End Select

End

'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
' Display Velbus Command type
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Private Sub DisplayCommandType(bType As Byte) As String

  Select bType
    Case VB_STATUS
      Return "VB_STATUS"
    Case VB_SWITCH_OFF
      Return "VB_SWITCH_OFF"
    Case VB_SWITCH_ON
      Return "VB_SWITCH_ON"
    Case VB_RELAY_TIMER
      Return "VB_RELAY_TIMER"
    Case VB_BLIND_OFF
      Return "VB_BLIND_OFF"
    Case VB_BLIND_UP
      Return "VB_BLIND_UP"
    Case VB_BLIND_DOWN
      Return "VB_BLIND_DOWN"
    Case VB_DIMMER_SET
      Return "VB_DIMMER_SET"
    Case VB_DIMMER_TIMER
      Return "VB_DIMMER_TIMER"
    Case VB_BUS_OFF
      Return "VB_BUS_OFF"
    Case VB_BUS_ACTIVE
      Return "VB_BUS_ACTIVE"
    Case VB_RS232_BUFFER_FULL
      Return "VB_RS232_BUFFER_FULL"
    Case VB_RS232_BUFFER_EMPTY
      Return "VB_RS232_BUFFER_EMPTY"
    Case VB_REALY_TIMER_BLINK
      Return "VB_REALY_TIMER_BLINK"
    Case VB_INTERFACE_STATUS
      Return "VB_INTERFACE_STATUS"
    Case VB_SLIDER_STATUS
      Return "VB_SLIDER_STATUS"
    Case VB_LAST_SLIDER_STATUS
      Return "VB_LAST_SLIDER_STATUS"
    Case VB_FORCED_OFF
      Return "VB_FORCED_OFF"
    Case VB_CANCEL_FORCED_OFF
      Return "VB_CANCEL_FORCED_OFF"
    Case VB_FORCED_ON
      Return "VB_FORCED_ON"
    Case VB_INHIBIT
      Return "VB_INHIBIT"
    Case VB_CANCEL_INHIBIT
      Return "VB_CANCEL_INHIBIT"
    Case VB_BLIND_SET
      Return "VB_BLIND_SET"
    Case VB_FIRMWARE_UPDATE
      Return "VB_FIRMWARE_UPDATE"
    Case VB_FIRMWARE_INFO
      Return "VB_FIRMWARE_INFO"
    Case VB_FIRMWARE_UPGRADE_ENTER
      Return "VB_FIRMWARE_UPGRADE_ENTER"
    Case VB_FIRMWARE_UPGRADE_ABORT
      Return "VB_FIRMWARE_UPGRADE_ABORT"
    Case VB_FIRMWARE_UPGRADE_EXIT
      Return "VB_FIRMWARE_UPGRADE_EXIT"
    Case VB_FIRMWARE_UPGRADE_START
      Return "VB_FIRMWARE_UPGRADE_START"
    Case VB_FIRMWARE_MEM_WRITE
      Return "VB_FIRMWARE_MEM_WRITE"
    Case VB_FIRMWARE_MEM
      Return "VB_FIRMWARE_MEM"
    Case VB_FIRMWARE_MEM_WRITE_CONFIRM
      Return "VB_FIRMWARE_MEM_WRITE_CONFIRM"
    Case VB_FIRMWARE_MEM_READ
      Return "VB_FIRMWARE_MEM_READ"
    Case VB_DISABLE_PROGRAM
      Return "VB_DISABLE_PROGRAM"
    Case VB_ENABLE_PROGRAM
      Return "VB_ENABLE_PROGRAM"
    Case VB_SELECT_PROGRAM
      Return "VB_SELECT_PROGRAM"
    Case VB_CLR_LEARN_MODE
      Return "VB_CLR_LEARN_MODE"
    Case VB_RF_CODE_STATUS
      Return "VB_RF_CODE_STATUS"
    Case VB_DATE
      Return "VB_DATE"
    Case VB_DIMMER_CONTROLLER_STATUS
      Return "VB_DIMMER_CONTROLLER_STATUS"
    Case VB_ENERGY_COUNTER
      Return "VB_ENERGY_COUNTER"
    Case VB_ALARM_CLOCK
      Return "VB_ALARM_CLOCK"
    Case VB_TEMP_SETTINGS_3
      Return "VB_TEMP_SETTINGS_3"
    Case VB_STATISTICS_REQUEST
      Return "VB_STATISTICS_REQUEST"
    Case VB_STATISTICS
      Return "VB_STATISTICS"
    Case VB_MEM_READ
      Return "VB_MEM_READ"
    Case VB_MEM_WRITE
      Return "VB_MEM_WRITE"
    Case VB_MEM_DUMP
      Return "VB_MEM_DUMP"
    Case VB_MEM_BLOCK
      Return "VB_MEM_BLOCK"
    Case VB_LCD_1
      Return "VB_LCD_1"
    Case VB_LCD_2
      Return "VB_LCD_2"
    Case VB_LCD_3
      Return "VB_LCD_3"
    Case VB_LCD_REQUEST
      Return "VB_LCD_REQUEST"
    Case VB_TIMER_ENABLE
      Return "VB_TIMER_ENABLE"
    Case VB_BACKLIGHT_RESET
      Return "VB_BACKLIGHT_RESET"
    Case VB_BACKLIGHT_BUTTON_RESET
      Return "VB_BACKLIGHT_BUTTON_RESET"
    Case VB_BACKLIGHT_BUTTON_SET
      Return "VB_BACKLIGHT_BUTTON_SET"
    Case VB_BACKLIGHT_STATUS
      Return "VB_BACKLIGHT_STATUS"
    Case VB_BACKLIGHT
      Return "VB_BACKLIGHT"
    Case VB_CLOCK_REQUEST
      Return "VB_CLOCK_REQUEST"
    Case VB_CLOCK
      Return "VB_CLOCK"
    Case VB_ERROR_COUNT_REQUEST
      Return "VB_ERROR_COUNT_REQUEST"
    Case VB_ERROR_COUNT
      Return "VB_ERROR_COUNT"
    Case VB_TEMP_COMFORT
      Return "VB_TEMP_COMFORT"
    Case VB_TEMP_DAY
      Return "VB_TEMP_DAY"
    Case VB_TEMP_NIGHT
      Return "VB_TEMP_NIGHT"
    Case VB_TEMP_SAFE
      Return "VB_TEMP_SAFE"
    Case VB_TEMP_COOLING
      Return "VB_TEMP_COOLING"
    Case VB_TEMP_HEATING
      Return "VB_TEMP_HEATING"
    Case VB_TEMP_LOCK
      Return "VB_TEMP_LOCK"
    Case VB_TEMP_UNLOCK
      Return "VB_TEMP_UNLOCK"
    Case VB_TIMER_SLEEP
      Return "VB_TIMER_SLEEP"
    Case VB_TEMP_SET
      Return "VB_TEMP_SET"
    Case VB_TEMP_REQUEST
      Return "VB_TEMP_REQUEST"
    Case VB_TEMP
      Return "VB_TEMP"
    Case VB_TEMP_SETTINGS_REQUEST
      Return "VB_TEMP_SETTINGS_REQUEST"
    Case VB_TEMP_SETTINGS_1
      Return "VB_TEMP_SETTINGS_1"
    Case VB_TEMP_SETTINGS_2
      Return "VB_TEMP_SETTINGS_2"
    Case VB_TEMP_STATUS
      Return "VB_TEMP_STATUS"
    Case VB_IR_STATUS
      Return "VB_IR_STATUS"
    Case VB_BLIND_STATUS
      Return "VB_BLIND_STATUS"
    Case VB_INPUT_STATUS
      Return "VB_INPUT_STATUS"
    Case VB_DIMMER_STATUS
      Return "VB_DIMMER_STATUS"
    Case VB_MODULE_NAME_REQUEST
      Return "VB_MODULE_NAME_REQUEST"
    Case VB_MODULE_NAME_1
      Return "VB_MODULE_NAME_1"
    Case VB_MODULE_NAME_2
      Return "VB_MODULE_NAME_2"
    Case VB_MODULE_NAME_3
      Return "VB_MODULE_NAME_3"
    Case VB_BLACKLIGHT_SET
      Return "VB_BLACKLIGHT_SET"
    Case VB_LED_STATUS
      Return "VB_LED_STATUS"
    Case VB_LED_CLEAR
      Return "VB_LED_CLEAR"
    Case VB_LED_SET
      Return "VB_LED_SET"
    Case VB_LED_BLINK_SLOW
      Return "VB_LED_BLINK_SLOW"
    Case VB_LED_BLINK_FAST
      Return "VB_LED_BLINK_FAST"
    Case VB_LED_BLINK_VERY_FAST
      Return "VB_LED_BLINK_VERY_FAST"
    Case VB_MODULE_STATUS
      Return "VB_MODULE_STATUS"
    Case VB_RELAY_STATUS
      Return "VB_RELAY_STATUS"
    Case VB_EEPROM_WRITE
      Return "VB_EEPROM_WRITE"
    Case VB_EEPROM_READ
      Return "VB_EEPROM_READ"
    Case VB_EEPROM_STATUS
      Return "VB_EEPROM_STATUS"
    Case VB_MODULE_TYPE
      Return "VB_MODULE_TYPE"
    Default
      Return "Unknown (" & Hex(bType, 2) & ")"
  End Select

End
