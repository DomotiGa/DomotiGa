' Gambas class file

' Description:
' CJSONRPC.class
' Built-in JSON-RPC server.

' Development Status:
' Finished

' DomotiGa - an open source home automation program.
' Copyright (C) Ron Klinkien, The Netherlands.

' Read file called COPYING for license details.

Public $sStr As String
Public $sStream As Stream

'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
' Module/Class specific variables
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Public PluginName As String = "JSONRPC"
Public PluginFriendlyName As String = "JSON-RPC"
Public PluginVersion As String = "1.40"
Public PluginAuthor As String = "Alexander Kuiper"
Public PluginProtocols As String[]
Public PluginMaxInstances As Integer = 1

Public KeyName As String
Public LogLabel As String = "[JSONRPC] "
Public Instance As Integer
Public IsRunning As Boolean
Public ErrorText As String
Public ErrorWhere As String

'Detect backend type!domotiga3 Or domotigaserver3...logfiles are different

'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
' JSON-RPC API Version
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Private APIVersion As String = "1.01"

'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
' Private Variables
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Private $bEnabled As Boolean
Private $iHTTPPort As Integer
Private $iMaxConn As Integer
Private $iTypeConn As Integer
Private $iAuth As Integer
Private $bDebug As Boolean
Private $bSSL As Boolean
Private $iSSLCertificate As Integer

'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
' Other Variable definitions like sockets, timers, etc
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Public hServerSocket As CServerSocket
Private $cClients As New Object[]
Private $sCurrentMethod As String
Private $cMethods As New String[]
Private $cIPWhiteList As New String[]
Private $iReply As Integer
Private $vReply As Variant

'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
' Constants
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Private Const JSONRPC_PARSEERROR As Integer = -32700
Private Const JSONRPC_INVALIDREQUEST As Integer = -32600
Private Const JSONRPC_METHODNOTFOUND As Integer = -32601
Private Const JSONRPC_INVALIDPARAMS As Integer = -32602
Private Const JSONRPC_INTERNALERROR As Integer = -32603

Private Const Type_Auth_None As Integer = 0 ' No authentication done
Private Const Type_Auth_Basic As Integer = 1 ' Basic HTTP authentication done - against the user list
Private Const Type_Auth_Session As Integer = 2 ' Session based authentication?

'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
' iType constants, used by BuildFilterFields & FilterFields
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Private Const Type_Data_None As Integer = 0
Private Const Type_Data_Device As Integer = 1
Private Const Type_Data_DeviceValue As Integer = 6
Private Const Type_Data_Event As Integer = 2
Private Const Type_Data_Action As Integer = 3
Private Const Type_Data_Scene As Integer = 4
Private Const Type_Data_Location As Integer = 5
Private Const Type_Thermostat_Scenario As Integer = 6

'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
' Mandatory subroutine for each Module/Class to initialize:
' - The cPlugin[x].Settings are copied into local variables
' - Port/Connection will be started (any errors caught)
' - Any other code per Class
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Public Sub StartPlugin(cPl As CPluginEntry)

  KeyName = cPl.KeyName
  Instance = cPl.Instance
  If Instance <> 1 Then LogLabel = Replace(LogLabel, "] ", "#" & Instance & "] ")

  ' Copy configuration items locally
  $bEnabled = cPl.Settings["enabled"]
  $iMaxConn = cPl.Settings["maxconn"]
  $iHTTPPort = cPl.Settings["httpport"]
  $bSSL = cPl.Settings["sslenabled"]
  $iSSLCertificate = cPl.Settings["sslcertificate_id"]
  $iTypeConn = cPl.Settings["type"]
  $iAuth = cPl.Settings["auth"]
  $bDebug = cPl.Settings["debug"]

  ' Connect/Initialize connection
  Connect()

End

'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
' Mandatory sub for each Module/Class to stop
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Public Sub StopPlugin()

  Try Disconnect()

End

'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
' Add a new JSON-RPC method
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Private Sub RegisterMethod(sMethod As String)

  If Not $cMethods.Exist(sMethod, gb.IgnoreCase) Then
    $cMethods.Add(sMethod)
  Endif 

End

'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
' Initialize the JSON-RPC server and register all methods
' It is possible to also register the help, but we don't use it
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Private Sub Connect() As Boolean

  Dim rResult As Result

  $cMethods.Clear()
  ' ------------------------
  ' start method definitions
  ' ------------------------

  ' ### System methods ###
  RegisterMethod("system.listmethods")
  RegisterMethod("system.hostname")
  RegisterMethod("system.get")

  ' ### API methods ###
  RegisterMethod("api.version")

  ' ### Global methods ###
  RegisterMethod("domotiga.pid")
  RegisterMethod("domotiga.uptime")
  RegisterMethod("domotiga.version")
  RegisterMethod("domotiga.get")

  ' ### Astro methods ###
  RegisterMethod("astro.get")

  ' ### Data methods ###
  RegisterMethod("data.newmessage")

  ' ### Mode methods ###
  RegisterMethod("housemode.list")
  RegisterMethod("housemode.get")
  RegisterMethod("housemode.set")

  ' ### Sound methods ###
  RegisterMethod("sound.list")
  RegisterMethod("sound.play")
  RegisterMethod("voicetext.speak")

  ' ### GlobalVar methods ###
  RegisterMethod("globalvar.list")
  RegisterMethod("globalvar.get")
  RegisterMethod("globalvar.set")
  RegisterMethod("globalvar.del")

  ' ### Device methods ###
  RegisterMethod("device.list")
  RegisterMethod("device.get")
  RegisterMethod("device.set")

  ' ### Value methods ###
  RegisterMethod("value.get")
  RegisterMethod("value.set")

  ' ### Location methods ###
  RegisterMethod("location.list")

  ' ### Plugin methods ###
  RegisterMethod("plugin.list")
  RegisterMethod("plugin.get")
  RegisterMethod("plugin.restart")

  ' ### Message methods ###
  RegisterMethod("email.send")
  RegisterMethod("twitter.send")
  RegisterMethod("sms.send")
  RegisterMethod("nma.send")
  RegisterMethod("prowl.send")
  RegisterMethod("pushover.send")

  ' ### Event methods ###
  RegisterMethod("event.list")
  RegisterMethod("event.set")
  RegisterMethod("event.run")
  RegisterMethod("action.list")
  RegisterMethod("action.run")
  RegisterMethod("condition.evaluate")
  RegisterMethod("scene.list")
  RegisterMethod("scene.get")
  RegisterMethod("scene.run")
  RegisterMethod("scene.create")
  RegisterMethod("scene.delete")

  ' ### SqueezeBox methods ###
  RegisterMethod("squeezebox.get")
  RegisterMethod("squeezebox.set")

  ' ### Razberry methods ###
  RegisterMethod("razberry.updatesready")

  ' ### RRDTool methods ###
  RegisterMethod("rrdtool.create")
  RegisterMethod("rrdtool.update")
  RegisterMethod("rrdtool.generate")
  RegisterMethod("rrdtool.deleterrd")

  ' ### ServerStats methods ###
  RegisterMethod("serverstat.update")

  ' ### DSC Security methods ###
  RegisterMethod("dsc.setpin")
  RegisterMethod("dsc.setarm")

  ' ### LEDMatrix methods ###
  RegisterMethod("ledmatrix.display")

  ' ### AVControl methods ###
  RegisterMethod("avcontrol.set")
  RegisterMethod("avcontrol.get")

  ' ### CUL methods ###
  RegisterMethod("cul.simulate")
  RegisterMethod("cul.queuecommand")

  ' ### Calendar methods ###
  RegisterMethod("calendar.get")
  RegisterMethod("calendar.set")

  ' ### Thermostat methods ###
  RegisterMethod("thermostat.list")
  RegisterMethod("thermostat.get")
  RegisterMethod("thermostat.set")
  RegisterMethod("thermostat.derogateheating")
  RegisterMethod("thermostat.getderogateheating")

  ' ### Commander methods ###
  RegisterMethod("cmdr.plcbus.txcommand")

  ' ### Subscribe methods ###
  RegisterMethod("subscribe.logupdate")
  RegisterMethod("subscribe.deviceupdate")

  ' ### Tools Commander methods ###
  RegisterMethod("tools.openzwave.get")
  RegisterMethod("tools.openzwave.set")
  RegisterMethod("tools.rfxcom.get")
  RegisterMethod("tools.rfxcom.set")
  RegisterMethod("tools.serialport.get")

  ' ---------------------------------------------------------
  ' All have been setup, now try to start the JSON-RPC server
  ' ---------------------------------------------------------

  If $iHTTPPort < 1024 Or If $iHTTPPort > 65535 Then
    Error.Raise("Invalid port number, it has be between 1024 and 65535")
  Endif 

  If $iMaxConn < 0 Then
    Error.Raise("Invalid maximum connections number")
  Endif

  hServerSocket = New CServerSocket As "hServerSocket"

  If $bSSL Then
    If $iSSLCertificate <= 0 Then
      Error.Raise("SSL enabled, but no SSL certificate configured")
    Endif

    rResult = Main.hDB.Exec("SELECT * FROM sslcertificates WHERE id = " & $iSSLCertificate)

    If rResult And If rResult.Available And If rResult.Count = 1 Then
      hServerSocket.SSLCertificate = IIf(rResult!certificate, Main.sBaseDir &/ "certificate" &/ rResult!certificate, "")
      hServerSocket.SSLPrivateKey = IIf(rResult!private, Main.sBaseDir &/ "certificate" &/ rResult!private, "")
      hServerSocket.SSLClientKey = IIf(rResult!client, Main.sBaseDir &/ "certificate" &/ rResult!client, "")
    Else
      Error.Raise("SSL enabled, but no SSL certificate found in the database")
    Endif

    If $bDebug Then
      Main.WriteDebugLog(LogLabel & "SSL Certificate: " & IIf(rResult!certificate, Main.sBaseDir &/ "certificate" &/ rResult!certificate, ""))
      Main.WriteDebugLog(LogLabel & "SSL Private Key: " & IIf(rResult!private, Main.sBaseDir &/ "certificate" &/ rResult!private, ""))
      Main.WriteDebugLog(LogLabel & "SSL Client: " & IIf(rResult!client, Main.sBaseDir &/ "certificate" &/ rResult!client, ""))
    Endif

    hServerSocket.Encrypt = Net.SSL
    Try hServerSocket.SSLStart()
    If Error Then Error.Raise("SSL start failed (" & Error.Text & ")")
  Endif

  Try hServerSocket.Port = $iHTTPPort
  If Error Then Error.Raise("Invalid TCP port")

  hServerSocket.Listen($iMaxConn)
  If hServerSocket.Status < 0 Then
    Main.WriteLog(LogLabel & "ERROR: " & PluginFriendlyName & " Server FAILED listen on Port " & $iHTTPPort)
    IsRunning = False
    ErrorText = ""
    ErrorWhere = ""
    Return False
  Endif

  ' Write to main logfile we connected successfully
  Main.WriteLog(LogLabel & PluginFriendlyName & " Server listening on Port " & $iHTTPPort & IIf($bSSL, " (SSL)", ""))

  IsRunning = True
  Return True

Catch ' some errors
  Main.WriteLog(LogLabel & "ERROR: " & PluginFriendlyName & " Server FAILED listen on Port " & $iHTTPPort)
  Main.WriteLog(LogLabel & "ERROR: " & Error.Text)
  IsRunning = False
  ErrorText = Error.Text
  ErrorWhere = Error.Where

  Return False

End

'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
' Shutdown our JSON-RPC server
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Private Sub Disconnect()

  Dim oObj As Object

  ' Close the remote clients
  For Each oObj In $cClients
    Try oObj.Close()
  Next

  ' Clear the client list
  $cClients.Clear()

  Try hServerSocket.Close()

End

'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
' Register an incoming connection. We support JSON-RPC over 
' HTTP (including URL) and WebSockets
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Public Sub hServerSocket_Connection(RemoteHost As String)

  Dim hS As CSocket

  hS = New CSocket As "hSocket"

  ' If a whitelist exist, reject all other IP address
  If $cIPWhiteList.Count >= 1 Then
    If Not $cIPWhiteList.Exist(RemoteHost) Then
      Try hS.AcceptSocket(hServerSocket)
      hS.Close()
      Return
    Endif
  Endif

  ' Do an assignment, if SSL fails, we can get an error
  Try hS.AssignSocket()
  If Error Then
    Return
  Endif

  ' We support HTTP and WebSockets
  hS.Protocol = hS.PROTOCOL_HTTP_WEBSOCKET

  ' Also support HTTP request in URL
  hS.HTTPRequestInUrl = "?request="

  ' With JSON-RPC we also support simple HTTP request like 'method=value.set&device_id=5&value=5'
  hS.HTTPRAWInUrl = "/json?"

  ' Overrule the content-type
  hS.HTTPHeaders = ["content-type: application/json"]

  $cClients.Add(hS)

End

'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
' Close and remove Socket
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Private Sub RemoveSocket(hS As CSocket)

  Try $cClients.Remove($cClients.Find(hS))

  ' Remove hooks to:
  ' subscribe.deviceupdate
  ' subscribe.logupdate

End

'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
' Read data from the Socket
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Public Sub hSocket_Read(sJsonData As Variant)

  Dim iJsonType As Byte = 2
  Dim vTestData As Variant
  Dim vJsonData As New Variant[]
  Dim Entry As Variant
  Dim vOutput As New Variant[]
  Dim sJSONVersion As String
  Dim sMethod As String
  Dim JsonBatch As Boolean
  Dim vId As Variant
  Dim jCol As JSONCollection
  Dim aParam As String[]
  Dim sParam As String

  ' Check if we got a simple JSON request - we normally prefer the JSON-RPC 2.0
  If InStr(sJsonData, "method=") = 1 Then

    ' Set it to JSON type 1
    iJsonType = 1

    If InStr(sJsonData, "&") Then
      sMethod = Mid(sJsonData, 8, InStr(sJsonData, "&") - 8)
      sJsonData = Mid(sJsonData, InStr(sJsonData, "&") + 1)
    Else
      sMethod = Mid(sJsonData, 8)
      sJsonData = ""
    Endif

    Entry = New JSONCollection
    aParam = Split(sJsonData, "&")

    If aParam.Count >= 1 Then
      For Each sParam In aParam
        If sParam Then
          If InStr(sParam, "=") Then
            Entry[Left(sParam, InStr(sParam, "=") - 1)] = URL.Decode(Mid(sParam, InStr(sParam, "=") + 1))
          Else
            ' Bad parameter
            vOutput.Add(JsonError(JSONRPC_INVALIDPARAMS, 1, vId))

            Try sJsonData = Util.JSONEncode(vOutput[0])

            Last.Begin()
            Last.Print(sJsonData)
            Last.Send()

            Return
          Endif
        Endif
      Next
    Endif

    ' Just pass all the data for testing
    RemoteCall(sMethod, Entry)

    ' The response from JSON handle can't be empty!
    If $vReply = Null Then
      If $iReply <> 0 Then
        vOutput.Add(JsonError($iReply, 1, vId))
      Else
        vOutput.Add(JsonError(JSONRPC_INTERNALERROR, 1, vId))
      Endif
    Else

    vOutput.Add(JsonToRpc($vReply, 1, vId))

    Endif

    Try sJsonData = Util.JSONEncode(vOutput[0])

    If Error Then
      ' JSON data is invalid, thrown an internal error
      sJsonData = Util.JSONEncode(JsonError(JSONRPC_INTERNALERROR, 1))
    Endif

    Last.Begin()
    Last.Print(sJsonData)
    Last.Send()

  Else

    ' Remove all NewLine and Carriage Return
    sJsonData = Replace(sJsonData, Chr(13), "")
    sJsonData = Replace(sJsonData, Chr(10), "")

    ' Try to decode the string
    Try vTestData = JSON.Decode(sJsonData, True)
    If Error Then
      Last.Begin()
      Last.Print(Util.JSONEncode(JsonError(JSONRPC_PARSEERROR, 2)))
      Last.Send()

      Return
    Endif

    Try Entry = vTestData[0]
    If Error Then
      Last.Begin()
      Last.Print(Util.JSONEncode(JsonError(JSONRPC_PARSEERROR, 2)))
      Last.Send() 
      Return
    Endif

    ' No array, just 1 call
    If Entry = Null Then
      JsonBatch = False
      vJsonData.Add(vTestData)
    Else
      JsonBatch = True
      vJsonData = vTestData
    Endif

    For Each Entry In vJsonData

      Try sJSONVersion = Entry["jsonrpc"]
      ' Check if we got a method name

      If sJSONVersion = "2.0" Then
        ' Check if we got a method name
        Try sMethod = Entry["method"]
        If Error Then
          vOutput.Add(JsonError(JSONRPC_INVALIDREQUEST, 1))
        Else
          If TypeOf(Entry["method"]) = gb.String Then
            Try vId = Entry["id"]

            sMethod = LCase(sMethod)

            If Not $cMethods.Exist(sMethod) Then
              vOutput.Add(JsonError(JSONRPC_METHODNOTFOUND, 2, vId))
            Else
              $iReply = 0 
              $vReply = Null

              ' Convert the 'Null' to ""
              If Entry["params"] Then
                For Each Entry["params"]
                  If Entry["params"][Entry["params"].Key] = Null Then
                    Entry["params"].Add("", Entry["params"].Key)
                  Else If TypeOf(Entry["params"][Entry["params"].Key]) = gb.Object And If Object.Type(Entry["params"][Entry["params"].Key]) = "JSONCollection" Then
                    jCol = Entry[Entry["params"].Key]
                    For Each jCol
                      If jCol[jCol.Key] = Null Then
                        jCol.Add("", jCol.Key)
                      Endif
                    Next
                  Endif
                Next
              Endif

              ' Just pass all the data for testing
              RemoteCall(sMethod, Entry["params"])

              ' If id=Null then it is most likely a Json-Rpc notification, we shouldn't respond to it
              If vId <> Null Then

                ' The response from JSON-RPC handle can't be empty!
                If $vReply = Null Then
                  If $iReply <> 0 Then
                    vOutput.Add(JsonError($iReply, 2, vId))
                  Else
                    vOutput.Add(JsonError(JSONRPC_INTERNALERROR, 2, vId))
                  Endif
                Else
                  vOutput.Add(JsonToRpc($vReply, 2, vId))
                Endif
              Endif
            Endif
          Else
            vOutput.Add(JsonError(JSONRPC_INVALIDREQUEST, 2))
          Endif
        Endif
      Else
        vOutput.Add(JsonError(JSONRPC_INVALIDREQUEST, 2))
      Endif

    Next

    If vOutput.Count >= 1 Then
      If JsonBatch Then
        Try sJsonData = Util.JSONEncode(vOutput)
      Else
        'Try sJsonData = Util.JSONEncode(vOutput[0])
        Try sJsonData = Util.JSONEncode(vOutput[0])
      Endif

      If Error Then
        ' JSON data is invalid, thrown an internal error
        sJsonData = Util.JSONEncode(JsonError(JSONRPC_INTERNALERROR, 2))
      Endif

      Last.Begin()
      Last.Print(sJsonData)
      Last.Send()
    Endif
  Endif

Catch
  Last.Begin()
  Last.Print(Util.JSONEncode(JsonError(JSONRPC_INTERNALERROR, iJsonType)))
  Last.Send()

End

'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
' Remove a suddenly socket from the list
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Public Sub hSocket_Closed()

  RemoveSocket(Last)

End

'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
' Authentication event
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Public Sub hSocket_Authorization(sData As String)

  ' Check if authorization is enabled in JSON-RPC
  ' if enabled and sData="" then do Stop Event
  ' If sData<>"" do unbase64 and check against user list

  ' Stop Event = Reject authorization

  If sData Then
  Else
  Endif

End

'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
' Create a Json Collection with a specific error message
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Private Sub JsonError(iError As Integer, iJsonType As Byte, Optional vId As Variant = Null) As JSONCollection

  Dim cJsonData As New JSONCollection
  Dim cError As New JSONCollection

  ' Fill the error fields first
  cError.Add(iError, "code")
  Select iError
    Case JSONRPC_PARSEERROR
      cError.Add("Parse error", "message")
    Case JSONRPC_INVALIDREQUEST
      cError.Add("Invalid request", "message")
    Case JSONRPC_METHODNOTFOUND
      cError.Add("Method not found", "message")
    Case JSONRPC_INVALIDPARAMS
      cError.Add("Invalid params", "message")
    Case JSONRPC_INTERNALERROR
      cError.Add("Internal error", "message")
    Default
      cError.Add("Unknown error", "message")
  End Select

  ' Build up the collection - if we are JSON-RPC 2.0
  If iJsonType = 1 Then
    cJsonData.Add(cError, "error")
  Else
    cJsonData.Add("2.0", "jsonrpc")
    cJsonData.Add(cError, "error")
    cJsonData.Add(vId, "id")
  Endif

  Return cJsonData

End

'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
' Convert a JsonCollection to a valid JSON-RPC 2.0 Collection
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Private Sub JsonToRpc(cJsonResponse As Variant, iJsonType As Byte, vId As Variant) As JSONCollection

  Dim cJsonData As New JSONCollection

  ' Build up the collection
  If iJsonType = 1 Then
    cJsonData.Add(cJsonResponse, "result")
  Else
    cJsonData.Add("2.0", "jsonrpc")
    cJsonData.Add(cJsonResponse, "result")
    cJsonData.Add(vId, "id")
  Endif

  Return cJsonData

End

'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
' Handle the JSON-RPC Remote Calls
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Public Sub RemoteCall(sName As String, cData As JSONCollection)

  Dim sParam As String

  ' Set method to private variable for logging purposes
  $sCurrentMethod = sName

  If $bDebug Then
    Try sParam = Util.JSONEncode(cData)

    Main.WriteDebugLog(LogLabel & "Got a RemoteCall for Method '" & sName & "'" & IIf(sParam, ", Params '" & sParam & "'", ""))
  Endif

  ' Create a new JSONCollection object, if it isn't passed
  If Not cData Then
    cData = New JSONCollection
  Endif

  Select LCase(sName)
      ' ### System methods ###
    Case "system.listmethods"
      Call_System_ListMethods()
    Case "system.hostname"
      cData.Add("hostname", "command")
      Call_System_Get(cData)
    Case "system.get"
      Call_System_Get(cData)

      ' ### API methods ###
    Case "api.version"
      Call_API_Version()

      ' ### Generic methods ###
    Case "domotiga.pid"
      cData.Add("pid", "command")
      Call_DomotiGa_Get(cData)
    Case "domotiga.uptime"
      cData.Add("uptime", "command")
      Call_DomotiGa_Get(cData)
    Case "domotiga.version"
      cData.Add("version", "command")
      Call_DomotiGa_Get(cData)
    Case "domotiga.get"
      Call_DomotiGa_Get(cData)

      ' ### Astro methods ###
    Case "astro.get"
      Call_Astro_Get(cData)

      ' ### Data methods ###
    Case "data.newmessage"
      Call_Data_NewMessage()

      ' ### Mode methods ###
    Case "housemode.list"
      Call_HouseMode_List()
    Case "housemode.get"
      Call_HouseMode_Get(cData)
    Case "housemode.set"
      Call_HouseMode_Set(cData)

      ' ### Sound methods ###
    Case "sound.list"
      Call_Sound_List()
    Case "sound.play"
      Call_Sound_Play(cData)
    Case "voicetext.speak"
      Call_VoiceText_Speak(cData)

      ' ### GlobalVar methods ###
    Case "globalvar.list"
      Call_GlobalVar_List()
    Case "globalvar.get"
      Call_GlobalVar_Get(cData)
    Case "globalvar.set"
      Call_GlobalVar_Set(cData)
    Case "globalvar.del"
      Call_GlobalVar_Del(cData)

      ' ### Device methods ###
    Case "device.list"
      Call_Device_List(cData)
    Case "device.get"
      Call_Device_Get(cData)
    Case "device.set"
      Call_Device_Set(cData)

      ' ### Value methods ###
    Case "value.get"
      Call_Value_Get(cData)
    Case "value.set"
      Call_Value_Set(cData)

      ' ## Location methods ###
    Case "location.list"
      Call_Location_List(cData)

      ' ### Plugin methods ###
    Case "plugin.get"
      Call_Plugin_Get(cData)
    Case "plugin.list"
      Call_Plugin_List(cData)
    Case "plugin.restart"
      Call_Plugin_Restart(cData)

      ' ### Message methods ###
    Case "email.send"
      Call_Email_Send(cData)
    Case "twitter.send"
      Call_Twitter_Send(cData)
    Case "sms.send"
      Call_SMS_Send(cData)
    Case "nma.send"
      Call_NMA_Send(cData)
    Case "prowl.send"
      Call_Prowl_Send(cData)
    Case "pushover.send"
      Call_Pushover_Send(cData)

      ' ### Event methods ###
    Case "event.list"
      Call_Event_List(cData)
    Case "event.set"
      Call_Event_Set(cData)
    Case "event.run"
      Call_Event_Run(cData)
    Case "action.list"
      Call_Action_List(cData)
    Case "action.run"
      Call_Action_Run(cData)
    Case "condition.evaluate"
      Call_Condition_Evaluate(cData)
    Case "scene.list"
      Call_Scene_List(cData)
    Case "scene.get"
      Call_Scene_Get(cData)
    Case "scene.run"
      Call_Scene_Run(cData)
    Case "scene.create"
      Call_Scene_Create(cData)
    Case "scene.delete"
      Call_Scene_Delete(cData)

      ' ### SqueezeBox methods ###
    Case "squeezebox.get"
      Call_SqueezeBox_Get(cData)
    Case "squeezebox.set"
      Call_SqueezeBox_Set(cData)

      ' ### RaZberry methods ###
    Case "razberry.updatesready"
      Call_RaZberry_Updatesready(cData)

      ' ### RRDTool methods ### 
    Case "rrdtool.create"
      Call_RRDTool_Create(cData)
    Case "rrdtool.update"
      Call_RRDTool_Update(cData)
    Case "rrdtool.generate"
      Call_RRDTool_Generate(cData)
    Case "rrdtool.deleterrd"
      Call_RRDTool_DeleteRRD(cData)

      ' ### ServerStats methods ###
    Case "serverstat.update"
      Call_ServerStat_Update(cData)

      ' ### DSC Security methods ###
    Case "dsc.setpin"
      Call_DSC_SetPin(cData)
    Case "dsc.setarm"
      Call_DSC_SetArm(cData)

      ' ### LEDMatrix methods ###
    Case "ledmatrix.display"
      Call_LEDMatrix_Display(cData)

      ' ### AVControl methods ###
    Case "avcontrol.get"
      Call_AVControl_Get(cData)
    Case "avcontrol.set"
      Call_AVControl_Set(cData)

      ' ### CUL methods ###
    Case "cul.simulate"
      Call_CUL_Simulate(cData)
    Case "cul.queuecommand"
      Call_CUL_QueueCommand(cData)

      ' ### Calendar methods ###
    Case "calendar.get"
      Call_Calendar_Get()
    Case "calendar.set"
      Call_Calendar_Set(cData)

      ' ### Thermostat methods ###
    Case "thermostat.list"
      Call_Thermostat_List(cData)
    Case "thermostat.derogateheating"
      Call_Thermostat_DerogateHeating(cData)
    Case "thermostat.getderogateheating"
      Call_Thermostat_GetDerogateHeating(cData)

      ' ### Commander methods ###
    Case "cmdr.plcbus.txcommand"
      Call_Cmdr_PLCBus_TxCommand(cData)

      ' ### subscribe methods ###
    Case "subscribe.logupdate"
      Call_Subscribe_LogUpdate()
    Case "subscribe.deviceupdate"
      Call_Subscribe_DeviceUpdate()

      ' ### Tools ###
    Case "tools.openzwave.get"
      Call_Tools_OpenZWave_Get(cData)
    Case "tools.openzwave.set"
      Call_Tools_OpenZWave_Set(cData)
    Case "tools.rfxcom.get"
      Call_Tools_RFXCom_Get(cData)
    Case "tools.rfxcom.set"
      Call_Tools_RFXCom_Set(cData)
    Case "tools.serialport.get"
      Call_Tools_SerialPort_Get(cData)

      ' ### Default - return an error ###
    Default
      SetReply(JSONRPC_METHODNOTFOUND, Null)
      Return
  End Select

Catch
  ' Handle errors - and we *NEED* always send a request
  Main.WriteLog(LogLabel & "ERROR: Method '" & sName & "', '" & Error.Text & "' at '" & Error.Where & "'")
  SetReply(JSONRPC_INTERNALERROR, Null)

End

'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
' Handle SetReply and return it to the hJSONRPC procedure
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Private Sub SetReply(iReply As Integer, vReply As Variant, Optional sError As String = "")

  $iReply = iReply
  $vReply = vReply 

  If $bDebug Then

    If iReply = 0 Then
      Main.WriteDebugLog(LogLabel & "Response for Method '" & $sCurrentMethod & "' Data '" & Util.JSONEncode(vReply) & "'")
    Else
      Main.WriteDebugLog(LogLabel & "Response for Method '" & $sCurrentMethod & "' ErrorCode=" & iReply)
    Endif

    ' Write error to a the logfile, if it contains a value
    If sError Then
      Main.WriteDebugLog(LogLabel & "ERROR: Method '" & $sCurrentMethod & "' - " & sError)
    Endif
  Endif

End

'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
' Check the data received, if it is valid data. The cData has 
' to be a JSONCollection, but cParam needs to be a Collection
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Private Sub CheckParam(cData As JSONCollection, cParam As Collection) As Boolean

  Dim cCol As Collection
  Dim iDataType As Integer
  Dim iInt As Integer

  If Not cData.Count Then
    SetReply(JSONRPC_INVALIDPARAMS, Null, "No params supplied")
    Return False
  Endif

  For Each cCol In cParam

    ' Check if param exists
    If cData.Exist(cParam.Key) Then

      iDataType = TypeOf(cData[cParam.Key])

      ' Check datatype
      Select cCol["datatype"]
        Case "string"
          If iDataType <> gb.String Then
            SetReply(JSONRPC_INVALIDPARAMS, Null, "params '" & cParam.Key & "' is not datatype 'string'")
            Return False 
          Endif
          If cCol.Exist("valuelist") And If Not cCol["valuelist"].Exist(cData[cParam.Key]) Then
            SetReply(JSONRPC_INVALIDPARAMS, Null, "params '" & cParam.Key & "' value isn't in the allowed list of '" & cCol["valuelist"].Join(", ") & "'")
            Return False
          Endif
        Case "integer"
          If iDataType <> gb.Integer And iDataType <> gb.Long And iDataType <> gb.Float Then
            Try iInt = CInt(cData[cParam.Key])
            If Error Then
              SetReply(JSONRPC_INVALIDPARAMS, Null, "params '" & cParam.Key & "' is not datatype 'integer'")
              Return False 
            Endif
            If cCol.Exist("minvalue") And If cCol["minvalue"] > iInt Then
              SetReply(JSONRPC_INVALIDPARAMS, Null, "params '" & cParam.Key & "' has to have a value of " & cCol["minvalue"] & " or higher")
              Return False 
            Endif
            If cCol.Exist("maxvalue") And If cCol["maxvalue"] < iInt Then
              SetReply(JSONRPC_INVALIDPARAMS, Null, "params '" & cParam.Key & "' has to have a value of " & cCol["maxvalue"] & " or lower")
              Return False 
            Endif
          Endif
        Case "numeric"
          If iDataType <> gb.Integer And iDataType <> gb.Long And iDataType <> gb.Float Then
            SetReply(JSONRPC_INVALIDPARAMS, Null, "params '" & cParam.Key & "' is not datatype 'numeric'")
            Return False 
          Endif
        Case "boolean"
          If iDataType <> gb.Boolean Then
            SetReply(JSONRPC_INVALIDPARAMS, Null, "params '" & cParam.Key & "' is not datatype 'boolean'")
            Return False 
          Endif
        Case "object"
          If iDataType <> gb.Object Then
            SetReply(JSONRPC_INVALIDPARAMS, Null, "params '" & cParam.Key & "' is not an array")
            Return False 
          Endif
        Case "any"
          ' Anything allows
      End Select

    Else
      ' Default params are not optional
      If cCol.Exist("optional") Then
        If Not cCol["optional"] Then
          SetReply(JSONRPC_INVALIDPARAMS, Null, "Param '" & cParam.Key & "' not supplied")
          Return False
        Endif
      Else
        SetReply(JSONRPC_INVALIDPARAMS, Null, "Param '" & cParam.Key & "' not supplied")
        Return False
      Endif
    Endif

  Next

  Return True

End

'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
' Check if an instance is present
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Private Sub CheckParamInstance(cData As JSONCollection, sPlugin As String) As Boolean

  Dim iInstanceId As Integer

  If Not cData.Exist("instance_id") Then
    cData["instance_id"] = 1
  Else
    Try iInstanceId = CInt(cData["instance_id"])
    If Error Then
      SetReply(JSONRPC_INVALIDPARAMS, Null, "params 'instance_id' isn't numeric integer")
      Return False
    Endif
    cData["instance_id"] = iInstanceId
    If cData["instance_id"] <= 0 Then
      cData["instance_id"] = 1
    Endif
  Endif

  ' Check if plugin instance really is created
  If Not Plugin.IsPluginEnabled(sPlugin, cData["instance_id"]) Then
    SetReply(0, False, "Plugin '" & sPlugin & "' instance '" & cData["instance_id"] & "' isn't enabled")
    Return False
  Endif

  Return True

End

'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
' Retrieve the "fields" field if it exists. If not existing, return an empty String[]
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Private Sub GetParamFields(cData As JSONCollection, Optional aExtraFields As String[]) As Boolean

  Dim aFields As String[]
  Dim aFieldsExtra As String[]
  Dim iPos As Integer
  Dim sFieldName As String
  Dim sField1, sField2 As String

  If cData And If cData.Exist("fields") Then
    If Object.Type(cData["fields"]) = "String[]" Or If Object.Type(cData["fields"]) = "Variant[]" Then
      Try aFields = cData["fields"] 
      If Error Then
        SetReply(JSONRPC_INVALIDPARAMS, Null, "params 'fields' is not an array of strings")
        Return False
      Endif
      cData["fields"] = aFields.Copy()

      ' Filter possible sub fields
      If aExtraFields Then
        For Each sFieldName In aExtraFields
          If cData["fields"].Exist(sFieldName) Then
            If Not cData.Exist("fields_" & sFieldName) Then
              cData["fields_" & sFieldName] = New String[]
            Endif
            cData["fields"].Remove(cData["fields"].Find(sFieldName))
          Endif
        Next
      Endif

      ' Now filter possible sub fields - like "values:units"
      ' We will create then a "fields_values" with the String[]
      For Each sFieldName In aFields
        iPos = InStr(sFieldName, ":")
        If iPos >= 1 Then
          sField1 = Mid(sFieldName, 1, iPos - 1)
          sField2 = Mid(sFieldName, iPos + 1)
          If Not cData.Exist("fields_" & sField1) Then
            aFieldsExtra = New String[]
            cData.Add(aFieldsExtra, "fields_" & sField1)
          Endif 
          cData["fields_" & sField1].Add(sField2)
          cData["fields"].Remove(cData["fields"].Find(sFieldName))
        Endif
      Next
    Else
      SetReply(JSONRPC_INVALIDPARAMS, Null, "params 'fields' is not an array of strings")
      Return False
    Endif
  Else
    cData["fields"] = New String[]
  Endif

  Return True

End

'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
' Do filtering of fields - trying to keep it generic as possible
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Private Sub FilterFields(iType As Integer, aFields As String[], rResult As Object, cMap As Collection, cValue As JSONCollection) As Boolean

  Dim sAttrName As String
  Dim sKey As String
  Dim vAttrValue As Variant
  Dim hField As ResultField
  Dim mField As String
  Dim cMapReverse As Collection

  ' Just initiate the cMap collection if it isn't used
  If cMap = Null Then cMap = New Collection

  ' We can't work with a Null object - we can't return a String[]
  If aFields = Null Then
    SetReply(JSONRPC_INVALIDPARAMS, Null, "aFields Object is 'Null'")
    Return False
  Endif

  ' If no fields are selected, we automatically select all fields in record/collection
  If aFields.Count = 0 Then

    ' Reverse mapping, else we can easily use it - one time done
    cMapReverse = New Collection
    For Each mField In cMap
      cMapReverse.Add(cMap.Key, mField)
    Next

    Select Object.Type(rResult)
      Case "Result"

        For Each hField In rResult.Fields

          If InStr(hField.Name, ".") Then
            sKey = Mid(hField.Name, RInStr(hField.Name, ".") + 1)
          Else
            sKey = hField.Name
          Endif

          If cMapReverse.Exist(sKey) Then
            sAttrName = cMapReverse[sKey]
          Else
            sAttrName = sKey
          Endif

          ' Skip certain fields
          Select iType
            Case Type_Data_DeviceValue
              Select sAttrName
                Case "id", "device_id"
                  Continue
              End Select
          End Select

          aFields.Add(sAttrName)
        Next

      Case "JSONCollection", "Collection"

        For Each rResult
          sKey = rResult.Key

          If cMapReverse.Exist(sKey) Then
            sAttrName = cMapReverse[sKey]
          Else
            sAttrName = sKey
          Endif

          aFields.Add(sAttrName)
        Next

      Default
        SetReply(JSONRPC_INVALIDPARAMS, Null, "rResult Object.Type is unknown '" & Object.Type(rResult) & "'")
        Return False
    End Select

    ' Add special fields
    Select iType 
      Case Type_Data_Device ' For devices add the icon
        aFields.Add("icon")
      Case Type_Data_DeviceValue ' For corrected values
        aFields.Add("value")
      Case Type_Data_Event
        aFields.Add("actionlist")
    End Select

  Endif

  ' Check if we got a required field list in, else we just do all fields in the table
  For Each sAttrName In aFields

    ' Determine if a mapping is in place
    If cMap.Exist(sAttrName) Then
      sKey = cMap[sAttrName]
    Else
      sKey = sAttrName
    Endif

    ' First we test if the field exists
    Try vAttrValue = rResult[sKey]

    ' We shouldn't run Null, has to be ""
    If TypeOf(vAttrValue) = gb.Null Or If TypeOf(vAttrValue) = gb.Object Then vAttrValue = ""

    ' Somebody passed an invalid field - bail now
    If Error Then
      ' Put exceptions here
      If sKey = "NA" Then
      Else
        SetReply(JSONRPC_INVALIDPARAMS, Null, "Field '" & sAttrName & IIf(cMap.Exist(sAttrName), "/" & sKey, "") & "' doesn't exist in the database")
        Return False
      Endif
    Endif

    ' Override values
    Select sAttrName
      Case "value"
        Try vAttrValue = Devices.CorrectValue(rResult["value"], rResult["correction"], rResult["device_id"])
        If Error Then vAttrValue = ""
      Case "lastchanged" 'last changed
        Try vAttrValue = Replace$(Str$(Format(rResult["lastchanged"], "yyyy-mm-dd hh:nn:ss")), Format(Date(), "yyyy-mm-dd") & " ", "")
        If Error Then vAttrValue = "Never"
      Case "firstseen" 'first seen
        Try vAttrValue = Replace$(Str$(Format(rResult["firstseen"], "yyyy-mm-dd hh:nn:ss")), Format(Date(), "yyyy-mm-dd") & " ", "")
        If Error Then vAttrValue = "Never"
      Case "lastseen" 'last seen
        Try vAttrValue = Replace$(Str$(Format(rResult["lastseen"], "yyyy-mm-dd hh:nn:ss")), Format(Date(), "yyyy-mm-dd") & " ", "")
        If Error Then vAttrValue = "Never"
      Case "icon" 'status icon - only valid for devices table - NOT set, this happens during device values
        vAttrValue = ""
    End Select

    cValue.Add(vAttrValue, sAttrName)
  Next

  Return True

End

'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
' Method=api.version
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Private Sub Call_API_Version()

  SetReply(0, APIVersion)

End

'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
' Method=system.listmethods
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Private Sub Call_System_ListMethods()

  Dim cMethodList As New String[]
  Dim sMethod As String

  For Each sMethod In $cMethods
    cMethodList.Add(sMethod)
  Next

  SetReply(0, cMethodList)

End

'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
' Method=system.get
' Supported command: hostname, ipaddress, architecture, family, gambasversion, user, uptime
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Private Sub Call_System_Get(cData As JSONCollection)

  Dim cValueOut As New JSONCollection
  Dim sStr As String
  Dim lValue As Long

  If Not CheckParam(cData, ["command": ["datatype": "string", "valuelist": ["hostname", "ipaddress", "architecture", "family", "gambasversion", "user", "uptime"]]]) Then Return

  Select cData["command"]
    Case "hostname"
      SetReply(0, System.Host)
    Case "ipaddress"
      SetReply(0, Main.aIPAddr)
    Case "architecture"
      SetReply(0, System.Architecture)
    Case "family"
      SetReply(0, System.Family)
    Case "gambasversion"
      SetReply(0, System.FullVersion)
    Case "user"
      cValueOut.Add(System.User.Name, "username")
      cValueOut.Add(System.User.Id, "uid")
      cValueOut.Add(System.User.Home, "homedir")
      cValueOut.Add(System.User.Group, "gid")
      SetReply(0, cValueOut)
    Case "uptime"
      cValueOut.Add(0, "uptime")
      cValueOut.Add("", "uptime_str")

      Try sStr = File.Load("/proc/uptime")
      If Not Error And If InStr(sStr, ".") Then
        sStr = Left(sStr, InStr(sStr, ".") - 1)
        Try lValue = CLong(sStr)
        If Not Error Then
          cValueOut.Add(lValue, "uptime")
          cValueOut.Add(Main.UptimeString(lValue), "uptime_str")
        Endif
      Endif
      SetReply(0, cValueOut)
   End Select

End

'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
' Method=domotiga.get
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Private Sub Call_DomotiGa_Get(cData As JSONCollection)

  Dim cValueOut As New JSONCollection
  Dim lValue As Long

  If Not CheckParam(cData, ["command": ["datatype": "string", "valuelist": ["servertype", "pid", "uptime", "version"]]]) Then Return

  Select cData["command"]
    Case "servertype"
      SetReply(0, Application.Title)
    Case "pid"
      SetReply(0, Application.Id)
    Case "version"
      SetReply(0, Main.sProgramVersion)
    Case "uptime"
      lValue = DateDiff(Main.GetGlobalVar("Program_Start"), Now(), gb.Second)
      cValueOut.Add(lValue, "uptime")
      cValueOut.Add(Main.UptimeString(lValue), "uptime_str")
      SetReply(0, cValueOut)
  End Select

End

'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
' Method=astro.get
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Private Sub Call_Astro_Get(cData As JSONCollection)

  Dim cValueIn As New Collection
  Dim cValueOut As New JSONCollection

  ' Check for "fields"
  If Not GetParamFields(cData) Then Return

  cValueIn.Add(Main.GetGlobalVar("Sunrise"), "sunrise")
  cValueIn.Add(Main.GetGlobalVar("Sunset"), "sunset")
  cValueIn.Add(Main.GetGlobalVar("Sunrise_Twilight"), "sunrise_twilight")
  cValueIn.Add(Main.GetGlobalVar("Sunset_Twilight"), "sunset_twilight")
  cValueIn.Add(Main.iAstroLatitude, "latitude")
  cValueIn.Add(Main.iAstroLongitude, "longitude")
  cValueIn.Add(Main.fAstroAutoTimezone, "timezone")
  cValueIn.Add(Main.sAstroAutoTimezoneName, "timezonename")

  If Not FilterFields(Type_Data_None, cData["fields"], cValueIn, Null, cValueOut) Then Return

  SetReply(0, cValueOut)

End

'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
' Method=housemode.list
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Private Sub Call_HouseMode_List()

  Dim aValue As New String[]
  Dim rResult As Result

  rResult = Main.hDB.Exec("SELECT * FROM config_housemode ORDER BY name")

  If rResult And If rResult.Available Then
    For Each rResult
      If rResult!name Then
        aValue.Add(rResult!name)
      Endif
    Next
  Endif

  SetReply(0, aValue)

End

'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
' Method=housemode.get
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Private Sub Call_HouseMode_Get(cData As JSONCollection)

  Dim cValueIn As New JSONCollection
  Dim cValueOut As New JSONCollection

  ' Check for "fields"
  If Not GetParamFields(cData) Then Return

  cValueIn.Add(Main.GetGlobalVar("House_Mode"), "mode")
  cValueIn.Add(Main.GetGlobalVar("Mute"), "mute")

  If Not FilterFields(Type_Data_None, cData["fields"], cValueIn, Null, cValueOut) Then Return

  SetReply(0, cValueOut)

End

'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
' Method=housemode.set
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Private Sub Call_HouseMode_Set(cData As JSONCollection)

  If Not cData.Count Then
    SetReply(JSONRPC_INVALIDPARAMS, Null, "params 'mode' or 'mute' is missing")
    Return
  Endif

  If Not CheckParam(cData, ["mode": ["datatype": "string", "optional": True], "mute": ["datatype": "boolean", "optional": True]]) Then Return

  SetReply(0, False)

  If cData.Exist("mode") Then
    Main.SetGlobalVar("House_Mode", cData["mode"])
    SetReply(0, True)
  Endif

  If cData.Exist("mute") Then
    Main.SetGlobalVar("Mute", cData["mute"])
    SetReply(0, True)
  Endif

End

'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
' Method=sound.list
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Private Sub Call_Sound_List()

  ' fill array with available sounds
  SetReply(0, Dir(Main.sBaseDir &/ "sounds", "*.wav"))

End

'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
' Method=sound.play
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Private Sub Call_Sound_Play(cData As JSONCollection)

  Dim bReturn As Boolean

  If Not CheckParam(cData, ["file": ["datatype": "string"], "volume": ["datatype": "integer", "minvalue": 0, "maxvalue": 100, "optional": True]]) Then Return

  ' If no volume is specific, don't specify anything (=system default)
  If cData.Exist("volume") Then
    Try bReturn = Sounds.PlaySnd(cData["file"], cData["volume"])
  Else
    Try bReturn = Sounds.PlaySnd(cData["file"])
  Endif

  SetReply(0, bReturn)

End

'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
' Method=voicetext.speak
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Private Sub Call_VoiceText_Speak(cData As JSONCollection)
  
  Dim bReturn As Boolean

  If Not CheckParam(cData, ["text": ["datatype": "string"], "voice": ["datatype": "string", "optional": True]]) Then Return

  ' If no volume is specific, don't specify anything (=system default)
  If cData.Exist("voice") Then
    Try bReturn = VoiceText.Speak(cData["text"], cData["voice"])
  Else
    Try bReturn = VoiceText.Speak(cData["text"])
  Endif

  SetReply(0, bReturn)

End

'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
' Method=globalvar.list
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Private Sub Call_GlobalVar_List()

  Dim cGV As CGlobalVarEntry
  Dim cValue As New JSONCollection

  For Each cGV In Main.GlobalVar
    If cGV.Value = Null Then
      cValue.Add("", Main.GlobalVar.Key)
    Else
      cValue.Add(cGV.Value, Main.GlobalVar.Key)
    Endif
  Next

  SetReply(0, cValue)

End

'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
' Method=globalvar.get
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Private Sub Call_GlobalVar_Get(cData As JSONCollection)

  Dim vValue As Variant

  If Not CheckParam(cData, ["name": ["datatype": "string"]]) Then Return

  If Main.GlobalVar.Exist(cData["name"]) Then
    vValue = Main.GlobalVar[cData["name"]].Value
    SetReply(0, vValue)
  Else
    SetReply(-1, Null)
  Endif

End

'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
' Method=globalvar.set
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Private Sub Call_GlobalVar_Set(cData As JSONCollection)

  Dim iDataType As Integer = 0
  Dim vValue As Variant
  Dim bOk As Boolean

  If Not CheckParam(cData, ["name": ["datatype": "string"], "value": ["datatype": "any"], "datatype": ["datatype": "string", "optional": True]]) Then Return

  vValue = cData["value"]

  Select LCase(cData["datatype"])
    Case "boolean"
      iDataType = gb.Boolean
    Case "number", "numeric", "integer"
      iDataType = gb.Float
    Case "string"
      iDataType = gb.String
    Default
      ' Do nothing, parameter is optional
  End Select

  If Main.GlobalVar.Exist(cData["name"]) Then

    ' Check if somebody wants to set a ReadOnly variable
    If Main.GlobalVar[cData["name"]].ReadOnly Then
      SetReply(0, False, "params 'name'='" & cData["name"] & "' is a read-only variable")
      Return
    Endif

    If iDataType <> 0 Then Main.GlobalVar[cData["name"]].DataType = iDataType
  Endif

  ' Convert the input to the correct datatype
  Select iDataType
    Case gb.Boolean ' JSON Boolean
      If TypeOf(vValue) = gb.String Then
        If UCase(vValue) = "TRUE" Or If UCase(vValue) = "T" Or If (vValue) = "1" Then
          vValue = True
        Else
          vValue = False
        Endif
      Else
        Try vValue = CBool(CInt(vValue))
        If Error Then
          SetReply(JSONRPC_INVALIDPARAMS, Null, "params 'value' cannot be converted to boolean")
          Return
        Endif
      Endif

    Case gb.Byte, gb.Short, gb.Integer, gb.Long, gb.Single, gb.Float ' JSON Numeric

      ' Convert it first to Float datatype
      If TypeOf(vValue) = gb.String Then vValue = Replace(vValue, ",", ".")
      Try vValue = CFloat(vValue)
      If Error Then
        SetReply(JSONRPC_INVALIDPARAMS, Null, "params 'value' cannot be converted to float")
        Return
      Endif
      iDataType = gb.Float

      ' Convert to Integer if it is a whole number
      If CInt(vValue) = vValue Then
        Try vValue = CInt(vValue)
        iDataType = gb.Integer
      Endif

    Case gb.Date
      Try vValue = CDate(vValue)
      If Error Then
        SetReply(JSONRPC_INVALIDPARAMS, Null, "params 'value' cannot be converted to date")
        Return
      Endif

    Case gb.String
      Try vValue = CStr(vValue)
      If Error Then
        SetReply(JSONRPC_INVALIDPARAMS, Null, "params 'value' cannot be converted to string")
        Return
      Endif

  End Select

  bOk = Main.SetGlobalVar(cData["name"], vValue)

  If bOk Then
    SetReply(0, True)
  Else
    SetReply(0, False, "params 'name'='" & cData["name"] & "' cannot be changed (enable debug GlobalVar for more info)")
  Endif

End

'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
' Method=globalvar.del
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Private Sub Call_GlobalVar_Del(cData As JSONCollection)

  If Not CheckParam(cData, ["name": ["datatype": "string"]]) Then Return

  ' Check if somebody wants to set a ReadOnly variable
  If Main.GlobalVar.Exist(cData["name"]) Then
    If Main.GlobalVar[cData["name"]].SystemVar Then
      SetReply(0, False, "params 'name'='" & cData["name"] & "' is a system variable, can't be deleted")
      Return
    Endif
  Endif

  Try Main.DelGlobalVar(cData["name"])
  SetReply(0, True)

End

'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
' Method=device.set
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Private Sub Call_Device_Set(cData As JSONCollection)

  ' Check the device_id and valuenum fields
  If Not CheckParam(cData, ["device_id": ["datatype": "integer"], "valuenum": ["datatype": "integer", "minvalue": 1, "optional": True], "value": ["datatype": "any"]]) Then Return

  If Devices.SetDevice(cData["device_id"], cData["value"], IIf(cData.Exist("valuenum"), cData["valuenum"], 1)) Then
    SetReply(0, True)
  Else
    SetReply(0, False)
  Endif

End

'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
' Method=device.list
' Returns: Array
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Private Sub Call_Device_List(cData As JSONCollection)

  Dim cDevice As New JSONCollection
  Dim aDevices As New Collection[]
  Dim cValue As New JSONCollection
  Dim aValues As Object
  Dim rResult As Result
  Dim rResultValues As Result
  Dim iGrp As Integer
  Dim sList As String
  Dim MapField As New Collection
  Dim MapFieldValues As New Collection
  Dim GetGroup As New String[]
  Dim GetLocation As New Integer[]
  Dim bFound As Boolean

  ' Mapping of attribute names from SQL to JSON. Hopefully to be removed in the future
  MapField.Add("id", "device_id")
  MapField.Add("poll", "disablepoll")
  MapField.Add("NA", "icon")

  MapFieldValues.Add("value", "rawvalue")
  MapFieldValues.Add("NA", "value")

  ' Determine if we got a "list" parameter/value
  If cData["list"] <> Null And If TypeOf(cData["list"]) <> gb.String Then
    SetReply(JSONRPC_INVALIDPARAMS, Null, "params 'list' is not a string")
    Return
  Endif

  sList = cData["list"]
  If sList = "" Then
    sList = "enabled"
  Endif

  ' Check for "fields"
  If Not GetParamFields(cData, ["values"]) Then Return

  ' Detect if the "groups" parameter is supplied, it has to be an array of strings
  If cData["groups"] <> Null And If TypeOf(cData["groups"]) = gb.Object Then
    Try GetGroup = cData["groups"]
    If Error Then
      SetReply(JSONRPC_INVALIDPARAMS, Null, "params 'groups' is not an array of strings")
      Return
    Endif
  Endif

  ' Detect if the "locations" parameter is supplied, it has to be an array of integers
  If cData["locations"] <> Null And If TypeOf(cData["locations"]) = gb.Object Then
    Try GetLocation = cData["locations"]
    If Error Then
      SetReply(JSONRPC_INVALIDPARAMS, Null, "params 'locations' is not an array of strings")
      Return
    Endif
  Endif

    ' Get ValuesFormat item, used to format the values in array (default) or hash
  If cData["valuesformat"] <> Null And If TypeOf(cData["valuesformat"]) <> gb.String Then
    SetReply(JSONRPC_INVALIDPARAMS, Null, "params 'valuesformat' is not a string")
    Return
  Endif

  ' If we got a field list, we don't know what to retrieve exactly, so we will do it all
  If cData["fields"].Count >= 1 Then
    sList &= "+ext"
  Endif

  ' Retrieve the information from the database
  rResult = Devices.GetDeviceList(sList)
  If Not rResult Or If Not rResult.Available Then
    Main.WriteLog(LogLabel & "ERROR: No devices found in table 'devices'! (Call_Device_List)")
    SetReply(0, aDevices)
    Return
  Endif

  ' If we didn't get a field list, use the defaults
  If cData["fields"].Count = 0 Then
    If InStr(sList, "ext") Then
      cData["fields"] = ["device_id", "name", "icon", "lastseen", "enabled", "hide", "dimable", "switchable", "batterystatus", "location_id", "locationname", "floorplan_id", "floorplanname", "floorplanimage", "x", "y", "devicetype_id", "devicetypename", "interface_id", "interfacename", "groups"]
      cData["fields_values"] = New String[]
    Else
      cData["fields"] = ["device_id", "name", "icon", "lastseen", "enabled", "hide", "dimable", "switchable", "batterystatus", "location_id", "locationname"]
      cData["fields_values"] = ["valuenum", "value", "units"]
    Endif
  Else
    ' If get "ALL", then just return all device+value fields
    If cData["fields"].Count = 1 And If cData["fields"].Exist("ALL") Then
      cData["fields"] = New String[]
      cData["fields_values"] = New String[]
    Else
      If Not cData.Exist("fields_values") Then
        cData["fields_values"] = New String[]
      Endif
    Endif
  Endif

  For Each rResult

    cDevice = New JSONCollection

    ' If a group or groups are supplied, filter on them
    If GetGroup.Count >= 1 Then
      bFound = False

      For iGrp = 0 To (GetGroup.Count - 1)
        If InStr(rResult!groups, "|" & GetGroup[iGrp] & "|") Then bFound = True
      Next

      If Not bFound Then Continue
    Endif

    ' If a location or locations are supplied, filter on them
    If GetLocation.Count >= 1 Then
      If Not GetLocation.Exist(rResult!location_id) Then Continue
    Endif

    ' Filter out the fields - if get get a False, an error happened
    If Not FilterFields(Type_Data_Device, cData["fields"], rResult, MapField, cDevice) Then Return

    ' Add device values
    If cData["valuesformat"] = "hash" Then
      aValues = New JSONCollection
    Else
      aValues = New Collection[]
    Endif

    rResultValues = Devices.GetValues(["device_id": rResult!id, "sortOrder": "valuenum"])
    For Each rResultValues
      cValue = New JSONCollection

      FilterFields(Type_Data_DeviceValue, cData["fields_values"], rResultValues, MapFieldValues, cValue) 
      If cData["valuesformat"] = "hash" Then
        aValues.Add(cValue, rResultValues!valuenum)
      Else
        aValues.Add(cValue)
      Endif

      ' Overrule the icon value if we have valuenum 1
      If rResultValues!valuenum = 1 Then
        Try cDevice.Add(Devices.GetStatusIcon(rResultValues!value, rResult!onicon, rResult!officon, rResult!dimicon), "icon")
      Endif
    Next

    cDevice.Add(aValues, "values")

    ' Finished, now add the device to the output list
    aDevices.Add(cDevice)
  Next

  SetReply(0, aDevices)

End

'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
' Method=device.get
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Private Sub Call_Device_Get(cData As JSONCollection)

  Dim cValue As New JSONCollection
  Dim cValueValue As New JSONCollection
  Dim aValueValue As New Collection[]
  Dim GetFieldValues As New String[]
  Dim rResult As Result
  Dim rResultValues As Result
  Dim MapField As New Collection
  Dim MapFieldValues As New Collection

  ' Mapping of attribute names from SQL to JSON. Hopefully to be removed in the future
  MapField.Add("id", "device_id")
  MapField.Add("poll", "disablepoll")
  MapField.Add("NA", "icon")

  MapFieldValues.Add("value", "rawvalue")
  MapFieldValues.Add("NA", "value")

  If Not CheckParam(cData, ["device_id": ["datatype": "integer"]]) Then Return

  ' Check for "fields"
  If Not GetParamFields(cData) Then Return

  ' Retrieve the information from the database, we will filter out in the next steps
  rResult = Devices.GetDeviceList("all+ext")

  If Not rResult Or If Not rResult.Available Then
    Main.WriteLog(LogLabel & "ERROR: No devices found in table 'devices'!")
    SetReply(0, cValue)
    Return
  Endif

  ' If we got ALL, then clear the String[], it will be populated by FilterFields automatically
  If cData["fields"].Count = 1 And If cData["fields"].Exist("ALL") Then
    cData["fields"].Clear
  Endif

  For Each rResult
    If cData["device_id"] = rResult!id Then
      ' Filter out the fields - if get get a False, an error happened
      If Not FilterFields(Type_Data_Device, cData["fields"], rResult, MapField, cValue) Then Return
      Break
    Endif

  Next

  ' Add device values
  aValueValue = New Collection[]
  rResultValues = Devices.GetValues(["device_id": cData["device_id"], "sortOrder": "valuenum"])

  If rResultValues And If rResultValues.Available Then
    For Each rResultValues
      cValueValue = New JSONCollection

      FilterFields(Type_Data_DeviceValue, GetFieldValues, rResultValues, MapFieldValues, cValueValue) 

      ' Overrule the icon value if we have valuenum 1
      If rResultValues!valuenum = 1 Then
        cValue.Add(Devices.GetStatusIcon(rResultValues!value, rResult!onicon, rResult!officon, rResult!dimicon), "icon")
      Endif

      aValueValue.Add(cValueValue)
    Next
  Endif

  cValue.Add(aValueValue, "values")

  SetReply(0, cValue)

End

'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
' Method=value.get
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Private Sub Call_Value_Get(cData As JSONCollection)

  Dim rResult As Result
  Dim MapField As New Collection
  Dim aValue As New Collection[]
  Dim cValue As JSONCollection

  ' Mapping of attribute names from SQL to JSON. Hopefully to be removed in the future
  MapField.Add("value", "rawvalue")
  MapField.Add("NA", "value")

  If Not CheckParam(cData, ["device_id": ["datatype": "integer"], "valuenum": ["datatype": "integer", "minvalue": 1], "command": ["datatype": "string", "valuelist": ["value", "log"], "optional": True], "timestamp": ["datatype": "string", "optional": True], "count": ["datatype": "integer", "optional": True]]) Then Return

  ' Check for "fields"
  If Not GetParamFields(cData) Then Return

  ' Set the command=value as default, if no parameter is supplied
  If Not cData.Exist("command") Then cData["command"] = "value"

  ' Determine if we got a timestamp or count
  If Not cData.Exist("timestamp") And If Not cData.Exist("count") Then cData["count"] = 100

  ' Remove the count if -1 is specified, then we just give all the entries
  If cData.Exist("count") And If cData["count"] = -1 Then cData.Remove("count")

  ' Do right command, only value and log are supported
  Select cData["command"]
    Case "value"
      rResult = Devices.GetValues(["device_id": cData["device_id"], "sortOrder": "valuenum"])

      cValue = New JSONCollection

      If rResult And If rResult.Available Then
        For Each rResult

          If cData["valuenum"] = rResult!valuenum Then
            FilterFields(Type_Data_DeviceValue, cData["fields"], rResult, MapField, cValue)
            Break
          Endif

        Next
      Endif

      SetReply(0, cValue)

    Case "log"
      If cData["fields"].Count = 0 Then
        cData["fields"] = ["log_id", "value", "rawvalue", "lastchanged"]
      Endif

      rResult = Devices.Get_Device_Values_Log(cData)

      If rResult And If rResult.Available Then
        For Each rResult
          cValue = New JSONCollection
          FilterFields(Type_Data_DeviceValue, cData["fields"], rResult, MapField, cValue) 
          aValue.Add(cValue)
        Next
      Endif

      SetReply(0, aValue)

  End Select

End

'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
' Method=value.set
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Private Sub Call_Value_Set(cData As JSONCollection)

  ' Check the device_id and valuenum fields
  If Not CheckParam(cData, ["device_id": ["datatype": "integer"], "valuenum": ["datatype": "integer", "minvalue": 1, "optional": True], "value": ["all": True]]) Then Return

  If Devices.ValueUpdate(cData["device_id"], IIf(cData.Exist("valuenum"), cData["valuenum"], 1), cData["value"]) Then
    SetReply(0, True)
  Else
    SetReply(0, False)
  Endif

End

'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
' Method=location.list
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Private Sub Call_Location_List(cData As JSONCollection)

  Dim cValue As New JSONCollection
  Dim aValue As New Collection[]
  Dim rResult As Result
  Dim MapField As New Collection

  MapField.Add("id", "location_id")

  If Not GetParamFields(cData) Then Return

  rResult = Devices.GetLocationList()
  If Not rResult Or If Not rResult.Available Then
    Main.WriteLog(LogLabel & "ERROR: No locations found in table 'locations'!")
    SetReply(0, aValue)
    Return
  Endif

  ' Filter out the fields - if get get a False, an error happened
  For Each rResult
    cValue = New JSONCollection
    If Not FilterFields(Type_Data_Location, cData["fields"], rResult, MapField, cValue) Then Return
    aValue.Add(cValue)
  Next

  SetReply(0, aValue)

End

'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
' Method=plugin.get
' Also used by Call_Plugin_List
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Private Sub Call_Plugin_Get(cData As JSONCollection, Optional cPl As CPluginEntry) As JSONCollection

  Dim cValueIn As New JSONCollection
  Dim cValueOut As New JSONCollection
  Dim bList As Boolean
  Dim bFound As Boolean

  bList = cPl

  ' If we got a cPl, it is passed via "Call_Plugin_List"
  If bList Then
    bFound = True
  Else
    ' Check for "fields"
    If Not GetParamFields(cData) Then Return Null

    If Not CheckParam(cData, ["name": ["datatype": "string"], "instance_id": ["datatype": "integer", "minvalue": 1]]) Then Return Null

    ' Loop through all plugins
    For Each cPl In Plugin.cPluginList

      If cPl.Instance = 0 Then Continue
      If cPl.Name = cData["name"] And If cPl.Instance = cData["instance_id"] Then
        bFound = True
        Break
      Endif
    Next

  Endif

  If bFound Then
    cValueIn = New JSONCollection
    cValueOut = New JSONCollection

    cValueIn.Add(cPl.name, "name")
    cValueIn.Add(cPl.Instance, "instance_id")
    cValueIn.Add(cPl.Settings["enabled"], "enabled")

    If cPl.Interface Then
      Try cValueIn.Add(cPl.Interface.IsRunning, "running")
      If Error Then cValueIn.Add(False, "running")
      Try cValueIn.Add(cPl.Interface.ErrorText, "error")
      If Error Then cValueIn.Add("UNKNOWN", "error")
      Try cValueIn.Add(cPl.Interface.ErrorWhere, "error")
      If Error Then cValueIn.Add("UNKNOWN", "errorwhere")
      Try cValueIn.Add(cPl.Interface.PluginFriendlyName, "friendlyname")
      If Error Then cValueIn.Add("", "friendlyname")
      Try cValueIn.Add(cPl.Interface.PluginVersion, "version")
      If Error Then cValueIn.Add("", "version")
      Try cValueIn.Add(cPl.Interface.PluginAuthor, "author")
      If Error Then cValueIn.Add("", "author")
      Try cValueIn.Add(cPl.Interface.PluginMaxInstances, "maxinstances")
      If Error Then cValueIn.Add(0, "maxinstances")
    Else
      cValueIn.Add(False, "running")
      cValueIn.Add("", "error")
      cValueIn.Add("", "errorwhere")
      cValueIn.Add("", "friendlyname")
      cValueIn.Add("", "version")
      cValueIn.Add("", "author")
      cValueIn.Add(0, "maxinstances")
    Endif

    If Not FilterFields(Type_Data_None, cData["fields"], cValueIn, Null, cValueOut) Then Return Null
  Endif

  If bList Then
    Return cValueOut
  Else
    SetReply(0, cValueOut)
  Endif

End

'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
' Method=plugin.list
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Private Sub Call_Plugin_List(cData As JSONCollection)

  Dim cPl As CPluginEntry
  Dim cValueOut As New JSONCollection
  Dim aValue As New Collection[]

  ' Check for "fields"
  If Not GetParamFields(cData) Then Return

  ' Loop through all plugins
  For Each cPl In Plugin.cPluginList

    If cPl.Instance = 0 Then Continue

    cValueOut = Call_Plugin_Get(cData, cPl)
    If Not cValueOut Then Return

    aValue.Add(cValueOut)
  Next

  SetReply(0, aValue)

End

'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
' Method=plugin.restart
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Private Sub Call_Plugin_Restart(cData As JSONCollection)

  If Not CheckParam(cData, ["name": ["datatype": "string"], "instance_id": ["datatype": "integer", "minvalue": 1, "optional": True]]) Then Return

  ' If we restart the json-rpc one, we need to delay - else we shoot ourselves in the head
  If UCase(cData["name"]) = "JSONRPC" Then
    Plugin.RestartDelay(cData["name"], IIf(cData.Exist("instance_id"), cData["instance_id"], 1))
  Else
    Plugin.Restart(cData["name"], IIf(cData.Exist("instance_id"), cData["instance_id"], 1))
  Endif

  SetReply(0, True)

End

'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
' Method=email.send
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Private Sub Call_Email_Send(cData As JSONCollection)

  If Not CheckParam(cData, ["subject": ["datatype": "string"], "msg": ["datatype": "string"], "to": ["datatype": "string", "optional": True]]) Then Return

  If Mail.SendMail(cData["subject"], cData["msg"], cData["to"]) Then
    SetReply(0, True)
  Else
    SetReply(0, False)
  Endif

End

'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
' Method=twitter.send
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Private Sub Call_Twitter_Send(cData As JSONCollection)

  Dim bOk As Boolean

  If Not CheckParam(cData, ["msg": ["datatype": "string"], "instance": ["datatype": "integer", "minvalue": 1, "optional": True]]) Then Return
  If Not CheckParamInstance(cData, "Twitter") Then Return

  Try bOk = Plugin.GetPluginObject("Twitter", cData["instance"]).Interface.PostTweet(cData["msg"])
  If Error Or If Not bOk Then
    SetReply(0, False)
  Else
    SetReply(0, True)
  Endif

End

'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
' Method=sms.send
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Private Sub Call_SMS_Send(cData As JSONCollection)

  Dim bOk As Boolean

  If Not CheckParam(cData, ["msg": ["datatype": "string"], "to": ["datatype": "string"], "instance": ["datatype": "integer", "minvalue": 1, "optional": True]]) Then Return
  If Not CheckParamInstance(cData, "SMS") Then Return

  Try bOk = Plugin.GetPluginObject("SMS", cData["instance_id"]).Interface.SendSMS(cData["msg"], cData["to"])
  If Error Or If Not bOk Then
    SetReply(0, False)
  Else
    SetReply(0, True)
  Endif

End

'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
' Method=nma.send
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Private Sub Call_NMA_Send(cData As JSONCollection)

  Dim bOk As Boolean

  If Not CheckParam(cData, ["msg": ["datatype": "string"], "application": ["datatype": "string", "optional": True], "event": ["datatype": "string", "optional": True], "instance": ["datatype": "integer", "minvalue": 1, "optional": True]]) Then Return
  If Not CheckParamInstance(cData, "NMA") Then Return

  ' Check the priority
  If cData["priority"] <> "" Then
    If cData["priority"] = "normal" Or If cData["priority"] = "0" Then cData["priority"] = ""
    If cData["priority"] = "lowest" Then cData["priority"] = "-2"
    If cData["priority"] = "verylow" Then cData["priority"] = "-2"
    If cData["priority"] = "low" Then cData["priority"] = "-1"
    If cData["priority"] = "moderate" Then cData["priority"] = "-1"
    If cData["priority"] = "high" Then cData["priority"] = "1"
    If cData["priority"] = "emergency" Then cData["priority"] = "2"

    Select cData["priority"]
      Case "", "-2", "-1", "1", "2"
        ' Valid priorities
      Default
        SetReply(JSONRPC_INVALIDPARAMS, Null, "params 'priority' has an invalid value")
        Return
    End Select
  Endif

  Try bOk = Plugin.GetPluginObject("NMA", cData["instance_id"]).Interface.PostNMA(cData["application"], cData["event"], cData["msg"], cData["priority"])
  If Error Or If Not bOk Then
    SetReply(0, False)
  Else
    SetReply(0, True)
  Endif
  
End

'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
' Method=prowl.send
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Private Sub Call_Prowl_Send(cData As JSONCollection)

  Dim bOk As Boolean

  If Not CheckParam(cData, ["msg": ["datatype": "string"], "application": ["datatype": "string", "optional": True], "event": ["datatype": "string", "optional": True], "instance": ["datatype": "integer", "minvalue": 1, "optional": True]]) Then Return
  If Not CheckParamInstance(cData, "Prowl") Then Return

  Try bOk = Plugin.GetPluginObject("Prowl", cData["instance_id"]).Interface.PostProwl(cData["application"], cData["event"], cData["msg"])
  If Error Or If Not bOk Then
    SetReply(0, False)
  Else
    SetReply(0, True)
  Endif

End

'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
' Method=pushover.send
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Private Sub Call_Pushover_Send(cData As JSONCollection)

  Dim bOk As Boolean
  Dim bSound As Boolean

  If Not CheckParam(cData, ["msg": ["datatype": "string"], "device": ["datatype": "string", "optional": True], "priority": ["datatype": "string", "optional": True], "sound": ["datatype": "string", "optional": True], "instance": ["datatype": "integer", "minvalue": 1, "optional": True]]) Then Return
  If Not CheckParamInstance(cData, "Pushover") Then Return

  ' Check if it is in the allowed list
  If cData["sound"] <> "" Then
    Try bSound = Plugin.GetPluginObject("Pushover", cData["instance_id"]).Interface.Sound_List.Exist(cData["sound"])
    If Not bSound Or If cData["sound"] = "pushover (default)" Then
      SetReply(JSONRPC_INVALIDPARAMS, Null, "params 'sound' has an invalid value")
      Return
    Endif 
  Endif
  
  ' Check the priority
  If cData["priority"] <> "" Then
    If cData["priority"] = "normal" Or If cData["priority"] = "0" Then cData["priority"] = ""
    If cData["priority"] = "lowest" Then cData["priority"] = "-2"
    If cData["priority"] = "verylow" Then cData["priority"] = "-2"
    If cData["priority"] = "low" Then cData["priority"] = "-1"
    If cData["priority"] = "high" Then cData["priority"] = "1"
    If cData["priority"] = "emergency" Then cData["priority"] = "2"
    
    Select cData["priority"]
      Case "", "-2", "-1", "1", "2"
        ' Valid priorities
      Default
        SetReply(JSONRPC_INVALIDPARAMS, Null, "params 'priority' has an invalid value")
        Return
    End Select
  Endif

  Try bOk = Plugin.GetPluginObject("Pushover", cData["instance_id"]).Interface.PostPushover(cData["device"], cData["msg"], cData["priority"], cData["sound"])
  If Error Or If Not bOk Then
    SetReply(0, False)
  Else
    SetReply(0, True)
  Endif

End

'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
' Method=event.list
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Private Sub Call_Event_List(cData As JSONCollection)

  Dim aValue As New Collection[]
  Dim cValue As New JSONCollection
  Dim cValueAction As New JSONCollection
  Dim aValueAction As New Collection[]
  Dim rResult As Result
  Dim rResultAction As Result
  Dim MapField As New Collection

  ' Mapping of attribute names from SQL to JSON. Hopefully to be removed in the future
  MapField.Add("id", "event_id")
  MapField.Add("NA", "actionlist")

  ' Check for "fields"
  If Not GetParamFields(cData) Then Return

  rResult = Events.GetEventList()
  If Not rResult Or If Not rResult.Available Then
    Main.WriteLog(LogLabel & "ERROR: No events found in table 'events'!")
    SetReply(0, aValue)
    Return
  Endif

  For Each rResult
    cValue = New JSONCollection

    ' Filter out the fields - if get get a False, an error happened
    If Not FilterFields(Type_Data_Event, cData["fields"], rResult, MapField, cValue) Then Return

    ' Add the action list - Only actionid & order, delay doesn't seem to be used?
    If cData["fields"].Exist("actionlist") Then

      rResultAction = Events.GetEventActionList(rResult!id)

      aValueAction = New Collection[]

      If rResult And If rResult.Available Then
        For Each rResultAction
          cValueAction = New JSONCollection
          cValueAction.Add(rResultAction!action, "action_id")
          cValueAction.Add(rResultAction!order, "order")
          aValueAction.Add(cValueAction)
        Next
      Endif

      cValue.Add(aValueAction, "actionlist")
    Endif

    aValue.Add(cValue)

  Next

  SetReply(0, aValue)

End


'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
' Method=event.set
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Private Sub Call_Event_Set(cData As JSONCollection)

  If Not CheckParam(cData, ["event_id": ["datatype": "integer"], "enabled": ["datatype": "boolean"]]) Then Return

  If Events.ChangeEventState(cData["event_id"], cData["enabled"]) Then
    SetReply(0, True)
  Else
    SetReply(0, False)
  Endif

End

'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
' Method=event.run
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Private Sub Call_Event_Run(cData As JSONCollection)

  If Not CheckParam(cData, ["event_id": ["datatype": "integer"]]) Then Return

  If Events.RunActions(cData["event_id"]) Then
    SetReply(0, True)
  Else
    SetReply(0, False)
  Endif

End

'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
' Method=action.list
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Private Sub Call_Action_List(cData As JSONCollection)

  Dim cValue As New JSONCollection
  Dim aValue As New Collection[]
  Dim rResult As Result
  Dim MapField As New Collection

  ' Mapping of attribute names from SQL to JSON. Hopefully to be removed in the future
  MapField.Add("id", "action_id")

  ' Check for "fields"
  If Not GetParamFields(cData) Then Return

  rResult = Events.GetActionList()
  If Not rResult Or If Not rResult.Available Then
    Main.WriteLog(LogLabel & "ERROR: No actions found in table 'actions'!")
    SetReply(0, aValue)
    Return
  Endif

  ' Filter out the fields - if get get a False, an error happened
  For Each rResult
    cValue = New JSONCollection
    If Not FilterFields(Type_Data_Action, cData["fields"], rResult, MapField, cValue) Then Return
    aValue.Add(cValue)
  Next

  SetReply(0, aValue)

End

'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
' Method=action.run
' We support the action_id, then it needs to be in the database, or we supply all relevant parameters
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Private Sub Call_Action_Run(cData As JSONCollection)

  If Not CheckParam(cData, ["action_id": ["datatype": "integer", "optional": True], "type": ["datatype": "integer", "optional": True]]) Then Return

  If cData.Exist("action_id") Then
    Try Events.RunAction(cData["action_id"], 0, 0)
    If Error Then
      Main.WriteDebugLog(LogLabel & "ERROR: '" & Error.Text & "' at '" & Error.Where & "' when running action!")
      SetReply(0, False)
    Else
      SetReply(0, True)
    Endif
  Else
    Try Events.RunAction(0, 0, 0, cData)
    If Error Then
      Main.WriteDebugLog(LogLabel & "ERROR: '" & Error.Text & "' at '" & Error.Where & "' when running action!")
      SetReply(0, False)
    Else
      SetReply(0, True)
    Endif
  Endif

End

'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
' Method=condition.evaluate
' Evaluate the expression on the Server, because it can't be done on the Client
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Private Sub Call_Condition_Evaluate(cData As JSONCollection)

  Dim sEval As String

  If Not CheckParam(cData, ["evaluate": ["all": True]]) Then Return

  If cData["evaluate"] Then
    sEval = Events.EvalFormula(cData["evaluate"])
    SetReply(0, sEval)
  Else
    SetReply(0, "")
  Endif

End

'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
' Method=scene.get
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Private Sub Call_Scene_Get(cData As JSONCollection)

  Dim rResult As Result
  Dim cValueOut As New JSONCollection

  ' Check for "fields"
  If Not GetParamFields(cData) Then Return
  If Not CheckParam(cData, ["scene_id": ["datatype": "integer"]]) Then Return

  rResult = Scenes.GetScenesList(["scene_id": cData["scene_id"]])
  If rResult And If rResult.Available Then
    If Not FilterFields(Type_Data_Scene, cData["fields"], rResult, Null, cValueOut) Then Return
  Endif

  SetReply(0, cValueOut)

End

'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
' Method=scene.list
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Private Sub Call_Scene_List(cData As JSONCollection)

  Dim rResult As Result
  Dim cValueOut As New JSONCollection
  Dim aValue As New Collection[]
  Dim MapField As New Collection

  ' Check for "fields"
  If Not GetParamFields(cData) Then Return

  rResult = Scenes.GetScenesList()
  If Not rResult Or If Not rResult.Available Then
    Main.WriteLog(LogLabel & "ERROR: No scenes found in table 'scenes'!")
    SetReply(0, aValue)
    Return
  Endif

  For Each rResult
    cValueOut = New JSONCollection
    If Not FilterFields(Type_Data_Scene, cData["fields"], rResult, MapField, cValueOut) Then Return
    aValue.Add(cValueOut)
  Next

  SetReply(0, aValue)

End

'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
' Method=scene.run
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Private Sub Call_Scene_Run(cData As JSONCollection)
  
  If Not CheckParam(cData, ["scene_id": ["datatype": "integer"]]) Then Return

  If Scenes.Run(cData["scene_id"]) Then
    SetReply(0, True)
  Else
    SetReply(0, False)
  Endif

End

'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
' Method=data.newmessage
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Private Sub Call_Data_Newmessage()

  Dim cValue As New JSONCollection

  cValue.Add(Main.iNewMails, "email")
  cValue.Add(Main.iNewCalls, "call")
  cValue.Add(Main.iNewVoicemails, "voicemail")

  SetReply(0, cValue)

End

'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
' Method=squeezebox.get
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Private Sub Call_SqueezeBox_Get(cData As JSONCollection)

  Dim sValue As String
  Dim bValue As Boolean
  Dim aValue As New String[]

  If Not CheckParam(cData, ["function": ["datatype": "string"], "player": ["datatype": "string", "optional": True]]) Then Return

  Select cData["function"]
    Case "volume" ' get current volume of squeezebox player
      sValue = "0"
      Try sValue = Plugin.GetPluginObject("SqueezeServer", 1).Interface.GetVolumePlayer(cData["player"])
      'If Error Then Main.WriteDebugLog(LogLabel & "ERROR: '" & Error.Text & "' at '" & Error.Where & "' when prev number player")
      SetReply(0, sValue)

    Case "currentnumber" ' get current playing number (title)
      sValue = "No title"
      Try sValue = Plugin.GetPluginObject("SqueezeServer", 1).Interface.GetCurrentTitle(cData["player"])
      ' If Error Then Main.WriteDebugLog(LogLabel & "ERROR: '" & Error.Text & "' at '" & Error.Where & "' when running current title player")
      SetReply(0, sValue)

    Case "currentartist" ' get current playing artist name
      sValue = "Unknown artist"
      Try sValue = Plugin.GetPluginObject("SqueezeServer", 1).Interface.GetCurrentArtist(cData["player"])
      'If Error Then Main.WriteDebugLog(LogLabel & "ERROR: '" & Error.Text & "' at '" & Error.Where & "' when running get player name")
      SetReply(0, sValue)

    Case "albums" ' get the list of all the available albums
      Try aValue = Plugin.GetPluginObject("SqueezeServer", 1).Interface.GetAlbums()
      'If Error Then Main.WriteDebugLog(LogLabel & "ERROR: '" & Error.Text & "' at '" & Error.Where & "' when running get albums command")
      SetReply(0, aValue)

    Case "mode" ' get the mode of the player
      sValue = "Unknown status"
      Try sValue = Plugin.GetPluginObject("SqueezeServer", 1).Interface.GetModePlayer(cData["player"])
      'If Error Then Main.WriteDebugLog(LogLabel & "ERROR: '" & Error.Text & "' at '" & Error.Where & "' when running mode player")
      SetReply(0, sValue)

    Case "playerid" ' get the player id
      sValue = "Unknown id"
      Try sValue = Plugin.GetPluginObject("SqueezeServer", 1).Interface.GetPlayerId(cData["player"])
      'If Error Then Main.WriteDebugLog(LogLabel & "ERROR: '" & Error.Text & "' at '" & Error.Where & "' when running get player id")
      SetReply(0, sValue)

    Case "playername" ' get the player name, using the id
      sValue = "Unknown name"
      Try sValue = Plugin.GetPluginObject("SqueezeServer", 1).Interface.GetPlayerName(cData["player"])
      'If Error Then Main.WriteDebugLog(LogLabel & "ERROR: '" & Error.Text & "' at '" & Error.Where & "' when running get player name")
      SetReply(0, sValue)

    Case "playertype" ' get player type e.g. Stream, Squeezebox 2, Slimp3
      sValue = "Unknown type"
      Try sValue = Plugin.GetPluginObject("SqueezeServer", 1).Interface.GetIsPlayer(cData["player"])
      'If Error Then Main.WriteDebugLog(LogLabel & "ERROR: '" & Error.Text & "' at '" & Error.Where & "' when running is player command")
      SetReply(0, sValue)

    Case "isconnected" ' get if the player is connected to SqueezeServer daemon
      Try bValue = Plugin.GetPluginObject("SqueezeServer", 1).Interface.PlayerConnectedToServer(cData["player"])
      'If Error Then Main.WriteDebugLog(LogLabel & "ERROR: '" & Error.Text & "' at '" & Error.Where & "' when running is player command")
      SetReply(0, bValue)

    Default ' not an allowed or invalid function type
      SetReply(JSONRPC_INVALIDPARAMS, Null, "params 'function' = '" & cData["function"] & "' is an invalid value")

  End Select

End

'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
' Method=squeezebox.set
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Private Sub Call_SqueezeBox_Set(cData As JSONCollection)

  Dim bValue As Boolean

  If Not CheckParam(cData, ["function": ["datatype": "string"], "player": ["datatype": "string", "optional": True]]) Then Return

  Select cData["function"]
    Case "volume" ' get current volume of squeezebox player
      If Not CheckParam(cData, ["volume": ["datatype": "integer", "minvalue": 0, "maxvalue": 100]]) Then Return

      Try Plugin.GetPluginObject("SqueezeServer", 1).Interface.SetVolumePlayer(cData["player"], cData["volume"])
      If Not Error Then
        bValue = True
      Else
        ' Write error
      Endif
      SetReply(0, bValue)

    Case "startplayer"
      Try Plugin.GetPluginObject("SqueezeServer", 1).Interface.PlayPlayer(cData["player"])
      If Not Error Then
        bValue = True
      Else
        ' Write error
      Endif

      SetReply(0, bValue)

    Case "stopplayer"
      Try Plugin.GetPluginObject("SqueezeServer", 1).Interface.StopPlayer(cData["player"])
      If Not Error Then
        bValue = True
      Else
        ' Write error
      Endif
      SetReply(0, bValue)

    Case "nextnumber"
      Try Plugin.GetPluginObject("SqueezeServer", 1).Interface.NextNumberPlayer(cData["player"])
      If Not Error Then
        bValue = True
      Else
        ' Write error
      Endif
      SetReply(0, bValue)

    Case "prevnumber"
      Try Plugin.GetPluginObject("SqueezeServer", 1).Interface.PrevNumberPlayer(cData["player"])
      If Not Error Then
        bValue = True
      Else
        ' Write error
      Endif
      SetReply(0, bValue)

    Case "clearplaylist"
      Try Plugin.GetPluginObject("SqueezeServer", 1).Interface.ClearPlaylistPlayer(cData["player"])
      If Not Error Then
        bValue = True
      Else
        ' Write error
      Endif
      SetReply(0, bValue)

    Case "addalbumtoplaylist"
      If Not CheckParam(cData, ["album": ["datatype": "string"]]) Then Return

      Try Plugin.GetPluginObject("SqueezeServer", 1).Interface.AddAlbumToPlaylistPlayer(cData["player"], cData["album"])
      If Not Error Then
        bValue = True
      Else
        ' Write error
      Endif
      SetReply(0, bValue)

    Default
      SetReply(JSONRPC_INVALIDPARAMS, Null, "params 'function' = '" & cData["function"] & "' is an invalid value")

  End Select

End

'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
' Method=razberry.updatesready
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Private Sub Call_RaZberry_Updatesready(cData As JSONCollection)

  Dim iInstance As Integer = 1

  If cData.Exist("instance_id") Then
    If Not CheckParam(cData, ["instance_id": ["datatype": "integer", "minvalue": 1]]) Then Return
    iInstance = CInt(cData["instance_id"])
  Endif

  ' TODO: Fix instance  
  Try Plugin.GetPluginObject("RaZberry", iInstance).interface.GetUpdates()
  SetReply(0, True)

End

'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
' Method=rrdtool.create
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Private Sub Call_RRDTool_Create(cData As JSONCollection)

  If Not CheckParam(cData, ["device_id": ["datatype": "integer", "optional": True]]) Then Return

  ' cData["device_id"]
  Try RRDTool.CreateRRDs(cData["device_id"])
  If Error Then
    SetReply(0, False)
  Else
    SetReply(0, True)
  Endif

End

'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
' Method=rrdtool.update
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Private Sub Call_RRDTool_Update(cData As JSONCollection)

  Try RRDTool.CreateGraphs(cData["group"], cData["time"])
  Try RRDTool.CreateExtGraphs(cData["group"], cData["time"])
  If Error Then
    SetReply(0, False)
  Else
    SetReply(0, True)
  Endif

End

'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
' Method=rrdtool.generate
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Private Sub Call_RRDTool_Generate(cData As JSONCollection)

  Dim sPNG As String

  Try sPNG = RRDTool.GenerateGraph(cData["graph_id"], cData["time"])
  If Error Then
    SetReply(0, "")
  Else
    SetReply(0, sPNG)
  Endif

End

'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
' Method=rrdtool.deleterrd
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Private Sub Call_RRDTool_DeleteRRD(cData As JSONCollection)

  If Not CheckParam(cData, ["device_id": ["datatype": "integer", "optional": True]]) Then Return
  If Not cData.Exist("device_id") Then cData["device_id"] = 0

  Try RRDTool.DeleteRRD(cData["device_id"])
  If Error Then
    SetReply(0, False)
  Else
    SetReply(0, True)
  Endif

End

'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
' Method=serverstat.update
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Private Sub Call_ServerStat_Update(cData As JSONCollection)

  Try ServerStats.CreateGraphs(cData["time"])
  If Error Then
    SetReply(0, False)
  Else
    SetReply(0, True)
  Endif

End

'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
' Method=dsc.setpin
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Private Sub Call_DSC_SetPin(cData As JSONCollection)

  Try Plugin.GetPluginObject("DSC", 1).Interface.TX("0401" & cData["pin"])
  If Error Then
    SetReply(0, False)
  Else
    SetReply(0, True)
  Endif

End

'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
' Method=dsc.setarm
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Private Sub Call_DSC_SetArm(cData As JSONCollection)

  'If InStr("0311 0301", sParams[0]) Then
  Try Plugin.GetPluginObject("DSC", 1).Interface.TX(cData["mode"])
  If Error Then
    SetReply(0, False)
  Else
    SetReply(0, True)
  Endif

End

'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
' Method=ledmatrix.display
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Private Sub Call_LEDMatrix_Display(cData As JSONCollection)

  Try Plugin.GetPluginObject("LEDMatrix", 1).Interface.DisplayMessage(cData["displayid"], cData["msg"])
  If Error Then
    SetReply(0, False)
  Else
    SetReply(0, True)
  Endif

End

'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
' Method=avcontrol.get
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Private Sub Call_AVControl_Get(cData As JSONCollection)

  Try AVControl.Get(cData["model"], cData["cmd"], cData["address"])
  If Error Then
    SetReply(0, False)
  Else
    SetReply(0, True)
  Endif

End

'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
' Method=avcontrol.set
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Private Sub Call_AVControl_Set(cData As JSONCollection)

  Try AVControl.Set(cData["model"], cData["cmd"], cData["value"], cData["address"])
  If Error Then
    SetReply(0, False)
  Else
    SetReply(0, True)
  Endif

End

'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
' Method=cul.simulate
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Private Sub Call_CUL_Simulate(cData As JSONCollection)

  Try Plugin.GetPluginObject("CUL", 1).Interface.Simulate(cData["data"])
  If Error Then
    SetReply(0, False)
  Else
    SetReply(0, True)
  Endif

End

'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
' Method=cul.queuecommand
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Private Sub Call_CUL_QueueCommand(cData As JSONCollection)

  Try Plugin.GetPluginObject("CUL", 1).Interface.QueueCommand(cData["cmd"])
  If Error Then
    SetReply(0, False)
  Else
    SetReply(0, True)
  Endif

End

'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
' Method=calendar.get
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Private Sub Call_Calendar_Get()

End

'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
' Method=calendar.set
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Private Sub Call_Calendar_Set(cData As JSONCollection)

  ' cData["planning"] = String[]
  If cData Then
  Endif

End

'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
' Method=thermostat.list
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Private Sub Call_Thermostat_List(cData As JSONCollection)

  Dim cValue As New Collection[]
  Dim cScenario As New JSONCollection
  Dim rResult As Result
  Dim rResultHeating As Result
  Dim MapField As New Collection
  Dim aHeating As New Collection[]
  Dim cHeating As New JSONCollection
  Dim sCurrTemp, sReqTemp As String
  Dim fTemp As Float
  Dim bHeating As Boolean

  If Not CheckParam(cData, ["command": ["datatype": "string"]]) Then Return
  If Not GetParamFields(cData) Then Return

  Select cData["command"]
    Case "scenarios", "scenarii"

      rResult = Thermostat.GetScenariiList()

      If rResult And If rResult.Available Then
        For Each rResult
          cScenario = New JSONCollection

          If Not FilterFields(Type_Thermostat_Scenario, cData["fields"], rResult, MapField, cScenario) Then Return

          If cData["fields"].Count > 0 Then
            If cData["fields"].Find("heating") >= 0 Then

              bHeating = True
            Else
              bHeating = False
            Endif
          Else
            bHeating = True
          Endif

          If bHeating Then
            ' Add Heating for the scenario
            aHeating = New Collection[]
            rResultHeating = Main.hDB.Exec("SELECT * FROM `thermostat_schedule` s, `thermostat_heating` h WHERE s.heating_id=h.id AND s.scenario_id=&1", rResult!id)
            If rResultHeating And If rResultHeating.Available Then
              For Each rResultHeating
                cHeating = New JSONCollection
                sCurrTemp = Devices.GetCurrentValueForDevice(rResultHeating!sensor, 1)
                fTemp = Thermostat.GetDerogateHeating(rResultHeating!id)
                If fTemp = Thermostat.NO_TEMP Then fTemp = Thermostat.GetRequestedTempForHeating(rResultHeating!scenario_id, rResultHeating!id)
                sReqTemp = fTemp

                cHeating.Add(rResultHeating!id, "heating_id")
                cHeating.Add(rResultHeating!name, "name")
                cHeating.Add(sCurrTemp, "temp_cur")
                cHeating.Add(sReqTemp, "temp_req")

                aHeating.Add(cHeating)
              Next

            Endif

            cScenario.Add(aHeating, "heating") 
          Endif

          cValue.Add(cScenario)
        Next
      Endif
    Default
      SetReply(JSONRPC_INVALIDPARAMS, Null, "params 'mode' has unknown value '" & cData["command"] & "'")
      Return
  End Select

  SetReply(0, cValue)

End

'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
' Method=thermostat.derogateheating
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Private Sub Call_Thermostat_DerogateHeating(cData As JSONCollection)

  Dim iScenarioId As Integer
  Dim iHeatingId As Integer
  Dim fNewVal, fVal, fDerVal As Float

  If Not CheckParam(cData, ["scenario_id": ["datatype": "integer"], "heating_id": ["datatype": "integer"], "operator": ["datatype": "string"]]) Then Return

  iScenarioId = CInt(cData["scenario_id"])
  iHeatingId = CInt(cData["heating_id"])

  fVal = Thermostat.GetRequestedTempForHeating(iScenarioId, iHeatingId)
  fDerVal = Thermostat.GetDerogateHeating(iHeatingId)
  If fDerVal <> Thermostat.NO_TEMP Then
    fval = fderval
  Endif

  If cData["operator"] = "+" Then
    If fDerVal = Thermostat.NO_TEMP Then
      fNewVal = Thermostat.GetNextRequestedTempForHeating(iScenarioId, iHeatingId)
      If fNewVal <> Thermostat.NO_TEMP Then
        If fNewVal < fval Then
          fNewVal = fval + 0.5
        Endif
      Else
        If fVal = Thermostat.NO_TEMP Then
          Try fVal = Devices.GetCurrentValueForDevice(Thermostat.GetHeatSensor(iHeatingId), 1)
        Endif

        fNewVal = fval + 0.5
      Endif
    Else
      fNewVal = fval + 0.5
    Endif

  Else If cData["operator"] = "-" Then

    If fDerVal = Thermostat.NO_TEMP Then
      fNewVal = Thermostat.GetNextRequestedTempForHeating(iScenarioId, iHeatingId)
      If fNewVal <> Thermostat.NO_TEMP Then
        If fNewVal > fval Then
          fNewVal = fval - 0.5
        Endif
      Else
        If fVal = Thermostat.NO_TEMP Then
          Try fVal = Devices.GetCurrentValueForDevice(Thermostat.GetHeatSensor(iHeatingId), 1)
        Endif

        fNewVal = fval - 0.5
      Endif
    Else
      fNewVal = fval - 0.5
    Endif

  Else
    Error.Raise("ERROR: Unsupported operator '" & cData["operator"] & "'")
  Endif

  Thermostat.SetDerogateHeating(iScenarioId, iHeatingId, fNewVal)
  SetReply(0, True)

Catch
  SetReply(0, False, Error.Text)

End

'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
' Method=thermostat.getderogateheating
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Private Sub Call_Thermostat_GetDerogateHeating(cData As JSONCollection)

  Dim iHeatingId As Integer = CInt(cData["heating_id"])
  Dim fDerVal As Float = Thermostat.GetDerogateHeating(iHeatingId)

  SetReply(0, fDerVal)

Catch
  SetReply(0, Null)

End

'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
' Method=cmdr.plcbus.txcommand
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Private Sub Call_Cmdr_PLCBUS_TxCommand(cData As JSONCollection)

  Try Plugin.GetPluginObject("PLCBUS", 1).Interface.PLCBUSTXCommand(cData["cmd"], cData["address"], cData["ack"], cData["data"])
  If Error Then
    SetReply(0, False)
  Else
    SetReply(0, True)
  Endif

End

'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
' method=subscribe.logupdate
' It always need to give a successful response
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Private Sub Call_Subscribe_LogUpdate()

  SetReply(0, True)

End

'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
' This is NOT a method to be called by the JSON-RPC server
' It is used to push information to the JSON-RPC server when connections are subscribed to it
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Public Sub Subscribe_LogUpdate(cData As JSONCollection)

  'hJSONRPC.LogUpdate(cData)
  If cData Then
  Endif

End

'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
' method=subscribe.deviceupdate 
' It always need to give a successful response
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Private Sub Call_Subscribe_DeviceUpdate()

  SetReply(0, True)

End

'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
' This is NOT a method to be called by the JSON-RPC server
' It is used to push information to the JSON-RPC server when connections are subscribed to it
' It publish the DeviceUpdate information, the caller is responsible for delivering the right format
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Public Sub Subscribe_DeviceUpdate(cData As JSONCollection)

  'hJSONRPC.DeviceUpdate(cData)
  If cData Then
  Endif

End

'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
' method=tools.openzwave.get
' Params:
' - command: list, controller
' - instance_id: numeric
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Private Sub Call_Tools_OpenZWave_Get(cData As JSONCollection)

  Dim iInstanceId As Integer
  Dim hOpenZWave As Object
  Dim aInstanceList As New Integer[]
  Dim cValue As New JSONCollection

  ' Detect if the "command" is a string
  If Not CheckParam(cData, ["command": ["datatype": "string"]]) Then Return

  ' Check for "instance_id", only not needed when getting instance list
  If cData["command"] <> "list" Then

    If Not CheckParam(cData, ["instance_id": ["datatype": "integer", "minvalue": 1]]) Then Return
    iInstanceId = CInt(cData["instance_id"])

    ' Don't continue if the Plugin isn't enabled
    If Not Plugin.IsPluginEnabled("OpenZWave", Instance) Then
      SetReply(JSONRPC_INVALIDPARAMS, Null, "The OpenZWave instance '" & iInstanceId & "' is disabled")
      Return
    Endif

    ' Make reference to our local object, makes it easier to code
    Try hOpenZWave = Plugin.GetPluginObject("OpenZWave", iInstanceId).Interface
    If Error Then
      SetReply(JSONRPC_INVALIDPARAMS, Null, "Unable to use the OpenZWave instance '" & iInstanceId & "', error=" & Error.Text)
      Return
    Endif

  Endif

  Select cData["command"]
    ' Get available/enabled controller list
    Case "list"
      aInstanceList = Plugin.GetPluginEnabledList("OpenZWave")
      cValue["count"] = aInstanceList.Count
      cValue["instance_id"] = aInstanceList
    Case "controller"
      cValue = hOpenZWave.JsonRpc_Tools_OpenZWave_Get(cData)
      If cValue = Null Then
        SetReply(JSONRPC_INVALIDPARAMS, Null, "Unknown response on 'controller' retrieval")
        Return
      Endif

    Default
      SetReply(JSONRPC_INVALIDPARAMS, Null, "params 'mode' has unknown value '" & cData["command"] & "'")
      Return
  End Select

  SetReply(0, cValue)

End

'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
' method=tools.openzwave.set
' Params:
' - command: includedevice, excludedevice, softreset, hardreset, healnetwork 
'            replacenode, removenode
'            setvalue, setconfig, wakeupinterval
'            nodeinfo, versionreport, meterreport, dynamicreport basicreport, updateneighbor, nodecapability
'            addassociation, removeassociation
'            addusercode, cancelusercode
' - instance_id: numeric, or homeid
' - node_id: numeric (optional)
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Private Sub Call_Tools_OpenZWave_Set(cData As JSONCollection)

  Dim hOpenZWave As Object
  Dim iInstanceId As Integer
  Dim iNodeId As Integer
  Dim iGroup As Integer
  Dim iIndex As Integer
  Dim iValue As Integer

  ' Detect if the "command" is a string
  If Not CheckParam(cData, ["command": ["datatype": "string"]]) Then Return

  If Not CheckParam(cData, ["instance_id": ["datatype": "integer", "minvalue": 1]]) Then Return
  iInstanceId = CInt(cData["instance_id"])

  ' Don't continue if the Plugin isn't enabled
  If Not Plugin.IsPluginEnabled("OpenZWave", iInstanceId) Then
    SetReply(JSONRPC_INVALIDPARAMS, Null, "OpenZWave instance '" & iInstanceId & "' isn't enabled")
    Return
  Endif

  ' Make reference to our local object, makes it easier to code
  Try hOpenZWave = Plugin.GetPluginObject("OpenZWave", iInstanceId).Interface
  If Error Then
    SetReply(JSONRPC_INVALIDPARAMS, Null, "OpenZWave instance '" & iInstanceId & "' issue, ERROR: " & Error.Text)
    Return
  Endif

  Select cData["command"]
    Case "includedevice", "excludedevice", "softreset", "hardreset", "healnetwork", "cancelusermode"
    Case "replacenode", "removenode", "setvalue", "setconfig", "wakeupinterval", "nodeinfo", "versionreport", "meterreport", "dynamicreport", "basicreport", "addassociation", "removeassociation", "addusercode", "removeusercode", "updateneighbor", "nodecapability", "setvalue"
      If Not CheckParam(cData, ["node_id": ["datatype": "integer", "minvalue": 1]]) Then Return
      iNodeId = CInt(cData["node_id"])
    Default
      ' ERROR
  End Select

  ' Do the OpenZWave action
  Select cData["command"]
    Case "includedevice"
      hOpenZWave.IncludeDevice()
    Case "excludedevice"
      hOpenZWave.ExcludeDevice()
    Case "cancelcontrollercommand"
      hOpenZWave.CancelControllerCommand()
    Case "softreset"
      hOpenZWave.ControllerSoftReset()
    Case "hardreset"
      hOpenZWave.ControllerHardReset()
    Case "healnetwork"
      hOpenZWave.HealNetwork()
    Case "replacenode"
      hOpenZWave.ReplaceFailedNode(iNodeId)
    Case "removenode"
      hOpenZWave.RemoveFailedNode(iNodeId)
    Case "nodeinfo"
      hOpenZWave.RefreshNodeInfo(iNodeId)
    Case "nodecapability"
      hOpenZWave.RequestNodeCapabilities(iNodeId)
    Case "versionreport"
      hOpenZWave.RequestNodeVersionReport(iNodeId)
    Case "meterreport"
      hOpenZWave.RequestNodeMeterReport(iNodeId)
    Case "dynamicreport"
      hOpenZWave.RequestNodeDynamicReport(iNodeId)
    Case "basicreport"
      hOpenZWave.RequestBasicReport(iNodeId)
    Case "updateneighbor"
      hOpenZWave.RequestNodeNeighborUpdate(iNodeId)
    Case "addusercode"
      hOpenZWave.SetNodeUserCodeStart(iNodeId)
    Case "removeusercode"
      hOpenZWave.SetNodeUserCodeRemove(iNodeId)
    Case "cancelusercode"
      hOpenZWave.SetNodeUserCodeStop()

    Case "setvalue"
      If Not CheckParam(cData, ["index": ["datatype": "integer", "minvalue": 1], "value": ["datatype": "integer"]]) Then Return
      iIndex = CInt(cData["index"])
      iValue = CInt(cData["value"])

      hOpenZWave.SetValue(iNodeId, iIndex, iValue)

    Case "wakeupinterval"
      If Not CheckParam(cData, ["value": ["datatype": "integer"]]) Then Return
      iValue = CInt(cData["value"])

      hOpenZWave.SetNodeWakeUpInterval(iNodeId, iValue)

    Case "setconfig"
      If Not CheckParam(cData, ["type": ["datatype": "string"], "index": ["datatype": "integer", "minvalue": 1], "value": ["datatype": "any"]]) Then Return
      iIndex = CInt(cData["index"])

      Select cData["type"]
        Case "list"
          If TypeOf(cData["value"]) = gb.String Then
            hOpenZWave.SetConfigParamList(iNodeId, iIndex, cData["value"])
          Else
            SetReply(JSONRPC_INVALIDPARAMS, Null, "params 'type=list' and value isn't a valid string")
            Return
          Endif
        Case "bool"
          If TypeOf(cData["value"]) = gb.Boolean Then
            If cData["value"] Then
              hOpenZWave.SetConfigParam(iNodeId, iIndex, 1)
            Else
              hOpenZWave.SetConfigParam(iNodeId, iIndex, 0)
            Endif
          Else
            SetReply(JSONRPC_INVALIDPARAMS, Null, "params 'type=bool' and value isn't a valid boolean datatype")
            Return
          Endif
        Default
          Try iValue = CInt(cData["value"])
          If Error Then
            SetReply(JSONRPC_INVALIDPARAMS, Null, "params 'value' isn't a numeric value")
            Return
          Endif

          hOpenZWave.SetConfigParam(iNodeId, iIndex, iValue)
      End Select

    Case "addassociation"

      If Not CheckParam(cData, ["group": ["datatype": "integer", "minvalue": 1], "addnode": ["datatype": "integer", "minvalue": 1]]) Then Return
      iGroup = CInt(cData["group"])
      iValue = CInt(cData["addnode"])

      hOpenZWave.AddAssociation(iNodeId, iGroup, iValue)

    Case "removeassociation"
      If Not CheckParam(cData, ["group": ["datatype": "integer", "minvalue": 1], "removenode": ["datatype": "integer", "minvalue": 1]]) Then Return
      iGroup = CInt(cData["group"])
      iValue = CInt(cData["removenode"])

      hOpenZWave.RemoveAssociation(iNodeId, iGroup, iValue)

  End Select

  ' Return True, will be improved later
  SetReply(0, True)

End

'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
' method=tools.rfxcom.get
' Params:
' - command: list, controller
' - rfxcom: rfxcomtrx, rfxcomtx or rfxcomrx
' - instance_id: numeric
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Private Sub Call_Tools_RFXCom_Get(cData As JSONCollection)

  Dim iInstanceId As Integer
  Dim hRFXCom As Object
  Dim aInstanceList As Integer[]
  Dim cValue As New JSONCollection
  Dim cList As New JSONCollection

  If Not CheckParam(cData, ["command": ["datatype": "string", "valuelist": ["list", "controller"]]]) Then Return

  ' Check for "type" and "instance_id", only not needed when getting instance list
  If cData["command"] <> "list" Then
    If Not CheckParam(cData, ["instance_id": ["datatype": "integer", "minvalue": 1], "rfxcom": ["datatype": "string", "valuelist": ["rfxcomtrx", "rfxcomtx", "rfxcomrx"]]]) Then Return
    iInstanceId = CInt(cData["instance_id"])

    ' Don't continue if the Plugin isn't enabled
    If Not Plugin.IsPluginEnabled(cData["rfxcom"], Instance) Then
      SetReply(JSONRPC_INVALIDPARAMS, Null, "The " & cData["rfxcom"] & " instance '" & iInstanceId & "' is disabled")
      Return
    Endif

    ' Make reference to our local object, makes it easier to code
    Try hRFXCom = Plugin.GetPluginObject(cData["rfxcom"], iInstanceId).Interface
    If Error Then
      SetReply(JSONRPC_INVALIDPARAMS, Null, "Unable to use the " & cData["rfxcom"] & " instance '" & iInstanceId & "', error=" & Error.Text)
      Return
    Endif

  Endif

  Select cData["command"]
    ' Get available/enabled controller list
    Case "list"
      aInstanceList = New Integer[]
      aInstanceList = Plugin.GetPluginEnabledList("RFXComTRX")
      cList["rfxcomtrx"] = aInstanceList

      aInstanceList = New Integer[]
      aInstanceList = Plugin.GetPluginEnabledList("RFXComRX")
      cList["rfxcomrx"] = aInstanceList

      aInstanceList = New Integer[]
      aInstanceList = Plugin.GetPluginEnabledList("RFXComTX")
      cList["rfxcomtx"] = aInstanceList

      cValue["count"] = cList["rfxcomtrx"].Count + cList["rfxcomrx"].Count + cList["rfxcomtx"].Count
      cValue["instance_id"] = cList
    Case "controller"
      cValue = hRFXCom.JsonRpc_Tools_RFXCom_Get(cData)
      If cValue = Null Then
        SetReply(JSONRPC_INVALIDPARAMS, Null, "Unknown response on 'controller' retrieval")
        Return
      Endif
  End Select

  SetReply(0, cValue)

End

'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
' method=tools.rfxcom.set
' Params:
' - rfxcom: rfcomtrx, rfxcomtx or rfcomrx
' - instance_id: numeric
' - function: lighting1, lighting2, lighting5, lighting6, etc
' - type:
' - address:
' - command:
' - group:
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Private Sub Call_Tools_RFXCom_Set(cData As JSONCollection)

  Dim hRFXCom As Object
  Dim iInstanceId As Integer

  If Not CheckParam(cData, ["instance_id": ["datatype": "integer", "minvalue": 1], "rfxcom": ["datatype": "string", "valuelist": ["rfxcomtrx", "rfxcomtx", "rfxcomrx"]], "function": ["datatype": "string"]]) Then Return
  iInstanceId = CInt(cData["instance_id"])

  ' Don't continue if the Plugin isn't enabled
  If Not Plugin.IsPluginEnabled(cData["rfxcom"], iInstanceId) Then
    SetReply(JSONRPC_INVALIDPARAMS, Null, "OpenZWave instance '" & iInstanceId & "' isn't enabled")
    Return
  Endif

  ' Make reference to our local object, makes it easier to code
  Try hRFXCom = Plugin.GetPluginObject(cData["rfxcom"], iInstanceId).Interface
  If Error Then
    SetReply(JSONRPC_INVALIDPARAMS, Null, cData["rfxcom"] & " instance '" & iInstanceId & "' issue, ERROR: " & Error.Text)
    Return
  Endif

  Select cData["rfxcom"]
    Case "rfxcomtrx"
      Select cData["function"]
        Case "lighting1"
          If Not CheckParam(cData, ["type": ["datatype": "string"], "address": ["datatype": "string"], "command": ["datatype": "string"], "group": ["datatype": "boolean"]]) Then Return
          hRFXCom.Lighting1(cData["type"], cData["address"], cData["command"], cData["group"])
        Case "lighting2"
          If Not CheckParam(cData, ["type": ["datatype": "string"], "address": ["datatype": "string"], "command": ["datatype": "string"], "group": ["datatype": "boolean"]]) Then Return
          hRFXCom.Lighting2(cData["type"], cData["address"], cData["command"], cData["group"])
        Case "lighting5"
          If Not CheckParam(cData, ["type": ["datatype": "string"], "address": ["datatype": "string"], "command": ["datatype": "string"]]) Then Return
          hRFXCom.Lighting5(cData["type"], cData["address"], cData["command"])
        Case "lighting6"
          If Not CheckParam(cData, ["type": ["datatype": "string"], "address": ["datatype": "string"], "command": ["datatype": "string"]]) Then Return
          hRFXCom.Lighting6(cData["type"], cData["address"], cData["command"])
        Case "chime"
          If Not CheckParam(cData, ["type": ["datatype": "string"], "address": ["datatype": "string"], "command": ["datatype": "string"]]) Then Return
          hRFXCom.Chime(cData["type"], cData["address"], cData["command"])
        Case "curtain"
          If Not CheckParam(cData, ["type": ["datatype": "string"], "address": ["datatype": "string"], "command": ["datatype": "string"]]) Then Return
          hRFXCom.Curtain(cData["type"], cData["address"], cData["command"])
        Case "thermostat2"
          If Not CheckParam(cData, ["type": ["datatype": "string"], "address": ["datatype": "string"], "command": ["datatype": "string"]]) Then Return
          hRFXCom.Thermostat2(cData["type"], cData["address"], cData["command"])
        Case "security1"
          If Not CheckParam(cData, ["type": ["datatype": "string"], "address": ["datatype": "string"], "command": ["datatype": "string"]]) Then Return
          hRFXCom.Security1(cData["type"], cData["address"], cData["command"])
        Case "fan"
          If Not CheckParam(cData, ["type": ["datatype": "string"], "address": ["datatype": "string"], "command": ["datatype": "string"]]) Then Return
          hRFXCom.Fan(cData["type"], cData["address"], cData["command"])
        Case "rfy"
          If Not CheckParam(cData, ["type": ["datatype": "string"], "address": ["datatype": "string"], "command": ["datatype": "string"]]) Then Return
          hRFXCom.RFY(cData["type"], cData["address"], cData["command"])
        Case "radiator1"
          If Not CheckParam(cData, ["type": ["datatype": "string"], "address": ["datatype": "string"], "command": ["datatype": "string"]]) Then Return
          hRFXCom.Radiator1(cData["type"], cData["address"], cData["command"])
        Case "protocolsetup"
          If Not CheckParam(cData, ["command": ["datatype": "string"], "mode": ["datatype": "object"]]) Then Return
          hRFXCom.ProtocolSetup(cData["command"], cData["mode"])
        Default
          SetReply(JSONRPC_INVALIDPARAMS, Null, "Unknown function '" & cData["function"] & "' supplied")
          Return
      End Select

    Case "rfxcomtx"
      Select cData["function"]
        Case "getversion"
          hRFXCom.GetVersion()
        Case "x10"
          If Not CheckParam(cData, ["address": ["datatype": "string"], "command": ["datatype": "string"]]) Then Return
          hRFXCom.X10(cData["address"], cData["command"])
        Case "ac"
          If Not CheckParam(cData, ["address": ["datatype": "string"], "command": ["datatype": "string"], "heeu": ["datatype": "boolean"], "group": ["datatype": "boolean"]]) Then Return
          hRFXCom.AC(cData["address"], cData["command"], cData["heeu"], cData["group"])
        Case "protocolsetup"
          If Not CheckParam(cData, ["command": ["datatype": "string", "valuelist": ["enablearc", "enableharrison", "enablekoppla", "disablex10"]]]) Then Return
          Select cData["command"]
            Case "enablearc"
              hRFXCom.EnableARCTX()
            Case "enableharrison"
              hRFXCom.EnableHarrisonTX()
            Case "enablekoppla"
              hRFXCom.EnableKopplaTX()
            Case "disablex10"
              hRFXCom.DisableX10TX()
          End Select
        Default
          SetReply(JSONRPC_INVALIDPARAMS, Null, "Unknown function '" & cData["function"] & "' supplied")
          Return
      End Select

    Case "rfxcomrx"
      Select cData["function"]
        Case "getversion"
          hRFXCom.GetVersion()
        Case "simulate"
          If Not CheckParam(cData, ["command": ["datatype": "string"]]) Then Return
          hRFXCom.bSimulate = True
          hRFXCom.Simulate(cData["command"])
        Case "protocolsetup"
          If Not CheckParam(cData, ["command": ["datatype": "string"]]) Then Return
          Select cData["command"]
            Case "enableall"
              hRFXCom.ProtocolSetup("ALL")
            Case "disableoregon"
              hRFXCom.ProtocolSetup("OREGON")
            Case "disablex10"
              hRFXCom.ProtocolSetup("X10")
            Case "disablearc"
              hRFXCom.ProtocolSetup("ARC")
            Case "disablekoppla"
              hRFXCom.ProtocolSetup("KOPPLA")
            Case "disableati"
              hRFXCom.ProtocolSetup("ATI")
            Case "disablevisonic"
              hRFXCom.ProtocolSetup("VISONIC")
            Case "disablesomfy"
              hRFXCom.ProtocolSetup("SOMFY")
            Case "disableheuk"
              hRFXCom.ProtocolSetup("HEUK")
            Case "disableheeu"
              hRFXCom.ProtocolSetup("HEEU")
            Default
              SetReply(JSONRPC_INVALIDPARAMS, Null, "Unknown command '" & cData["command"] & "' supplied")
              Return
          End Select
        Default
          SetReply(JSONRPC_INVALIDPARAMS, Null, "Unknown function '" & cData["function"] & "' supplied")
          Return
      End Select

  End Select

  ' Return True, will be improved later
  SetReply(0, True)

End

'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
' method=tools.serialport.get
' Params:
' - command: list
' - path: path to the devices
' - filter: pattern
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Private Sub Call_Tools_SerialPort_Get(cData As JSONCollection)

  Dim cSerialPorts As New Collection
  Dim cValue As New JSONCollection

  If Not CheckParam(cData, ["command": ["datatype": "string", "valuelist": ["list"]], "path": ["datatype": "string"], "filter": ["datatype": "string"]]) Then Return

  Select cData["command"]
    Case "list"
      cSerialPorts = Util.ScanSerialPorts(cData["path"], cData["filter"])
      cValue.Add(cSerialPorts.Count, "count")
      cValue.Add(cSerialPorts, "serialport")
  End Select

  SetReply(0, cValue)

End



'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
' Method=scene.create
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Private Sub Call_Scene_Create(cData As Collection)

  If cData = Null Then
    Main.WriteDebugLog("params 'name', '' and 'displayorder' are missing")
    SetReply(JSONRPC_INVALIDPARAMS, Null)
    Return
  Endif

  ' The objectid has to be an integer and objecttype an integer
  If Not CheckParam(cData, ["name": ["datatype": "string", "optional": True], "event_id": ["datatype": "integer", "optional": False]]) Then Return

  If Scenes.createScene(cData["name"], cData["event_id"]) Then
    SetReply(0, True)
  Else
    SetReply(0, False)
  Endif

End

'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
' Method=scene.delete
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Private Sub Call_Scene_Delete(cData As Collection)

  If cData = Null Then
    Main.WriteDebugLog("params 'id' is missing")
    SetReply(JSONRPC_INVALIDPARAMS, Null)
    Return
  Endif

 ' The id has to be an integer and displayorder an integer
  If Not CheckParam(cData, ["id": ["datatype": "integer", "optional": False]]) Then Return

  If Scenes.deleteScene(cData["id"]) Then
    SetReply(0, True)
  Else
    SetReply(0, False)
  Endif

End

