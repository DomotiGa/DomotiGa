' Gambas class file

' Description:
' CIViewer.class
' Native support for CommandFusion's iViewer protocol.

' Development Status:
' Not working yet.

' Links:
' http://www.commandfusion.com
' http://commandfusion.googlecode.com/svn/trunk/dotNet_control/iViewerControl

' DomotiGa - an open source home automation program.
' Copyright (C) Ron Klinkien, The Netherlands.

' Read file called COPYING for license details.

'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
' Module/Class specific variables
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Public PluginName As String = "IViewer"
Public PluginType As Integer = Plugin.Type_Class
Public PluginFriendlyName As String = "CF iViewer"
Public PluginVersion As String = "1.00"
Public PluginAuthor As String = "Ron Klinkien"
Public PluginProtocols As String[]
Public PluginMaxInstances As Byte = 1

Public KeyName As String
Public LogLabel As String = "[IViewer] "
Public Instance As Integer
Public IsRunning As Boolean
Public ErrorText As String
Public ErrorWhere As String

'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
' Public variables - will be removed in the future
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Property IViewerPort As String
Property IViewerDebug As Boolean
Property IViewerPassword As String

'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
' Private Variables
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Private $bEnabled As Boolean
Private $sPort As String
Private $bIViewerDebug As Boolean
Private $sPassword As String

Public hIViewer As ServerSocket

Private oClients As New Object[]
Private sBuffer As String

'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
' Mandatory Sub for EACH Module/Class to initialize:
' - The cPlugin[x].Settings are copied into local variables
' - Port/Connection will be started (any errors caught)
' - Any other code per Class
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Public Sub StartPlugin(cPl As CPluginEntry)

  KeyName = cPl.KeyName
  Instance = cPl.Instance
  If Instance <> 1 Then LogLabel = Replace(LogLabel, "] ", "#" & Instance & "] ")

  ' Copy configuration items locally
  $bEnabled = cPl.Settings["enabled"]
  $sPort = cPl.Settings["tcpport"]
  $sPassword = cPl.Settings["password"]
  $bIViewerDebug = cPl.Settings["debug"]
 
  ' Connect/Initialize connection
  Connect()

End

'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
' Mandatory sub for EACH Module/Class to stop
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Public Sub StopPlugin()

  Try Disconnect()

End

'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
' start our tcp server
Public Function Connect() As Boolean

  hIViewer = New ServerSocket As "IViewer"
  hIViewer.Type = Net.Internet
  hIViewer.Port = $sPort
  hIViewer.Listen(0)

  If hIViewer.Status = Net.Active Then
  ' Write to main logfile we connected successfully
    Main.WriteLog(LogLabel & PluginFriendlyName & " Server listening on Port " & $sPort)
    IsRunning = True
    Return True
  Else
    Main.WriteLog(LogLabel & "ERROR: " & PluginFriendlyName & " Server FAILED listen on  Port " & $sPort)
    IsRunning = False
    ErrorText = "Net Not Active"
    Return False
  Endif

Catch ' some errors
  Main.WriteLog(LogLabel & "ERROR: " & PluginFriendlyName & " Server FAILED listen on  Port " & $sPort)
  Main.WriteLog(LogLabel & "ERROR: " & Error.Text)
  IsRunning = False
  ErrorText = Error.Text
  ErrorWhere = Error.Where

  Return False

End

' shutdown our tcp server
Public Sub Disconnect() As Boolean

  ' DO WHILE hSocket.Count > 0
  '   RemoveSocket(hSocket[0])
  ' LOOP

  hIViewer.Close()

  Main.WriteLog(LogLabel & PluginFriendlyName & " TCP Server closed.")

  ' all ok
  Return True

Finally
  IsRunning = False
  ErrorText = ""
  ErrorWhere = ""

Catch
  Main.WriteLog(LogLabel & "ERROR: " & Error.Text)
  Return False

End

Public Sub IViewer_Connection(sRemoteHostIP As String)

  Dim hSocket As Socket

  If hIViewer.Status <= Net.Active Then Return
  hSocket = hIViewer.Accept()
  oClients.Add(hSocket)
  If $bIViewerDebug Then Main.WriteDebugLog(LogLabel & "Got connect from client with IP " & hSocket.RemoteHost)

End

Public Sub IViewer_Error()

  Main.WriteLog(LogLabel & "ERROR: Unable to bind socket.")

End

Public Sub Socket_Read()

  Dim sData As String

  If Last.Status <> Net.Connected Then Return
  sData = Read #Last, 1
  If $bIViewerDebug Then Main.WriteDebugLog(LogLabel & "Data from socket " & oClients.Find(Last) & " " & oClients[oClients.Find(Last)].RemoteHost & " :" & sData)
  If sData = "\x03" Then ' buffer until \x03 then parse
    If Len(sBuffer) > 1 Then ParseLine(sBuffer)
    sBuffer = Null
  Else
    sBuffer &= sData
  Endif

End

Public Sub ParseLine(sText As String)

  Dim aScan As String[]

  If $bIViewerDebug Then Main.WriteDebugLog(LogLabel & sText)
  aScan = Scan(sText, "*=*")
  If aScan.Count = 2 Then
    Select Case Left(aScan[0], 1)
      Case "a", "d"
        ' analog (eg. a2=4000) or digital join (eg. d10=1)
        Events.CheckIViewerRemoteEvents("iviewer", aScan[0], aScan[1])
      Case "s"
        ' serial (eg. s4=this is text)
        If aScan[0] = "s10001" Then
          If $bIViewerDebug Then Main.WriteDebugLog(LogLabel & "< iViewer: " & aScan[1])
        Else If aScan[0] = "s10002" Then
           If $bIViewerDebug Then Main.WriteDebugLog(LogLabel & "< Device: " & aScan[1])
        Else
          Events.CheckIViewerRemoteEvents("iviewer", aScan[0], aScan[1])
        Endif
      Case "h"
        ' heartbeat message
        If $bIViewerDebug Then Main.WriteDebugLog(LogLabel & "< Heartbeat request.")
        Try Write #Last, "h=1\x03", 4
        If $bIViewerDebug Then Main.WriteDebugLog(LogLabel & "> Heartbeat reply.")
      Case "p"
        If $bIViewerDebug Then Main.WriteDebugLog(LogLabel & "< Password request.")
        ' password
        If aScan[1] = $sPassword Then
          Try Write #Last, "p=ok\x03", 5
          If $bIViewerDebug Then Main.WriteDebugLog(LogLabel & "> Password ok.")
        Else
          Try Write #Last, "p=bad\x03", 6
          If $bIViewerDebug Then Main.WriteDebugLog(LogLabel & "> Password bad.")
        Endif
      Case "m"
        ' orientation, (eg. m=landscape)
      Case "l"
        ' list event, (eg. l1:4:d1=1)
    End Select
  Endif
  If UCase(sText) = UCase("SendDeviceStatusAll") Then SendDeviceStatusAll()
  ' SendDeviceStatus("Front Lamp") or SendDeviceStatus(65) 
  aScan = Scan(sText, "*(*")
  If aScan.Count = 2 Then
     If UCase(aScan[0]) = UCase("SendDeviceStatus") Then SendDeviceStatus(Left(aScan[1], -1))
  Endif
End

Private Sub SendDeviceStatusAll()

  Dim rResult As Result
  Dim sString As New Collection
  Dim sList As New RpcStruct
  Dim iCnt As Integer
  Dim sValue, sValue2, sValue3, sValue4, sType As String

  rResult = Devices.FindAllEnabledDevices()

  If Not rResult.Available Then
    Main.WriteLog(LogLabel & "ERROR: table 'devices' not found!")
    Return
  Endif

  For iCnt = 0 To rResult.Max
    If Not rResult!hide Then

      Try sValue = Devices.CorrectValue(rResult!value, rResult!correction, rResult)
      Try sValue2 = Devices.CorrectValue(rResult!value2, rResult!correction2, rResult)
      Try sValue3 = Devices.CorrectValue(rResult!value3, rResult!correction3, rResult)
      Try sValue4 = Devices.CorrectValue(rResult!value4, rResult!correction4, rResult)
      If sValue = "Dim 100" Then sValue = "100"
      If sValue = "Dim 99" Then sValue = "100"
      If sValue = "Dim 0" Then sValue = "0"
      If rResult!switchable Then
         sType = "switch"
      Else If rResult!dimable Then
         sType = "dimmer"
      Endif
      If sValue <> Null Then SendUpdateForDevice(rResult!name, sValue, "value", IIf(sType, sType, "value"))
      If sValue2 <> Null Then SendUpdateForDevice(rResult!name, sValue2, "value2", IIf(sType, sType, "value2"))
      If sValue3 <> Null Then SendUpdateForDevice(rResult!name, sValue3, "value3", IIf(sType, sType, "value3"))
      If sValue4 <> Null Then SendUpdateForDevice(rResult!name, sValue4, "value4", IIf(sType, sType, "value4"))

    Endif
    rResult.MoveNext
  Next
End

Public Sub SendDeviceStatus(vDeviceName As Variant)

  Dim iInterface, iDeviceId As Integer
  Dim sText, sAddress, sDeviceName As String
  Dim sValue, sValue2, sValue3, sValue4, sType As String

 ' If we get a byte/integer or a string that can be parsed to integer, we should try to find the device with an id
  Try iDeviceId = CInt(vDeviceName)
  If Error Then
    Main.WriteDebugLog("[Warning] You are using a device name '" & vDeviceName & "' instead of device id, this option is be deprecated and will be removed!")
    Try iDeviceId = Devices.FindIdForDevice(vDeviceName)
    If Error Or Not iDeviceId Then Return
  Endif

  If Not Devices.CheckIfDeviceExists(iDeviceId) Then
    Main.WriteDebugLog("[Devices] ERROR: Device with id '" & iDeviceId & "' not found!")
    Return
  Endif  

  Try sValue = Devices.GetCurrentValueForDevice(iDeviceId, 1)
  Try sValue2 = Devices.GetCurrentValueForDevice(iDeviceId, 2)
  Try sValue3 = Devices.GetCurrentValueForDevice(iDeviceId, 3)
  Try sValue4 = Devices.GetCurrentValueForDevice(iDeviceId, 4)
 
  iInterface = Devices.FindInterfaceForDevice(iDeviceId)
  If Not iInterface Then Return

  sAddress = Devices.FindAddressForDevice(iDeviceId)
  If Not sAddress Then Return

  sType = LCase(Devices.CheckControlDevice(sAddress, iInterface))

  ' TODO set devicename
  If $bIViewerDebug Then Main.WriteDebugLog(LogLabel & "sType: " & sType & " sDeviceName " & sDeviceName)

  If sValue = "Dim 100" Then sValue = "100"
  If sValue = "Dim 99" Then sValue = "100"
  If sValue = "Dim 0" Then sValue = "0"

  If sValue <> Null Then SendUpdateForDevice(sDeviceName, sValue, "value", IIf(sType, sType, "value"))
  If sValue2 <> Null Then SendUpdateForDevice(sDeviceName, sValue2, "value2", IIf(sType, sType, "value2"))
  If sValue3 <> Null Then SendUpdateForDevice(sDeviceName, sValue3, "value3", IIf(sType, sType, "value3"))
  If sValue4 <> Null Then SendUpdateForDevice(sDeviceName, sValue4, "value4", IIf(sType, sType, "value4"))
End



'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
' publish data to iViewer
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Public Sub SendUpdateForDevice(sDevice As String, sValue As String, sValueField As String, sType As String)

  Dim sDeviceTypePair As String = Replace(sDevice & "_" & sValueField, " ", "_")


If $bIViewerDebug Then Main.WriteDebugLog(LogLabel & "SendUpdateForDevice: " & sDeviceTypePair & " :" & sValue)

  If oClients.Count = 0 Then
    If $bIViewerDebug Then Main.WriteDebugLog(LogLabel & "No clients connected, so aborting item updates.")
    Return ' no clients connected
  Endif

  Select LCase(sType)
     Case "value", "value1", "setpoint"
       UpdateIviewerClients(sDeviceTypePair, sValue)
     Case "value2"
       UpdateIviewerClients(sDeviceTypePair, sValue)
     Case "value3"
       UpdateIviewerClients(sDeviceTypePair, sValue)
     Case "value4"
       UpdateIviewerClients(sDeviceTypePair, sValue)
     Case "motion"
       UpdateIviewerClients(sDeviceTypePair, IIf(sValue == "Motion", 1, 0))
     Case "switch"
       If LCase(sValue) = "off" Then
         UpdateIviewerClients(sDeviceTypePair, "0")
       Else If LCase(sValue) = "on" Or If InStr(LCase(sValue), "dim") Then
         UpdateIviewerClients(sDeviceTypePair, "1")
       Endif
     Case "dimmer", "dim"
       Select LCase(sValue)
         Case "on"
           Return ' With my AeonLabs dimmer, openzwave DOES send setvalue notifcations as it ramps UP - so we do not want to send initial on command
                  ' as "on" command sets the dimmer to the last set value, not necessarily 100.
           'UpdateIviewerClients(sID, sDeviceTypePair, "100")
         Case "off"
           'Return ' With my AeonLabs dimmer, openzwave DOES NOT send notifcations as it ramps DOWN - so we do want to send "0" as off command 
           UpdateIviewerClients(sDeviceTypePair, "0")
         Case Else
           UpdateIviewerClients(sDeviceTypePair, Replace(sValue, "dim ", "", gb.IgnoreCase))
       End Select
   End Select

End

Public Sub UpdateIviewerClients(sDeviceTypePair As String, sValue As String)

  Dim sDataToSend As String
  Dim sIViewerTerminator As String = "\x03"  ' used by iViewer app when parsing to detect the end of a response
  Dim i As Integer
  
  sDataToSend = sDeviceTypePair & "=" & sValue & sIViewerTerminator
  
  i = 0
  While i < oClients.Count
    Try Write #oClients[i], sDataToSend, Len(sDataToSend)
    If $bIViewerDebug Then Main.WriteDebugLog(LogLabel & "Client" & i & ": " & oClients[i].RemoteHost & " :" & sDataToSend)
    Inc i
  Wend
  Catch
    If $bIViewerDebug Then Main.WriteDebugLog(LogLabel & "ERROR: " & Error.Text & " at " & Error.Where)

End

Public Sub Socket_Closed()

  If $bIViewerDebug Then Main.WriteDebugLog(LogLabel & "Connection closed by client " & oClients.Find(Last))
  oClients.Remove(oClients.Find(Last))

End

Private Function IViewerPort_Read() As String

  Return $sPort

End

Private Sub IViewerPort_Write(Value As String)

  $sPort = Value

End

Private Function IViewerDebug_Read() As Boolean

  Return $bIViewerDebug

End

Private Sub IViewerDebug_Write(Value As Boolean)

  $bIViewerDebug = Value

End

Private Function IViewerPassword_Read() As String

  Return $sPassword

End

Private Sub IViewerPassword_Write(Value As String)

  $sPassword = Value

End
