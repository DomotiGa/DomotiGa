' Gambas class file

' Description:
' CHomeMatic.class
' Connect to HomeMatic LAN adapter via tcp socket.
' Version 29 April 2012.

' Development Status:
' Just started. Basic functionality. Bugs still possible, pls report.

' Credits: JvdK

' DomotiGa - an open source home automation program.
' Copyright (C) Ron Klinkien, The Netherlands.

' Read file called COPYING for license details.

'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
' Module/Class specific variables
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Public PluginName As String = "HomeMatic"
Public PluginFriendlyName As String = "HomeMatic"
Public PluginVersion As String = "1.00"
Public PluginAuthor As String = "JvdK"
Public PluginProtocols As String[]
Public PluginMaxInstances As Integer = 1

Public KeyName As String
Public LogLabel As String = "[HomeMatic] "
Public InterfaceId As Integer
Public Instance As Integer
Public IsRunning As Boolean
Public ErrorText As String
Public ErrorWhere As String

'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
' Private Variables
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Private $bEnabled As Boolean
Private $sTCPHost As String
Private $iTCPPort As Integer
Private $bDebug As Boolean
Private $sHMLANid As String

' Interface objects
Public hMySocket As CSocket

Private $sMsgData As String

Public tHMBusy As Timer
Public bHMPairEnabled As Boolean
Public iStackCount As Integer               ' Use in Main form statusbar?
Public iStackCountUntransmitted As Integer  ' Use in Main form statusbar?
Public sHMLANReportedFW As String           ' HMLAN real properties
Public sHMLANReportedSerial As String       ' HMLAN real properties
Public sHMLANReportedAddress As String      ' HMLAN real properties

' logging
Public bHMRawLogEnabled As Boolean = False   ' log all port traffic
Public bHMRadioLogEnabled As Boolean = False ' log radio traffic
Public bHMInfoLogEnabled As Boolean = True   ' log all commands and responses
Public bHMErrorLogEnabled As Boolean = False ' log all unrecognized messages and errors

Private bFirstByte As Boolean = True
Private RecBuf As New Byte[255]
Private bMessage As Boolean = False
Private iByteCount As Integer = 0
Private bHMBusy As Boolean  ' waiting for delay timer to finish

' stack management
Private cQueue As New Collection  ' command buffer
Private cAckstore As New Collection
Private cMsgnr As New Collection
Private cDestDevice_id As New Collection
Private iMessageCounter As Integer = 0
Private cPayload As New Collection
Private cTimeStamp As New Collection

' pairing
Private cDevice_state As New Collection
Private sNewDevice As New String[7]

' connection management
Private tKeepAlive As Timer
Private tAckTimer As Timer
Private iCommandRetry As Integer = 0

' timesync
Private iUTCoffset As Integer
Private iDelta As Long

' data collection
Private sConf5Dump As String

'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
' Mandatory subroutine for each Module/Class to initialize:
' - The cPlugin[x].Settings are copied into local variables
' - Port/Connection will be started (any errors caught)
' - Any other code per Class
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Public Sub StartPlugin(cPl As CPluginEntry)

  KeyName = cPl.KeyName
  Instance = cPl.Instance
  If Instance <> 1 Then LogLabel = Replace(LogLabel, "] ", "#" & Instance & "] ")

  ' Copy configuration items locally
  $bEnabled = cPl.Settings["enabled"]
  $sTCPHost = cPl.Settings["tcphost"]
  $iTCPPort = cPl.Settings["tcpport"]
  $sHMLANid = cPl.Settings["hmid"]
  $bDebug = cPl.Settings["debug"]

  InterfaceId = Devices.FindInterface("HomeMatic LAN Adapter")
  If InterfaceId = 0 Then
    ErrorText = "Required InterfaceId can't be retrieved from the database!"
    WriteLog("ERROR: " & ErrorText)
    IsRunning = False
    Return
  Endif

  ' Connect/Initialize connection
  ConnectTCP()

End

'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
' Mandatory sub for each Module/Class to stop
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Public Sub StopPlugin()

  Try Disconnect()

End

'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
' Easy helper for WriteLog
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Private Sub WriteLog(sLog As String)

  Main.WriteLog(LogLabel & sLog)
  If $bDebug Then Main.WriteDebugLog(LogLabel & sLog)

End

'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
' Easy helper for WriteDebugLog
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Private Sub WriteDebugLog(sLog As String)

  If $bDebug Then Main.WriteDebugLog(LogLabel & sLog)

End

'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
' connect to the host:port
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Private Sub ConnectTCP()

  Dim iReconnectRetry As Integer = 0

  ' try to close the connection
  Try hMySocket.Close
  Try iReconnectRetry = hMySocket.ReconnectRetry

  ' get a new one - but also pass on our previous reconnect counter
  hMySocket = New CSocket(iReconnectRetry) As "MySocket"

  hMySocket.DataType = &HFF + gb.Byte
  hMySocket.Connect($sTCPHost, $iTCPPort)

  ' start keeping the HMLAN Adapter alive
  SendHMLAN("K")
  tKeepAlive = New Timer As "tKeepAlive"
  tKeepAlive.Delay = 20000
  tKeepAlive.Start

  WriteLog(PluginFriendlyName & " TCP interface connecting to " & $sTCPHost & ":" & $iTCPPort)

Catch ' some errors
  WriteLog("ERROR: " & PluginFriendlyName & " TCP interface FAILED to connect to " & $sTCPHost & ":" & $iTCPPort)
  WriteLog("ERROR: " & Error.Text)
  IsRunning = False
  ErrorText = Error.Text
  ErrorWhere = Error.Where

End

'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
' disconnect from the host
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Private Sub Disconnect()

  ' try to close the connection
  Try hMySocket.Close

  ' try stop running timers
  StopTimers()

  WriteLog(PluginFriendlyName & " TCP connection closed.")

Finally
  IsRunning = False
  ErrorText = ""
  ErrorWhere = ""

Catch
  WriteLog("ERROR: " & Error.Text)

End

'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
'
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Private Sub StopTimers()

  Try tHMBusy.Stop

End

'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
' initialize interface
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Private Sub Run()

  Dim rResult As Result

  $sMsgData = ""

  ' start keeping the HMLAN Adapter alive
  SendHMLAN("K")
  tKeepAlive = New Timer As "tKeepAlive"
  tKeepAlive.Delay = 20000
  tKeepAlive.Start

  ' define timer for interface busy
  tHMBusy = New Timer As "tHMBusy"
  tHMBusy.Stop

  ' define Timer for Ack/Nack timeouts
  tAckTimer = New Timer As "tAcktimer"
  tAckTimer.Delay = 4500                '10 x tHMBusy.Delay
  tAckTimer.Stop

  ' get offset from UTC for time calculations
  iUTCoffset = UTCoffset()

  ' set HMLAN address and time
  SendHMLAN("A" & $sHMLANid)
  SendHMLAN("C")
  SendHMLAN("Y01,01,")
  SendHMLAN("Y02,01,")
  SendHMLAN("Y03,01,")
  SendHMLAN("Y03,01,")
  SendHMLAN("T" & systemtime() & ",04,00,00000000")
  SendHMLAN("A" & $sHMLANid)

  ' setup ACK's for paired units
  rResult = Devices.FindDevicesForInterface(InterfaceId, Instance)
  If rResult And If rResult.Available Then
    For Each rResult
    SendHMLAN("+" & rResult!address & ",00,00")
    Next
  Endif

  iCommandRetry = 0
  PushStack() ' kickstart

End

'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
' peer closed tcp socket
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Public Sub MySocket_Closed()

  WriteLog("ERROR: TCP socket closed by peer.")

  IsRunning = False
  ErrorText = "TCP socket closed by peer"

  StopTimers()

End

'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
' error while connected/connecting to tcp host
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Public Sub MySocket_Error(sMsg As String)

  WriteLog("ERROR: " & sMsg)

  IsRunning = False
  ErrorText = sMsg

  StopTimers()

End

'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
' host ip address found
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Public Sub MySocket_Found()

  Log.Plugin_DNS_Found(LogLabel, $sTCPHost)

End

'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
' tcp socket is connected
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Public Sub MySocket_Ready()

  WriteLog("TCP interface connected.")
  IsRunning = True

  Run()

End

'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
' Called when we should reconnect to the tcp host
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Public Sub MySocket_Reconnect()

  ConnectTCP()

End

'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
' received data from the tcp port. vVar is gb.String
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Public Sub MySocket_Read(vVar As Variant)

  $sMsgData &= vVar

  ' Check for special character and process data - but remove CrLf
  While InStr($sMsgData, Chr(&HA))
    ProcessReceivedPacket(Mid($sMsgData, 1, InStr($sMsgData, gb.Lf) - 3))
    $sMsgData = Mid($sMsgData, InStr($sMsgData, gb.Lf) + 1)
  Wend

End

'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
' keep the HM LAN Adapter connection alive
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Public Sub tKeepAlive_Timer()

  SendHMLAN("K")
  tKeepAlive.Stop
  tKeepAlive.Start
  StackStats()

End

'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
' control devices
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Public Sub SendCommand(iDeviceId As Integer, sValue As String)

  Dim iSpace As Integer
  Dim sAttribute, sCmd, sAddress, sModel As String

  ' find last space and split there to get command and value
  iSpace = RInStr(sValue, " ")
  If iSpace = 0 Then Return

  sCmd = Left(sValue, iSpace - 1)
  sAttribute = (Right$(sValue, (Len(sValue) - iSpace)))

  ' TODO: hack from setdevice, need to check this
  sValue = "Temperature " & sValue

  ' get address of Device
  Try sAddress = Devices.FindAddressForDevice(iDeviceId)
  If Error Then Return

  ' get description of devicetype to use as model
  Try sModel = Devices.FindDeviceTypeDescriptionForDeviceId(iDeviceId)
  If Error Then Return

  If sModel = "HM_CC_TC"
    Select sCmd
      Case "Temperature"
        HM_CC_TC_Temperature(sAddress, sAttribute)
      Case "Status Request"
        HM_CC_TC_Status(sAddress)
      Case "Parameter5"
      HM_CC_TC_GetconfigParam5(sAddress)
      Case "Parameter6"
      HM_CC_TC_GetconfigParam6(sAddress)
    End Select
    Return
  Endif

End

'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
' pairing routines ---- can probably be run direct
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Private Sub ProcessPair(sAddress As String, sStep As String)

  Select sStep
    Case "Pair1"
      Pair1(sAddress)
    Case "Pair2"
      Pair2(sAddress)
    Case "Pair3"
      Pair3(sAddress)
  End Select

End

'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
' set the requested temperature (thermostat set temperature)
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Private Sub HM_CC_TC_Temperature(sAddress As String, sValue As String)

  Dim sStatusbits, sMsgtype, sSrc, sDst, sData, sCmd As String
  Dim iValue As Integer

  iValue = Val(sValue) * 2
  sStatusbits = "A0"  ' wakeup, bidi, rpten
  sMsgtype = "11"
  sSrc = $sHMLANid     ' address
  sDst = sAddress
  sData = "0202" & Hex$((iValue), 2)
  sCmd = sStatusbits & sMsgtype & sSrc & sDst & sData
  StackCommand(sCmd)
  PushStack()
  If bHMInfoLogEnabled Then WriteDebugLog("[INFO]" & Chr(9) & sAddress & " Sending new SET Temperature " & (iValue / 2) & " Degrees C")

End

'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
' read the set temperature
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Private Sub HM_CC_TC_Status(sAddress As String)

  Dim sStatusbits, sMsgtype, sSrc, sDst, sData, sCmd As String

  If bHMInfoLogEnabled Then WriteDebugLog("[INFO]" & Chr(9) & sAddress & " Requested current SET Temperature")
  sStatusbits = "A1"  ' bidi, rpten
  sMsgtype = "01"
  sSrc = $sHMLANid     ' address
  sDst = sAddress
  sData = "010E"
  sCmd = sStatusbits & sMsgtype & sSrc & sDst & sData
  StackCommand(sCmd)
  PushStack()

End

Private Sub Pair1(sAddress As String)

  Dim sStatusbits, sMsgtype, sSrc, sDst, sData, sCmd As String

  If bHMInfoLogEnabled Then WriteDebugLog(sAddress & " Writing Register 5")
  sStatusbits = "A0"  ' bidi, rpten
  sMsgtype = "01"
  sSrc = $sHMLANid     ' address
  sCmd = "+" & sSrc & ",00,00,"
  SendHMLAN(sCmd)
  sDst = sAddress
  sData = "00050000000000"
  sCmd = sStatusbits & sMsgtype & sSrc & sDst & sData
  StackCommand(sCmd)
  PushStack()

End

Private Sub Pair2(sAddress As String)

  Dim sStatusbits, sMsgtype, sSrc, sDst, sData, sCmd As String
  
  If bHMInfoLogEnabled Then WriteDebugLog(sAddress & " Writing controller address ")
  sStatusbits = "A0"  ' bidi, rpten
  sMsgtype = "01"
  sSrc = $sHMLANid     ' address
  sDst = sAddress
  sData = "000802010A" & Left$($sHMLANid, 2) & "0B" & Mid$($sHMLANid, 3, 2) & "0C" & Right$($sHMLANid, 2)
  sCmd = sStatusbits & sMsgtype & sSrc & sDst & sData
  StackCommand(sCmd)
  PushStack()

End

Private Sub Pair3(sAddress As String)

  Dim sStatusbits, sMsgtype, sSrc, sDst, sData, sCmd As String

  If bHMInfoLogEnabled Then WriteDebugLog(sAddress & " Verifying controller address")
  sStatusbits = "A0"  ' bidi, rpten
  sMsgtype = "01"
  sSrc = $sHMLANid     ' address
  sDst = sAddress
  sData = "0006"
  sCmd = sStatusbits & sMsgtype & sSrc & sDst & sData
  StackCommand(sCmd)
  PushStack()

End

Private Sub HM_CC_TC_GetconfigParam5(sAddress As String) 'experimental

  Dim sStatusbits, sMsgtype, sSrc, sDst, sData, sCmd As String

  sStatusbits = "A0"  ' bidi, rpten
  sMsgtype = "01"
  sSrc = $sHMLANid     ' address
  sDst = sAddress
  sCmd = "+" & sDst & ",00,00,"
  SendHMLAN(sCmd)
  SendHMLAN(sCmd)
  SendHMLAN(sCmd)
  sData = "02040000000005"
  'CONFIG CHANNEL 2
  'CONFIG PEER ADDRESS 000000
  'CONFIG PEER CHANNEL 0
  'CONFIG PARAM LIST 5
  sCmd = sStatusbits & sMsgtype & sSrc & sDst & sData
  StackCommand(sCmd)
  PushStack()
  If bHMInfoLogEnabled Then WriteDebugLog(sAddress & " Requesting parameter list 5")

End

Private Sub HM_CC_TC_GetconfigParam6(sAddress As String) 'experimental

  Dim sStatusbits, sMsgtype, sSrc, sDst, sData, sCmd As String

  sStatusbits = "A0"  ' bidi, rpten
  sMsgtype = "01"
  sSrc = $sHMLANid     ' address
  sDst = sAddress
  sCmd = "+" & sDst & ",00,00,"
  SendHMLAN(sCmd)
  SendHMLAN(sCmd)
  SendHMLAN(sCmd)
  sData = "02040000000006"
  'CONFIG CHANNEL 2
  'CONFIG PEER ADDRESS 000000
  'CONFIG PEER CHANNEL 0
  'CONFIG PARAM LIST 6
  sCmd = sStatusbits & sMsgtype & sSrc & sDst & sData
  StackCommand(sCmd)
  PushStack()
  If bHMInfoLogEnabled Then WriteDebugLog(sAddress & " Requesting parameter list 6")

End

'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
' message for HMLAN adapter
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Public Sub SendHMLAN(sBuffer As String)

  QueueAdd(sBuffer) ' & "\r\n")

End

'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
' add command to stack
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Public Sub StackCommand(sPayload As String)

  Dim sMsgnr, sDst, sHash As String

  sDst = Mid$(sPayload, 11, 6)
  sMsgnr = MessageCounter()

  ' populate with new commands
  sHash = sDst & sMsgnr
  cPayload.Add(sPayload, sHash)
  cAckstore.Add("STORED", sHash)
  cMsgnr.Add(sMsgnr, sHash)
  cDestDevice_id.Add(sDst, sHash)
  cTimestamp.Add(timestamp(), sHash) 'Time message went on the stack

  ' '- - - - - - - - - - - DEBUG - PRINT THE STACK - - - - - -
  ' FOR EACH sPayload IN cPayload
  '   PRINT "dst " & cPayload.Key & " NR " & cMsgnr[cPayload.key] & " Payload " & sPayload & " time " & cTimestamp[cPayload.Key] & " ACK " & cAckstore[cPayload.Key]
  ' NEXT
  ' PRINT "-------------------------------"

End

'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
' find the oldest message on the stack that is in stored state
' and push it on the queue
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Private Sub PushStack()

  Dim sLowestTimestamp, sTimestamp, sOldestKey, sRaw, sSentHash As String

  sLowestTimestamp = "FFFFFFFF"
  For Each sTimestamp In cTimestamp
    If Val("&H" & sTimestamp & "&") < Val("&H" & sLowestTimestamp & "&") And cAckstore[cTimeStamp.key] = "STORED"
    sLowestTimestamp = sTimestamp
    sOldestKey = cTimestamp.Key
    Endif
  Next

  Try sRaw = "S" & timestamp() & "," & "00,00000000,01" & "," & Hex$((UNIXtime() - iDelta), 8) & "," & cMsgnr[sOldestkey] & cPayload[sOldestkey]
  If sRaw Then
    Try sSentHash = Mid$(cPayload[sOldestKey], 11, 6) & cMsgnr[sOldestKey]
    If sSentHash Then
      tAckTimer.Start
      QueueAdd(sRaw, sSentHash)
    Endif
  Endif

End

Public Sub QueueAdd(sCommand As String, Optional SHash As String) ' add command to queue

  cQueue.Add(sCommand, Rnd)
  If sHash Then cAckstore[sHash] = "QUEUED"

  ' process it
  If bHMBusy = False Then DoQueue()

End

'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
' process items in queue
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Private Sub DoQueue()

  Dim sPacket As String

  For Each sPacket In cQueue
    WriteCommand(sPacket, cQueue.Key)
    Break ' only do first one, or wait for echo and do next one ?
  Next

End

'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
' send string to HMLAN interface
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Public Sub WriteCommand(sBuffer As String, sKey As String)

  ' return if not connected yet
  If hMySocket.Status <> Net.Connected Then Return
  ' send the message to the tcp stream
  If bHMRawLogEnabled Then WriteDebugLog("[RAW] " & Chr(9) & "TX " & sBuffer)

  hMySocket.Write(sBuffer, gb.String)

  ' remove sent command from queue
  cQueue.Remove(sKey)

  tHMBusy.Delay = 350 ' 350ms Value is critical, faster will cause the adapter to crash, if slower the thermostat falls asleep :(
  If bHMBusy = False Then bHMBusy = True
  tHMBusy.Start

End

'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
' interface busy reset
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Public Sub tHMBusy_Timer()

  bHMBusy = False
  tHMBusy.Stop

  If cQueue.Count Then ' if there are more commands left in queue, send next one
    DoQueue()
  Endif

End

'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
' process the message received from the HM-LAN interface
' all messages are , separated text strings, closed with CR/LF
' so far 5 different types found
' with 1 segment: Response to D1 or D2 etc, don't know what it is
' with 3 segments: received when sending a D to the interface
' with 4 segments: the HM-LAN Ack I00, also received when sending a Y to the interface
' with 6 segments: Routine messages and pairing
' with 7 segments: Version information, response to "K"
' sending B turns on the red light and waits (for new FW ?)
' monitor (and store for transmission) received signal strength (later)
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Private Sub ProcessReceivedPacket(sData As String)

  Dim iMaxSegments, iHMLANUptimecounter As Integer
  Dim sMsgSegments As String[]

  bMessage = False
  bFirstByte = True

  sMsgSegments = Split(sData)
  iMaxSegments = sMsgSegments.Count
  If bHMRawLogEnabled Then WriteDebugLog("[RAW] " & Chr(9) & "RX " & sData)

  Select iMaxSegments
    Case 1       ' WriteDebugLog("Dx " & (sMsgSegments[0]))
    Case 3       ' WriteDebugLog("D " & (sMsgSegments[0]) & " Seg1 " & (sMsgSegments[1]) & " T " & (sMsgSegments[2]))
    Case 4       ' WriteDebugLog("Y " & (sMsgSegments[0]) & " Seg1 " & (sMsgSegments[1]) & " T " & (sMsgSegments[2]) & " Seg3 " & (sMsgSegments[3]))
    Case 6
      StackManager(sMsgSegments)
      If bHMRadioLogEnabled And If Left$(sMsgSegments[0]) = "E" Then WriteDebugLog("[RADIO]" & Chr(9) & "RX " & Right$(sMsgSegments[0], 6) & " RSSI: " & Val("&H" & sMsgSegments[4]))
      ProcessRadioMessage(sMsgSegments)
    Case 7
       If bHMInfoLogEnabled Then WriteDebugLog("[INFO]" & Chr(9) & (sMsgSegments[0]) & ", Uptime " & (Val("&H" & sMsgSegments[5]) Div 1000) & " Seconds, UNTRANSMITTED COMMANDS: " & iStackCountUntransmitted & ", OPEN COMMANDS: " & iStackCount & " for " & (Val("&H" & sMsgSegments[6] & "&")) & " DEVICE(S)")
       sHMLANReportedFW = sMsgSegments[1]
       sHMLANReportedSerial = sMsgSegments[2]
       sHMLANReportedAddress = sMsgSegments[4]
       iHMLANUptimecounter = Val("&H" & sMsgSegments[5])
       iDelta = UNIXtime() - iHMLANUptimecounter
    Case Else
       If bHMErrorLogEnabled Then WriteDebugLog("ERROR: '" & Error.Text & "' at '" & Error.Where & "' Parsing HM data packet: ")
       DisplayPacket(RecBuf)
  End Select

  ' do some errorchecking on the segmentdata, notify if something's not normal.
  ' idea: notify for low rssi values.

  'IF iMaxSegments > 0 THEN Process_Raw_Messagetypes(iMaxSegments, sMsgSegments)

End

'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
' process the message from the radio
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Private Sub ProcessRadioMessage(sSegments As String[])

  Dim sSrc, sDst, sMsgnr, sMsgtype, sPayload, sCmd As String
  Dim bAckRequested, bWakeup, bAsleep, bBroadcast As Boolean = False
  Dim iPayload_length As Integer

  sMsgnr = Left(sSegments[5], 2)
  bWakeUp = BTst(Val("&H" & (Mid(sSegments[5], 3, 2)) & "&"), 0)       ' for later use and diagnostics
  bAsleep = BTst(Val("&H" & (Mid(sSegments[5], 3, 2)) & "&"), 1)       ' for later use and diagnostics
  bBroadcast = BTst(Val("&H" & (Mid(sSegments[5], 3, 2)) & "&"), 2)    ' for later use and diagnostics
  bAckRequested = BTst(Val("&H" & (Mid(sSegments[5], 3, 2)) & "&"), 5) ' for later use and diagnostics
  sMsgtype = (Mid(sSegments[5], 5, 2))                                 ' &00 &01 &02, &10, &58 &70
  sSrc = (Mid(sSegments[5], 7, 6))
  sDst = (Mid(sSegments[5], 13, 6))
  sPayload = (Right(sSegments[5], -18))
  iPayload_length = Len(Right(sSegments[5], -18))                      ' for later use and diagnostics

  '~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  ' Messagetypes :
  ' &00 config request from Device
  ' &01 config message to Device
  ' &02 normally a plain Ack
  ' &10 status from device, sometimes with ack request
  ' &70 weather info
  ' &58 status from radiator valve
  '~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  If bHMRadioLogEnabled Then WriteDebugLog("[RADIO]" & Chr(9) & "RX " & sSegments[5] & IIf(bAckRequested, "    ACKREQ", "") & IIf(bWakeUp, " WAKEUP", "") & IIf(bBroadcast, " BROADCAST", "") & IIf(bAsleep, " SLEEPING", ""))
  If sMsgtype = "02" Then
    If bHMRadioLogEnabled And sSrc <> $sHMLANid Then WriteDebugLog("[RADIO]" & Chr(9) & "TX " & sSrc & CalcRSSI(Val("&H" & Right$(sPayload, 2) & "&")))
  Endif
  If Sdst = $sHMLANid And bAckRequested = True And sMsgtype = "3F" Then
    sCmd = "+" & sSrc & ",02,00,"
    SendHMLAN(sCmd)
    sCmd = ("S" & Timestamp() & ",00,00000000,01," & Hex$((UNIXtime() - iDelta), 8) & "," & sMsgnr & "803F" & sDst & sSrc & "0204" & Systemtime())
    QueueAdd(sCmd)
  Endif
  If Sdst = $sHMLANid And bAckRequested = True And sMsgtype <> "00" And sMsgtype <> "3F" And Left$(sSegments[0], 1) = "E" Then
    sCmd = "+" & sSrc & ",02,00,"
    SendHMLAN(sCmd)
    sCmd = ("S" & Timestamp() & ",00,00000000,01," & Hex$((UNIXtime() - iDelta), 8) & "," & sMsgnr & "8002" & sDst & sSrc & "00")
    QueueAdd(sCmd)
  Endif
  If bHMPairEnabled Then Pair_me(sMsgnr, sSrc, sPayload, sMsgtype)
  Display_Message(sSegments)

End

'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
' respond to the pairing request if bHMPairEnabled
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Private Sub Pair_me(sMsgnr As String, sNewDevice_address As String, sPayload As String, sMsgtype As String)

  Dim sNewDevice_serH, sNewDevice_serA, sDummy, sValue, sType As String
  Dim sValues As String[]
  Dim iCnt, iDeviceId As Integer
  Dim rDeviceInfo As Result

  If sMsgtype = "00" ' received a pairing request while pairing is enabled
    sNewDevice[0] = sNewDevice_address      ' address
    sNewDevice[2] = Left(sPayload, 2)       ' firmware version
    sNewDevice[3] = Mid(sPayload, 3, 4)     ' device type
    sNewDevice[4] = Mid(sPayload, 7, 2)     ' device sub type
    sNewDevice[5] = Mid(sPayload, 15, 4)    ' device class (not used yet, but maybe later)
    sNewDevice[6] = Mid(sPayload, 26, 6)    ' device additional information (not used yet)
    sNewDevice_serH = Mid(sPayload, 9, 20)  ' device serial in hex char

    If bHMInfoLogEnabled Then WriteDebugLog("Device serial in HEX '" & sNewDevice_serH & "'")
    For iCnt = 1 To 17 Step 2
      sNewDevice_serA &= Chr(Val("&" & (Mid(sNewDevice_serH, iCnt, 2))))
    Next
    sNewDevice[1] = sNewDevice_serA
    If bHMInfoLogEnabled Then WriteDebugLog("Device serial in ASC '" & sNewDevice_serA & "'")

    If bHMInfoLogEnabled Then WriteDebugLog("[INFO]" & Chr(9) & "Pairing Request from '" & sNewDevice[0] & "' of the type '" & sNewDevice[3] & "' and subtype '" & sNewDevice[4] & "'")
    rDeviceInfo = Main.hDB.Exec("SELECT * FROM devicetypes_homematic WHERE type_code = &1", sNewDevice[3])
    If rDeviceInfo!commands = "none supported"
      If bHMErrorLogEnabled Then WriteDebugLog("[ERROR]" & Chr(9) & "This device is not (yet) supported " & sNewDevice[0] & ", " & sNewDevice[1] & ", " & sNewDevice[2] & ", " & sNewDevice[3] & ", " & sNewDevice[4] & ", " & sNewDevice[5])
    Else 'supported
      ' just clear any open commands for this device
      For Each sDummy In cDestDevice_id
        If sDummy = sNewDevice_address Then cDestDevice_id.Remove(cDestDevice_id.key)
      Next
      ProcessPair(sNewDevice_address, "Pair1")
      ProcessPair(sNewDevice_address, "Pair2")
      ProcessPair(sNewDevice_address, "Pair3")
      cDevice_state[sNewDevice_address] = "pairing complete"
      Wait 2
      For Each sDummy In cDestDevice_id
        If sDummy = sNewDevice_address Then cDevice_state[sNewDevice_address] = "pairing incomplete"
      Next
       ' insert device in devices table if pairing was successful
      If cDevice_state[sNewDevice_address] = "pairing complete" Then
        rDeviceInfo = Main.hDB.Exec("SELECT * FROM devicetypes_homematic WHERE type_code = &1", sNewDevice[3])
        sValue = rDeviceInfo!values
        sValues = Split(sValue)
        sType = rDeviceInfo!type
        ' check if device exists with this address.
        iDeviceId = Devices.Find(Instance, sNewDevice_address, InterfaceId, sType, sNewDevice_serA)
        ' If Not iDeviceId Then ' insert
        '   sNewDevice_Id = Devices.AutoCreateDevice(sNewDevice_address, InterfaceId, sType, sNewDevice_serA)
        '   rResult = Main.hDB.Exec("SELECT id FROM devices WHERE address = &1", sNewDevice_address)
        '   sQuery = "CREATE TABLE domotigalogs." & rResult!id & " (id int, LastSeen CHAR(64), lastChanged CHAR(6))"
        '   Main.hDB.Exec(sQuery)
        '   For Icnt = 0 To sValues.Count - 1
        '     sQuery = "ALTER TABLE domotigalogs." & rResult!id & " ADD COLUMN " & sValues[iCnt] & " FLOAT"
        '     Main.hDB.Exec(sQuery) ' create external log file
        '   Next
        ' Else ' it already exists
        '   If bHMErrorLogEnabled Then WriteDebugLog( "Device with address " & sNewDevice_address & " already exists. Not creating any new tables. Delete the device and logtables first to clear old device data")
        ' Endif ' autocreate
      Endif ' pairing
    Endif ' supported
  Endif ' msg 00

End

'----------------------------------------------
' display and log messages
'----------------------------------------------
Private Sub Display_Message(sSegments As String[])

  Dim sSrc, sDst, sMsgnr, sMsgtype, sPayload As String
  Dim bAckRequested, bWakeup, bAsleep, bBroadcast As Boolean = False
  Dim iDeviceId, iHumidity, iValvestate, iPayload_length As Integer
  Dim fTemperature As Float
  Dim rResult As Result

  sMsgnr = Left(sSegments[5], 2)
  bWakeUp = BTst(Val("&H" & (Mid(sSegments[5], 3, 2)) & "&"), 0)
  bAsleep = BTst(Val("&H" & (Mid(sSegments[5], 3, 2)) & "&"), 1)
  bBroadcast = BTst(Val("&H" & (Mid(sSegments[5], 3, 2)) & "&"), 2)
  bAckRequested = BTst(Val("&H" & (Mid(sSegments[5], 3, 2)) & "&"), 5)
  sMsgtype = (Mid(sSegments[5], 5, 2))  ' %1 &2, &10, &58 &70 &00
  sSrc = (Mid(sSegments[5], 7, 6))      ' sending device id
  sDst = (Mid(sSegments[5], 13, 6))     ' receiving device id
  sPayload = (Right(sSegments[5], -18))
  iPayload_length = Len(Right(sSegments[5], -18))

  Try rResult = Main.hDB.Exec("SELECT id, devicetype_id FROM devices WHERE address = &1", sSrc) ' don't bail out on unknown devices
  Try rResult = Main.hDB.Exec("SELECT description FROM devicetypes WHERE id = &1", rResult!devicetype_id)
  If rResult.Available Then
    Select rResult!description
      Case "HM_CC_TC"
        Select sMsgtype
          Case "70"
            iHumidity = (ascii2hex(Mid(sSegments[5], 23, 2)))
            fTemperature = (ascii2hex(Mid(sSegments[5], 19, 4))) / 10
            iDeviceId = Devices.Find(Instance, sSrc, InterfaceId, "HM_CC_TC")
            If iDeviceId Then
              Devices.ValueUpdate(iDeviceId, 2, fTemperature, Devices.ValueType_Temperature)
              Devices.ValueUpdate(iDeviceId, 3, iHumidity, Devices.ValueType_Humidity)
            Endif
            If bHMInfoLogEnabled Then WriteDebugLog("[INFO]" & Chr$(9) & sSrc & " Temperature " & fTemperature & " Humidity " & iHumidity)
          Case "58"
            iValvestate = (ascii2hex(Mid(sSegments[5], 21, 2))) / 2.55
            iDeviceId = Devices.Find(Instance, sSrc, InterfaceId, "HM_CC_TC")
            If bHMInfoLogEnabled Then WriteDebugLog("[INFO]" & Chr$(9) & sSrc & " Requesting Valve " & sDst & " for " & iValvestate & " % open")
            If iDeviceId Then Devices.ValueUpdate(iDeviceId, 4, iValvestate)
          Case "02"
            If bAsleep = False And bAckRequested = False And Mid$(sSegments[5], 19, 4) = "0102" Then
             fTemperature = (ascii2hex(Mid(sSegments[5], 23, 2))) / 2
             If bHMInfoLogEnabled Then WriteDebugLog("[INFO]" & Chr$(9) & sSrc & " Set Temperature " & fTemperature)
             iDeviceId = Devices.Find(Instance, sSrc, InterfaceId, "HM_CC_TC")
             If iDeviceId Then Devices.ValueUpdate(iDeviceId, 1, fTemperature, Devices.ValueType_Temperature)
            Else If bAsleep = False And bAckRequested = False And Mid$(sSegments[5], 19, 2) = "00" Then
              If bHMInfoLogEnabled Then WriteDebugLog("[INFO]" & Chr$(9) & sSrc & " Awake ")
             Else
              If bHMErrorLogEnabled Then WriteDebugLog("[ERROR]" & Chr$(9) & sSrc & " Message type " & sMsgtype & " with unsupported content " & Left$(sSegments[5], -2))
            Endif
          Case "10"
            If (bAsleep = False) And If (bAckRequested = True) And If (Mid$(sSegments[5], 19, 4) = "0602") Then
              fTemperature = (ascii2hex(Mid(sSegments[5], 23, 2))) / 2
              If bHMInfoLogEnabled Then WriteDebugLog("[INFO]" & Chr$(9) & sSrc & " Manual Override Temperature " & fTemperature)
              iDeviceId = Devices.Find(Instance, sSrc, InterfaceId, "HM_CC_TC")
              If iDeviceId Then Devices.ValueUpdate(iDeviceId, 1, fTemperature, Devices.ValueType_Temperature)
             Else If Left(sSegments[0]) = "E" And (bAsleep = False) And If (bAckRequested = True) And If (Mid$(sSegments[5], 19, 2) = "03") Then
              sConf5Dump &= Left(Right(sPayload, -4), -2) ' experimental, only through quickset after db modification (add the commands)
             Else
              If bHMErrorLogEnabled Then WriteDebugLog("[ERROR]" & Chr$(9) & sSrc & "Message type " & sMsgtype & " with unsupported content " & Left$(sSegments[5], -2))
            Endif
          Case "3F"
            If bHMInfoLogEnabled Then WriteDebugLog("[INFO]" & Chr(9) & sSrc & " Timesync ") ' done in Ack message"
          Case "00"
            If bHMErrorLogEnabled And bHMPairEnabled = False Then WriteDebugLog("[INFO]" & Chr(9) & "Received Pairing request from " & sSrc & " while not in Pairing mode")
          Case Else
            If bHMErrorLogEnabled Then WriteDebugLog("[ERROR] Unknown message " & Left$(sSegments[5], -2) & " from address " & sSrc)
        End Select ' HM-CC-TC
      Case Else
        If bHMErrorLogEnabled Then WriteDebugLog("[ERROR]" & Chr(9) & "Unknown Devicetype (Check Database)")
    End Select ' devices
  Else
    If bHMErrorLogEnabled Then
      If sSrc = $sHMLANid Then
         'WriteDebugLog( "[RADIO]" & Chr(9) & "ECHO TX " & sSegments[5])
      Else
        WriteDebugLog("[ERROR]" & Chr(9) & "Received message " & sSegments[5] & " from unknown device with address " & sSrc)
      Endif
    Endif
  Endif

End

'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
' if a command has not been confirmed by the HMLAN Adapter after 3.5 seconds
' assume that it was lost and stop waiting for it, send it again.
' after 25 retries stop retrying, the cable is probably disconnected
' During pairing 10 commands are going out in sequence, each adding a THMBusy delay of 350ms
' ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Public Sub tAckTimer_Timer()

  tAckTimer.Stop
  Restack()
  If iCommandRetry < 25
    Inc iCommandRetry
    If iCommandRetry Mod 5 = 0 And bHMErrorLogEnabled Then WriteDebugLog("retries left: " & (25 - iCommandRetry))
    PushStack() ' retry and continue
   Else
    If bHMErrorLogEnabled Then WriteDebugLog("Exceeded 25 retry attempts, retry mechanism disabled until HMLAN Adapter is reachable again")
  Endif

End

Private Sub Restack()

  Dim sSrc, sPayload As String

  For Each sSrc In cDestDevice_id
    If cAckstore[cDestDevice_id.Key] = "QUEUED"
      sPayload = cPayload[cDestDevice_id.Key]
      cPayload.Remove(cDestDevice_id.Key)
      cAckstore.Remove(cDestDevice_id.Key)
      cMsgnr.Remove(cDestDevice_id.Key)
      cTimestamp.Remove(cDestDevice_id.Key)
      cDestDevice_id.Remove(cDestDevice_id.Key)
      StackCommand(sPayload)
    Endif
  Next

End

Public Sub Timestamp() As String ' mS since 00:00

  Dim sDateUnits As New String[4]
  Dim iMilliseconds, iSeconds As Integer

  sdateUnits = Split(Format$(Now, "hh:nn:ssu"), ":")
  iMilliseconds = Val(Right$(sDateUnits[2], 3))
  iseconds = Val(Left$(sDateUnits[2], 2))
  iMilliseconds = 3600000 * sDateUnits[0] + 60000 * sDateUnits[1] + 1000 * iSeconds + iMilliseconds
  Return Hex$(iMilliseconds, 8)

End

' seconds since 01/01/2000
Private Sub Systemtime() As String

  Dim fTimestamp As Float
  Dim iTimestamp As Integer
  Dim sHexTimestamp As String

  fTimestamp = DateDiff("01/01/2000 00:00:00", Now, gb.Second)
  iTimestamp = fTimestamp - iUTCoffset
  sHexTimestamp = Hex$(iTimestamp, 8)

  Return sHexTimestamp

End

' offset in seconds from UTC
Private Sub UTCoffset() As Integer

  Dim sUTCtime As String
  Dim iLOCALtime As Integer

  Exec ["date", "-u", "+%s"] To sUTCtime
  iLOCALtime = DateDiff("01/01/1970 00:00:00", Now, gb.Second)
  Return iLOCALtime - Val(sUTCtime)

End

' unix time in mS since epoch
Public Sub UNIXtime() As Long

  Dim iReturnValue As Long
  Dim sReturnValue As String

  Exec ["date", "-u", "+%s%N"] To sReturnValue
  iReturnValue = (Val(sReturnValue)) / 1000000
  Return iReturnValue

Catch
  WriteDebugLog("Error when trying to run 'date': " & Error.Text & ".")

End

Private Sub DisplayPacket(bBuf As Byte[]) As String

  Dim sMsg As String
  Dim iCnt As Integer

  For iCnt = 0 To iByteCount
    sMsg &= Chr(bBuf[iCnt])
  Next
  Return sMsg

End

Private Sub MessageCounter() As String

  If iMessageCounter < 255 Then
    Inc iMessageCounter
  Else
    iMessageCounter = 0
  Endif
  Return Hex$(iMessagecounter, 2)

End

Private Function ascii2hex(sAsciiString As String) As Short

  Dim iDecResult As Short

  iDecResult = Val("&H" & sAsciiString & "&")
  If iDecResult > 16384 Then iDecResult = - (32768 - iDecResult)
  Return iDecResult

End

Private Sub StackManager(sSegments As String[])

  Dim sSrc, sDst, sMsgnr, sDummy, sCmd, sHash, sPayload As String
  'DIM sHMRssi AS String  ' signal strength from device to HM adapter, not yet implemented
  'DIM sDeviceRssi AS String  'signal strength from HM adapter to device, not yet implemented
  Dim bPending, bAckRequested, bBroadcast, bAsleep As Boolean = False

  sMsgnr = Left(sSegments[5], 2)
  bAsleep = BTst(Val("&H" & (Mid(sSegments[5], 3, 2)) & "&"), 1)       ' for later use and diagnostics
  bBroadcast = BTst(Val("&H" & (Mid(sSegments[5], 3, 2)) & "&"), 2)    ' for later use and diagnostics
  bAckRequested = BTst(Val("&H" & (Mid(sSegments[5], 3, 2)) & "&"), 5) ' for later use and diagnostics
  sSrc = (Mid(sSegments[5], 7, 6))
  sDst = (Mid(sSegments[5], 13, 6))

  ' process received ACKs AND NACKs

  ' check for NACK
  sHash = sDst & sMsgnr
  If (cMsgnr.exist(sHash) And sSegments[1] = "0008") Then
    cAckstore[sHash] = "NACK"
    sCmd = "+" & sDst & ",02,00,"
    SendHMLAN(sCmd)
    'DEBUG sDst & " " & sMsgnr & " NACK Received"
    tAckTimer.Stop
    PushStack() ' now run the next command on the queue
  Endif

  sHash = sSrc & sMsgnr

  ' check for ACK
  If (cMsgnr.Exist(sHash) And sSegments[1] = "0001") Then
    cPayload.Remove(sHash)
    cAckstore.Remove(sHash)
    cMsgnr.Remove(sHash)
    cDestDevice_id.Remove(sHash)
    cTimestamp.Remove(sHash)
    'DEBUG sSrc & " " & sMsgnr & " ACK Received"
    tAckTimer.Stop
    PushStack() ' now run the next command on the queue
  Endif

  ' check for open messages on the stack
  If sSegments[1] = "0081" Then
    For Each sDummy In cDestDevice_id
      If cAckstore[cDestDevice_id.Key] = "NACK" And Left$(cDestDevice_id.Key, 6) = sSrc
        sPayload = cPayload[cDestDevice_id.Key]
        cPayload.Remove(cDestDevice_id.Key)
        cAckstore.Remove(cDestDevice_id.Key)
        cMsgnr.Remove(cDestDevice_id.Key)
        cTimestamp.Remove(cDestDevice_id.Key)
        cDestDevice_id.Remove(cDestDevice_id.Key)
        'DEBUG sSrc & " " & sMsgnr & " Delayed NACK Received"
        'put all commands for this device back in the queue
        StackCommand(sPayload)
      Endif
    Next
    PushStack()
  Endif

  ' command completed is 8010 and 8002 (no ack requested)
  For Each sDummy In cDestDevice_id
   If sDummy = sSrc Then bPending = True ' if we still have commands in the stack, don't clear the status
  Next
  ' rule out all other messages 
  If bPending = False And bAckRequested = False And bBroadcast = False And bAsleep = False And sdst = $sHMLANid Then
    SendHMLAN("-" & sSrc)
    SendHMLAN("+" & sSrc)
  Endif

End

'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
' analyze the stack.
' untransmitted: No response from the HMLAN adapter
' stack count: No response from remote device
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Private Sub StackStats()

  Dim sDummy As String

  iStackCountUntransmitted = 0
  iStackCount = 0
  For Each sDummy In cAckstore
    If sDummy = "QUEUED" Then Inc iStackCountUntransmitted
    If sDummy = "NACK" Then Inc iStackCount
  Next

End

Private Sub CalcRSSI(fRSSI As Float) As String

  If fRSSI Then
    Return " RSSI: " & IIf(fRSSI >= 128, (fRSSI - 256) / 2 - 74, fRSSI / 2 - 74)
  Else
    Return ""
  Endif

End

