' Gambas module file

' Description:
' JSON.module
' Provides JSON encode and decode functions.

' Development Status:
' Ported from Gambas3 gb.web component.

' DomotiGa - an open source home automation program.
' Copyright(C) 2010 Ron Klinkien

' Read file called COPYING for license details.

EXPORT

PRIVATE $sStr AS String
PRIVATE $iPos AS Integer

PRIVATE SUB GetChar() AS String

  DIM sCar AS String

  IF $iPos > Len($sStr) THEN RETURN
  sCar = Mid$($sStr, $iPos, 1)
  INC $iPos
  RETURN sCar

END

PRIVATE SUB ReadChar() AS String

  DIM sCar AS String

  DO
    sCar = GetChar()
    IF NOT sCar THEN RETURN
    IF sCar > " " THEN RETURN sCar
  LOOP

END

PRIVATE SUB ReadToken() AS String

  DIM sToken, sCar AS String

  sCar = ReadChar()
  IF NOT IsLetter(sCar) THEN RETURN sCar

  sToken = sCar
  DO
    sCar = GetChar()
    IF NOT sCar THEN BREAK
    IF NOT IsLetter(sCar) THEN
      DEC $iPos
      BREAK
    ENDIF
    sToken &= sCar
  LOOP

  RETURN sToken

END

PRIVATE SUB ReadString() AS String

  DIM sCar, sString AS String
  DIM iPos AS Integer

  DO
    sCar = GetChar()
    IF NOT sCar THEN Error.Raise("Non terminated string")
    IF sCar = Chr$(34) THEN RETURN sString
    IF sCar = "\\" THEN
      sCar = GetChar()
      IF NOT sCar THEN Error.Raise("Non terminated string")
      iPos = InStr("bfrtn", sCar)
      IF iPos THEN
       ' sCar = Mid$("\b\f\r\t\n", iPos, 1)
      ELSE IF sCar = "u" THEN
        TRY sCar = String.Chr$(Val("&H" & Mid$($sStr, $iPos, 4)))
        IF NOT ERROR THEN $iPos += 4
      ELSE
        ' keep character
      ENDIF
    ENDIF
    sString &= sCar
  LOOP

END

PRIVATE SUB ReadObject() AS Collection

  DIM sCar, sKey AS String
  DIM cObject AS NEW Collection

  DO
    sCar = ReadChar()
    IF sCar = "}" THEN RETURN cObject
    IF sCar <> Chr$(34) THEN Error.Raise("String expected")
    sKey = ReadString()
    sCar = ReadChar()
    IF sCar <> ":" THEN Error.Raise("Colon expected")
    cObject[sKey] = ReadValue()
    sCar = ReadChar()
    IF sCar = "}" THEN RETURN cObject
    IF sCar <> "," THEN Error.Raise("Comma expected")
  LOOP

END

PRIVATE SUB ReadArray() AS Variant[]

  DIM sCar, sKey AS String
  DIM aArray AS NEW Variant[]

  DO
    sCar = ReadChar()
    IF sCar = "]" THEN RETURN aArray
    DEC $iPos
    aArray.Add(ReadValue())
    sCar = ReadChar()
    IF sCar = "]" THEN RETURN aArray
    IF sCar <> "," THEN Error.Raise("Comma expected")
  LOOP

END

PRIVATE SUB ReadNumber(sNumber AS String) AS Variant

  DIM sCar AS String
  DIM vNumber AS Variant

  DO
    sCar = GetChar()
    IF NOT sCar THEN BREAK
    IF InStr("-+0123456789eE.", sCar) = 0 THEN
      DEC $iPos
      BREAK
    ENDIF
    sNumber &= sCar
  LOOP

  TRY vNumber = CFloat(sNumber)
  IF IsNull(vNumber) THEN Error.Raise("Incorrect number")
  RETURN vNumber

END

PRIVATE SUB ReadValue() AS Variant

  DIM sCar AS String = ReadToken()

  IF sCar = "{" THEN
    RETURN ReadObject()
  ELSE IF sCar = "[" THEN
    RETURN ReadArray()
  ELSE IF sCar = Chr$(34) THEN
    RETURN ReadString()
  ELSE IF sCar = "-" OR IF IsDigit(sCar) THEN
    RETURN ReadNumber(sCar)
  ELSE IF sCar = "null" THEN
    RETURN NULL
  ELSE IF sCar = "true" THEN
    RETURN TRUE
  ELSE IF sCar = "false" THEN
    RETURN FALSE
  ELSE
   ' Error.Raise("Incorrect token: " & Quote(sCar))
  ENDIF

END

PRIVATE SUB WriteValue(vVal AS Variant)

  DIM sStr AS String
  DIM iPos AS Integer
  DIM aArray AS Array
  DIM cCol AS Collection

  SELECT CASE TypeOf(vVal)

    CASE gb.Null
      $sStr &= "null"

    CASE gb.Boolean
      IF vVal THEN
        $sStr &= "true"
      ELSE
        $sStr &= "false"
      ENDIF

    CASE gb.Byte, gb.Short, gb.Integer, gb.Long, gb.Float
      $sStr &= CStr(vVal)

    CASE gb.Date
      $sStr &= Chr$(34) & CStr(vVal) & Chr$(34)

    CASE gb.String
      sStr = Quote(vVal)
      DO
        iPos = InStr(sStr, "\\", iPos + 1)
        IF iPos = 0 THEN BREAK
        IF Mid$(sStr, iPos + 1, 1) = "x" THEN
'         Mid$(sStr, iPos, 4) = "\\u00" & Mid$(sStr, iPos + 1, 2)
        ELSE
          INC iPos
        ENDIF
      LOOP
      $sStr &= sStr

    CASE ELSE
      IF vVal IS Array THEN
        aArray = vVal
        $sStr &= "["
        FOR iPos = 0 TO vVal.Max
          IF iPos THEN $sStr &= ", "
          WriteValue(aArray[iPos])
        NEXT
        $sStr &= "]"
      ELSE IF vVal IS Collection THEN
        cCol = vVal
        $sStr &= "{"
        FOR EACH vVal IN cCol
          IF iPos THEN $sStr &= ", "
          WriteValue(cCol.Key)
          $sStr &= ": "
          WriteValue(vVal)
          INC iPos
        NEXT
        $sStr &= "}"
      ENDIF

  END SELECT

END

PUBLIC SUB Decode(JSONString AS String) AS Variant

  DIM vVal AS Variant

  $sStr = JSONString
  $iPos = 1
  vVal = ReadValue()
  $sStr = ""
  RETURN vVal

END

PUBLIC SUB Encode(Value AS Variant) AS String

  $sStr = ""
  WriteValue(Value)
  RETURN $sStr

END
