' Gambas class file

' Description:
' CxPL.class
' Provide basic support for the xPL protocol.

' Development Status:
' Just started developing this one, not 100% complete yet.

' DomotiGa - an open source home automation program.
' Copyright(C) 2008-2011 Ron Klinkien

' Read file called COPYING for license details.

PRIVATE CONST VENDOR AS String = "domotiga-xpl"

PROPERTY xPLDebug AS Boolean
PRIVATE bxPLDebug AS Boolean
PROPERTY Interface AS String
PRIVATE sInterface AS String
PROPERTY HeartBeatTime AS Integer
PRIVATE iHeartBeatTime AS Integer
PROPERTY TargetHost AS String
PRIVATE sTargetHost AS String
PROPERTY OurIPAddress AS String
PRIVATE sOurIPAddress AS String

PUBLIC hxPLListener AS NEW UdpSocket
PUBLIC hxPLSender AS NEW UdpSocket

PRIVATE iListenerPort AS Integer = 50000

PUBLIC tHBeatTimer AS Timer
PUBLIC xPLMsg AS NEW CxPLMsg

PUBLIC FUNCTION StartListener() AS Boolean

  DIM iOffset AS Integer

  ' try to close the connection
  TRY hxPLListener.Close

  ' get a new one
  hxPLListener = NEW UdpSocket AS "xPLListener"

  FOR iOffset = 0 TO 5
    iListenerPort += iOffset
    ' [GB2:BIND] TRY hxPLListener.Bind(iListenerPort)
    TRY hxPLListener.Port = iListenerPort
    TRY hxPLListener.Bind()
    IF NOT ERROR THEN
      ' start hbeat timer to stay connected to hub
      tHBeatTimer = NEW Timer AS "tHBeatTimer"
      tHBeatTimer.Delay = 60000 * iHeartBeatTime ' heartbeat interval
      tHBeatTimer.Start
      SendHeartBeat()
      RETURN TRUE
    ENDIF
  NEXT
  RETURN FALSE

CATCH
  RETURN FALSE

END

PUBLIC SUB tHBeatTimer_Timer()

  SendHeartBeat()

END

PUBLIC SUB xPLListener_Read()

  DIM sData AS String

  TRY READ #hxPLListener, sData, Lof(hxPLListener)
  IF ERROR THEN
    Main.WriteDebugLog(("[xPL] Error reading data from udp socket! -> ") & Error.Text)
  ELSE
    IF ValidateMsg(sData) THEN
      ProcessData(xPLExtract(sData))
    ELSE
      Main.WriteDebugLog(("[xPL] Received an invalid xPL message!"))
    ENDIF
  ENDIF
  IF bxPLDebug THEN Main.WriteDebugLog("[xPL] < " & sData)

END

PRIVATE SUB ValidateMsg(sData AS String) AS Boolean

  DIM sRegExp AS Regexp
  DIM sPattern AS String = "^xpl-(?<msgtype>trig|stat|cmnd)\n{\n(?:hop=\\d\n" &
   "|source=(?<sv>[0-9a-z]{1,8})-(?<sd>[0-9a-z]{1,8})\\.(?<si>[0-9a-zA-Z/-]{1,16})\n" &
   "|target=(?<target>(?<tv>[0-9a-z]{1,8})-(?<td>[0-9a-z]{1,8})\\.(?<ti>[0-9a-z/-]{1,16})|\\*)\n){3}" &
   "\\}\n" &
   "(?<class>[0-9a-z/-]{1,8})\\.(?<type>[0-9a-z/-]{1,8})\n" &
   "\\{\n" &
   "(?:(?<key>[0-9a-z/-]{1,16})=(?<val>[\x20-\xFF]{0,})\n)*" &
   "\\}\n$"

  sRegExp = NEW Regexp(sData, sPattern, Regexp.MultiLine)
  IF sRegExp.Offset = 0 THEN
    RETURN TRUE   ' valid
  ELSE
    RETURN FALSE  ' not valid
  ENDIF

END

PRIVATE SUB ProcessData(oxPLMsg AS Object)

  DIM axPLSources AS Object[] = [Main.hRFXComxPL]
  DIM oSource AS Object
  DIM bFound AS Boolean = FALSE

  oxPLMsg.Source = GetHeaderValueFromKey(oxPLMsg, "source")
  SELECT oxPLMsg.Type
    CASE "xpl-stat", "xpl-trig", "xpl-cmnd"
      IF oxPLMsg.Source = VENDOR & "." & System.Host THEN
        IF Main.hxPL.xPLDebug THEN Main.WriteDebugLog(("[xPL] Received message from ourselves, ignore."))
        bFound = TRUE
      ELSE
        FOR EACH oSource IN axPLSources
          IF oSource THEN
            IF oxPLMsg.Source = oSource.RXAddress THEN
              oSource.ProcessxPLMsg(oxPLMsg)
              bFound = TRUE
            ENDIF
          ENDIF
        NEXT
      ENDIF
    CASE ELSE
      Main.WriteDebugLog(("[xPL] Received unsupported message type '" & oxPLMsg.Type & "'"))
  END SELECT
  IF bFound = FALSE AND IF Main.hxPL.xPLDebug THEN Main.WriteDebugLog(("[xPL] Didn't find any matching xPL interface with source address '") & oxPLMsg.Source & "'")

END

PUBLIC SUB GetHeaderValueFromKey(oxPLMsg AS CxPLMsg, sKey AS String) AS String

  DIM iCnt AS Integer

  FOR iCnt = 0 TO oxPLMsg.HeaderName.Max
    IF oxPLMsg.HeaderName[iCnt] = sKey THEN RETURN oxPLMsg.HeaderValue[iCnt]
  NEXT
  RETURN

END

PUBLIC SUB GetBodyValueFromKey(oxPLMsg AS CxPLMsg, sKey AS String) AS String

  DIM iCnt AS Integer

  FOR iCnt = 0 TO oxPLMsg.BodyName.Max
    IF oxPLMsg.BodyName[iCnt] = sKey THEN RETURN oxPLMsg.BodyValue[iCnt]
  NEXT
  RETURN

END

PRIVATE SUB xPLExtract(sMsg AS String) AS CxPLMsg

  DIM xPLMsg AS NEW CxPLMsg
  DIM iSection AS Integer = 1
  DIM sLine AS String
  DIM aMsg, aScan AS String[]

  aMsg = Split(sMsg, "\n")
  IF aMsg.Count THEN
    xPLMsg.Type = aMsg[0]
    FOR EACH sLine IN aMsg

      ' start of message
      IF iSection = 1 THEN
        IF sLine = "{" THEN INC iSection
      ENDIF

      ' parse header
      IF iSection = 2 THEN
        IF sLine = "}" THEN
          INC iSection
        ELSE
          aScan = Scan(sLine, "*=*")
          IF aScan.Count = 2 THEN xPLMsg.AddHeaderPair(aScan[0], aScan[1])
        ENDIF
      ENDIF

      ' look for schema
      IF iSection = 3 THEN
        IF (Len(sLine) > 2) THEN
          xPLMsg.Schema = sLine
          INC iSection
        ENDIF
      ENDIF

      ' start of body
      IF iSection = 4 THEN
        IF sLine = "{" THEN INC iSection
      ENDIF

      ' parse body
      IF iSection = 5 THEN
        IF sLine = "}" THEN
          INC iSection
        ELSE
          aScan = Scan(sLine, "*=*")
          IF aScan.Count = 2 THEN
            xPLMsg.AddBodyPair(aScan[0], aScan[1])
          ENDIF
        ENDIF
      ENDIF
    NEXT
  ENDIF
  RETURN xPLMsg

END

PUBLIC SUB SendHeartBeat()

  DIM sStatMsg AS String = "xpl-stat\n{\nhop=1\nsource=" & VENDOR & "." & System.Host & "\ntarget=*\n}\n"
  DIM sHbeatMsg AS String = "hbeat.app\n{\ninterval=" & iHeartBeatTime & "\nport=" & iListenerPort & "\nremote-ip=" & sOurIPAddress & "\nversion=" & Main.sProgramVersion & "\n}\n"

  SendMessage(sStatMsg & sHbeatMsg)

END

'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
' send UDP message
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
PUBLIC SUB SendMessage(sMessage AS String)

  ' sent it to all computers on this network
  hxPLSender = NEW UdpSocket AS "Sender"
  hxPLSender.Broadcast = TRUE
  ' [GB2:BIND] hxPLSender.Bind(0)
  hxPLSender.Port = 0
  hxPLSender.Bind()
  hxPLSender.TargetPort = 3865
  hxPLSender.TargetHost = sTargetHost
  WRITE #hxPLSender, sMessage, Len(sMessage)
  IF bxPLDebug THEN Main.WriteDebugLog("[xPL] > " & sMessage)

CATCH
  Main.WriteDebugLog(("[xPL] ERROR: Cannot send xPL message! ") & ERROR.Text & (" at ") & ERROR.Where)

END

'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
' disconnect from the host
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
PUBLIC FUNCTION Disconnect() AS Boolean

  ' try to close the connection
  TRY hxPLListener.Close
  TRY hxPLSender.Close
  TRY tHBeatTimer.Stop
  Main.WriteLog(("xPL listener stopped."))

  ' all ok
  RETURN TRUE

CATCH ' some errors
  Main.WriteLog(("xPL Error: ") & ERROR.Text)
  RETURN FALSE

END

'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
' display error if connect failed
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
PUBLIC SUB hxPLListener_Error()

  ' handle error
  SELECT CASE hxPLListener.Status
    CASE Net.CannotCreateSocket
      Main.WriteLog(("xPL: The system does not allow to create a socket."))
    CASE Net.CannotBindSocket
      Main.WriteLog(("xPL: Unable to bind a socket."))
    CASE Net.CannotRead
      Main.WriteLog(("xPL: Error reading data."))
    CASE Net.CannotWrite
      Main.WriteLog(("xPL: Error writing data."))
  END SELECT

END

PRIVATE FUNCTION XPLDebug_Read() AS Boolean

  RETURN bxPLDebug

END

PRIVATE SUB xPLDebug_Write(Value AS Boolean)

  bxPLDebug = Value

END

PRIVATE FUNCTION Interface_Read() AS String

  RETURN sInterface

END

PRIVATE SUB Interface_Write(Value AS String)

  sInterface = Value

END

PRIVATE FUNCTION HeartBeatTime_Read() AS Integer

  RETURN iHeartBeatTime

END

PRIVATE SUB HeartBeatTime_Write(Value AS Integer)

  iHeartBeatTime = Value

END

PRIVATE FUNCTION TargetHost_Read() AS String

  RETURN sTargetHost

END

PRIVATE SUB TargetHost_Write(Value AS String)

  sTargetHost = Value

END

PRIVATE FUNCTION OurIPAddress_Read() AS String

  RETURN sOurIPAddress

END

PRIVATE SUB OurIPAddress_Write(Value AS String)

  sOurIPAddress = Value

END
