' Gambas class file

' Description:
' CMQTT.class
' Connect to a MQTT broker to publish device data and listen for incoming data.

' Development Status:
' Just started.

' Resources:
' http://public.dhe.ibm.com/software/dw/webservices/ws-mqtt/mqtt-v3r1.html

' DomotiGa - an open source home automation program.
' Copyright (C) Ron Klinkien, The Netherlands.

' Read file called COPYING for license details.

Property Host As String
Property Port As Integer
Property Username As String
Property Password As String
Property PubTopic As String
Property SubTopic As String
Property HeartBeat As Integer
Property Retain As Boolean
Property Qos As Integer
Property MQTTDebug As Boolean

Private sTCPHost As String
Private iTCPPort As Integer
Private sUsername As String
Private sPassword As String
Private sPubTopic As String
Private sSubTopic As String
Private iHeartBeat As Integer
Private bRetain As Boolean
Private iQos As Integer
Private bMQTTDebug As Boolean

Public hMQTT As New Socket
Public tMQTTPing As Timer
Public tMQTTBusy As Timer
Private RecBuf As New String[255]
Private RecBytes As Integer

' queue and command buffer stuff
Private cQueue As New Collection  ' command buffer
Private bBusy As Boolean          ' waiting for delay timer to finish

' message types
Const MQTTCONNECT As Byte = &H10
Const MQTTCONNACK As Byte = &H20
Const MQTTPUBLISH As Byte = &H30
Const MQTTPINGRESP As Byte = &D0
Const MQTTSUBSCRIBE As Byte = &H80
Const MQTTPUBACK As Byte = &H90

' message types
Const MQTT_CONNECT As Integer = 1
Const MQTT_CONNACK As Integer = 2
Const MQTT_PUBLISH As Integer = 3
Const MQTT_PUBACK As Integer = 4
Const MQTT_SUBACK As Integer = 9
Const MQTT_PINGRESP As Integer = 13

'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
' connect to the host:port
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Public Function Connect() As Boolean

  ' try to close the connection
  Try hMQTT.Close

  ' get a new one
  hMQTT = New Socket As "MQTT"
  hMQTT.Connect(sTCPHost, iTCPPort)

  ' all ok
  Return True

Catch ' some errors
  Main.WriteLog(("MQTT Error: ") & Error.Text & (" at ") & Error.Where)
  Return False

End

'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
' disconnect from the host
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Public Function Disconnect() As Boolean

  ' tell MQTT broker that we want to disconnect
  ClientDisconnect()

  ' try stop running timers
  Try tMQTTPing.Stop
  Try tMQTTBusy.Stop

  ' try to close the connection
  Try hMQTT.Close
  Main.WriteLog(("MQTT socket close."))

  ' all ok
  Return True

Catch ' some errors
  Main.WriteLog(("MQTT Error: ") & Error.Text & (" at ") & Error.Where)
  Return False

End

Public Sub MQTT_Error()

  ' handle error
  Select Case hMQTT.Status
    Case Net.CannotCreateSocket
      Main.WriteLog(("MQTT: The system does not allow to create a socket."))
    Case Net.HostNotFound
      Main.WriteLog(("MQTT: Host '") & sTCPHost & ("' not found."))
    Case Net.ConnectionRefused
      Main.WriteLog(("MQTT: Unable to connect. Connection refused."))
    Case Net.CannotRead
      Main.WriteLog(("MQTT: Error reading data."))
    Case Net.CannotWrite
      Main.WriteLog(("MQTT: Error writing data."))
  End Select

End

Public Sub MQTT_Read()

  Dim bByte As Byte

  Try bByte = Read #hMQTT As Byte
  If Error Then Main.WriteDebugLog(("[MQTT] Error reading data from network socket! -> ") & Error.Text & (" at ") & Error.Where)

  ParseMessage(bByte)

End

Public Sub MQTT_Ready()

  Main.WriteLog(("MQTT socket connected."))

    ' start ping timer
  tMQTTPing = New Timer As "tMQTTPing"
  tMQTTPing.Delay = iHeartBeat * 1000 ' multiply for seconds
  tMQTTPing.Start

  ' define timer for busy
  tMQTTBusy = New Timer As "tMQTTBusy"
  tMQTTBusy.Stop

  ClientConnect("DomotiGa")
  SubscribeTopic(sSubTopic)

End

Public Sub tMQTTPing_Timer()

  ClientHeartBeat()

End

'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
' send connect message
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Private Sub ClientConnect(sId As String)

  Dim bBuf As New Byte[255]
  Dim iCnt As Integer

  ' fixed header
  bBuf[0] = MQTTCONNECT ' connect
  ' bBuf[1] = 12 + Len(sId) + 2 ' remaining length
  bBuf[1] = 12 + Len(sId) + 2 + Len(sUsername) + Len(sPassword) ' remaining length
  ' var header
  bBuf[2] = &H0   ' 0
  bBuf[3] = &H6   ' 6
  bBuf[4] = &H4D  ' M
  bBuf[5] = &H51  ' Q
  bBuf[6] = &H49  ' I
  bBuf[7] = &H73  ' s
  bBuf[8] = &H64  ' d
  bBuf[9] = &H70  ' p
  bBuf[10] = &H3  ' protocol version = 3

  ' connect flag
  bBuf[11] = &H2  ' clean session only
  If sUsername Then bBuf[11] = BSet(bBuf[11], 7)
  If sPassword And If Not sUsername Then
    If bMQTTDebug Then Main.WriteDebugLog(("[MQTT] You cannot supply a password without a username!"))
    Return
  Else
    bBuf[11] = BSet(bBuf[11], 6)
  Endif
  bBuf[12] = &H0  ' MSB keepalive
  bBuf[13] = iHeartBeat ' LSB
  bBuf[14] = &H0  ' ID string length MSB
  bBuf[15] = Len(sId)  ' ID string length LSB

  ' id
  For iCnt = 1 To Len(sId)
    bBuf.Add(Asc(Mid(sId, iCnt, 1)), 15 + iCnt)
  Next

  ' username
  If sUsername Then
    For iCnt = 1 To Len(sUsername)
      bBuf.Add(Asc(Mid(sUsername, iCnt, 1)), 15 + iCnt + Len(sId))
    Next
  Endif

  ' password
  If sPassword Then
    For iCnt = 1 To Len(sPassword)
      bBuf.Add(Asc(Mid(sPassword, iCnt, 1)), 15 + iCnt + Len(sId) + Len(sUsername))
    Next
  Endif

  If bMQTTDebug Then Main.WriteDebugLog(("[MQTT] Connecting to broker."))
  bBuf.Resize(2 + bBuf[1])
  QueueCommand(bBuf)

End

'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
' send disconnect message
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Private Sub ClientDisconnect()

  Dim bBuf As New Byte[2]

  bBuf[0] = -&H7F + &5F ' disconnect
  bBuf[1] = &H0

  If bMQTTDebug Then Main.WriteDebugLog(("[MQTT] Disconnecting from broker."))
  QueueCommand(bBuf)

End

'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
' send heartbeat message
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Private Sub ClientHeartBeat()

  Dim bBuf As New Byte[2]

  bBuf[0] = &HC0
  bBuf[1] = &H0

  If bMQTTDebug Then Main.WriteDebugLog(("[MQTT] Sending heartbeat to broker."))
  QueueCommand(bBuf)

End

'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
' subscribe message
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Private Sub SubscribeTopic(sTopic As String)

  Dim bBuf As New Byte[255]
  Dim iCnt, iTopicLen As Integer

  iTopicLen = Len(sTopic)

  ' fixed header
  bBuf[0] = MQTTSUBSCRIBE     ' subscribe
  bBuf[1] = &H5 + Len(sTopic) ' remaining length
  bBuf[2] = &H0   ' MSB
  bBuf[3] = &HA   ' message id
  bBuf[4] = iTopicLen / 128   ' MSB
  bBuf[5] = iTopiclen Mod 128 ' # bytes of topic

  For iCnt = 1 To Len(sTopic)
    bBuf.Add(Asc(sTopic, iCnt), 5 + iCnt)
  Next
  bBuf.Add(&H0, 5 + Len(sTopic) + iCnt + 1)

  If bMQTTDebug Then Main.WriteDebugLog(("[MQTT] Subscribing to Topic '") & sTopic & ("'"))
  bBuf.Resize(&H7 + Len(sTopic))
  QueueCommand(bBuf)

End

'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
' publish data
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Public Sub PublishMsg(sTopic As String, sMsg As String)

  Dim bBuf As New Byte[255]
  Dim iCnt, iTopicLen, iMsgLen As Integer

  sTopic = sPubTopic &/ sTopic
  iTopicLen = Len(sTopic)
  iMsgLen = Len(sMsg)

  ' remove wildcards
  sTopic = Replace(sTopic, "#", " ")
  sTopic = Replace(sTopic, "+", " ")

  ' publish with retain enabled if set
  If bRetain Then bBuf[0] = BSet(MQTTPUBLISH, 0)

  ' set chosen QoS
  Select Case iQoS
    Case 0
      ' default
    Case 1
      bBuf[0] = BSet(bBuf[0], 1)
    Case 2
      bBuf[0] = BSet(bBuf[0], 2)
    Case Else
      If bMQTTDebug Then Main.WriteDebugLog(("[MQTT] Invalid QoS value '") & iQoS & ("' set!"))
      Return
  End Select

  bBuf[1] = iTopicLen + iMsgLen + 2 ' remaining length
  bBuf[2] = iTopicLen / 128         ' MSB topic length
  bBuf[3] = iTopicLen Mod 128       ' LSB
  For iCnt = 1 To Len(sTopic)
    bBuf.Add(Asc(sTopic, iCnt), 3 + iCnt)
  Next
  For iCnt = 1 To Len(sMsg)
    bBuf.Add(Asc(sMsg, iCnt), 3 + iTopicLen + iCnt)
  Next

  If bMQTTDebug Then Main.WriteDebugLog(("[MQTT] Publishing Message '") & sMsg & ("' to Topic '") & sTopic & ("'"))
  bBuf.Resize(&H4 + Len(sTopic) + Len(sMsg))
  QueueCommand(bBuf)

End

'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
' add command to queue
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Private Sub QueueCommand(aPacket As Byte[])

  ' add command to queue
  cQueue.Add(aPacket, Rnd)

  ' if not busy process it
  If bBusy = False Then DoQueue()

End

'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
' process items in queue
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Private Sub DoQueue()

  Dim aPacket As Byte[] = Null

  For Each aPacket In cQueue
    WriteCommand(aPacket, cQueue.Key)
    Break ' only do first one
  Next

End

'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
' busy reset
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Public Sub tMQTTBusy_Timer()

  bBusy = False
  tMQTTBusy.Stop

  If cQueue.Count Then ' if there are more commands left in queue, send next one
    If bMQTTDebug Then Main.WriteDebugLog(("[MQTT] Sending next command from Queue (count = " & cQueue.Count & ")"))
    DoQueue()
  Endif

End

'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
' writes the packets
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Private Sub WriteCommand(bBuffer As Byte[], sKey As String)

  Dim iCnt As Integer
  Dim bByte As Byte

  If Not bMQTTDebug Then
    bBuffer.Write(hMQTT, 0, bBuffer.Length)
    Return
  Endif

  Main.WriteDebugLog("[MQTT] >", True)
  For Each bByte In bBuffer
    If iCnt >= bBuffer.Length Then Break
    Try Write #hMQTT, CByte(bByte) As Byte
    Main.WriteRFXDebugLog(" " & Hex(bByte, 2), True)
    Inc iCnt
  Next
  Main.WriteRFXDebugLog("\n", True)

  ' remove sent command from queue
  cQueue.Remove(sKey)

  tMQTTBusy.Delay = 50 ' 50mS (initial test value)
  tMQTTBusy.Start
  If bBusy = False Then bBusy = True

Catch
   Main.WriteDebugLog(("[MQTT] Not connected to MQTT Broker, cannot Publish! "))
   'Connect()

End

Private Sub ParseMessage(bByte As Byte)

  Dim iType As Integer
  
  If RecBytes = 0 Then ' 1st byte of a packet received
    ' clear
    RecBuf[0] = 0
    RecBuf[1] = 0
    If bByte <> 0 Then
      If bMQTTDebug Then Main.WriteRFXDebugLog("[MQTT] < ", 0)
    Endif
  Endif

  iType = Lsr(Val(RecBuf[0]), 4)


  Try RecBuf[RecBytes] = bByte ' store received byte
  Inc RecBytes  ' increment byte counter

  ' connack
  'If RecBuf[0] = MQTTCONNACK And If RecBytes = 4 Then
  If iType = MQTT_CONNACK And If RecBytes = 4 Then
    If bMQTTDebug Then
      Main.WriteRFXDebugLog(Hex(bByte, 2) & "\n", 1)
      DecodeConnAck(RecBuf)
    Endif
    RecBytes = 0  ' set to zero to receive next message
  ' puback
  'Else If RecBuf[0] = MQTTPUBACK And If RecBytes = RecBuf[1] + 2 Then
  Else If iType = MQTT_PUBACK And If RecBytes = RecBuf[1] + 2 Then
    If bMQTTDebug Then
      Main.WriteRFXDebugLog(Hex(bByte, 2) & "\n", 1)
      DecodePubAck(RecBuf)
    Endif
    RecBytes = 0  ' set to zero to receive next message
  ' pingresp
  'Else If RecBuf[0] = MQTTPINGRESP And If RecBytes = 2 Then
  Else If iType = MQTT_PINGRESP And If RecBytes = 2 Then
    If bMQTTDebug Then
      Main.WriteRFXDebugLog(Hex(bByte, 2) & "\n", 1)
      Main.WriteDebugLog(("[MQTT] Server replied with alive packet."))
    Endif
    RecBytes = 0  ' set to zero to receive next message
  Else If iType = MQTT_SUBACK And If RecBytes = RecBuf[1] + 2 Then
    If bMQTTDebug Then
      Main.WriteRFXDebugLog(Hex(bByte, 2) & "\n", 1)
      'DecodeSubAck(RecBuf)
      Main.WriteDebugLog(("[MQTT] Subscription ack packet."))
    Endif
    RecBytes = 0  ' set to zero to receive next message
  'Else If RecBuf[0] And &H30 And If RecBytes = RecBuf[1] Then
  Else If iType = MQTT_PUBLISH And If RecBytes = RecBuf[1] Then
    ' If bMQTTDebug Then
    '   Main.WriteRFXDebugLog(Hex(bByte, 2) & "\n", 1)
    '   Main.WriteDebugLog(("[MQTT] Received published data."))
    '   DecodePublish(RecBuf)
    ' Endif
    RecBytes = 0  ' set to zero to receive next message
  Else
    'Print RecBytes & " -> " & Hex(bByte, 2)
    If bMQTTDebug Then Main.WriteRFXDebugLog(Hex(bByte, 2) & " ", 1) ' write the output to the screen
  Endif

End

Private Sub DecodePublish(bBuffer As String[])

  Dim bByte As Byte
  Dim iCnt As Integer

  Main.WriteDebugLog("[MQTT] Received: ", True)
  For iCnt = 4 To RecBytes - 5
    Main.WriteRFXDebugLog(Chr(bBuffer[iCnt]), True)
  Next
  Main.WriteRFXDebugLog("\n", True)

End

Private Sub DecodeConnAck(bBuffer As String[])

  ' 20020000
  Select Case bBuffer[3]
    Case 0
      Main.WriteDebugLog(("[MQTT] Connection accepted by server."))
    Case 1
      Main.WriteDebugLog(("[MQTT] Connection refused by server, wrong protocol version."))
    Case 2
      Main.WriteDebugLog(("[MQTT] Connection refused by server, identifier refused."))
    Case 3
      Main.WriteDebugLog(("[MQTT] Connection refused by server, MQTT service unavailable."))
    Case 4
      Main.WriteDebugLog(("[MQTT] Connection refused by server, bad username or password."))
    Case 5
      Main.WriteDebugLog(("[MQTT] Connection refused by server, client is not authorized."))
    Case Else
      Main.WriteDebugLog(("[MQTT] Received unknown CONNACK status code!"))
  End Select

End

Private Sub DecodePubAck(bRecBuf As String[])

  Main.WriteDebugLog(("[MQTT] Subscription accepted by broker."))
  ' TODO: implement decode message id and QoS granted

End

' implement properties
Private Function Host_Read() As String

  Return sTCPHost

End

Private Sub Host_Write(Value As String)

  sTCPHost = Value

End

Private Function Port_Read() As Integer

  Return iTCPPort

End

Private Sub Port_Write(Value As Integer)

  iTCPPort = Value

End

Private Function MQTTDebug_Read() As Boolean

  Return bMQTTDebug

End

Private Sub MQTTDebug_Write(Value As Boolean)

  bMQTTDebug = Value

End

Private Function Username_Read() As String

  Return sUsername

End

Private Sub Username_Write(Value As String)

  sUsername = Value

End

Private Function Password_Read() As String

  Return sPassword

End

Private Sub Password_Write(Value As String)

  sPassword = Value

End

Private Function PubTopic_Read() As String

  Return sPubTopic

End

Private Sub PubTopic_Write(Value As String)

  sPubTopic = Value

End

Private Function SubTopic_Read() As String

  Return sSubTopic

End

Private Sub SubTopic_Write(Value As String)

  sSubTopic = VALUE

End

Private Function HeartBeat_Read() As Integer

  Return iHeartBeat

End

Private Sub HeartBeat_Write(Value As Integer)

  iHeartBeat = Value

End

Private Function Qos_Read() As Integer

  Return iQoS

End

Private Sub Qos_Write(Value As Integer)

  iQoS = Value

End

Private Function Retain_Read() As Boolean

  Return bRetain

End

Private Sub Retain_Write(Value As Boolean)

  bRetain = Value

End
