' Gambas class file

' Description:
' CMQTT.class
' Connect to a MQTT broker to publish device data and listen for incoming data.

' Development Status:
' Just started.

' Resources:
' http://public.dhe.ibm.com/software/dw/webservices/ws-mqtt/mqtt-v3r1.html

' DomotiGa - an open source home automation program.
' Copyright (C) Ron Klinkien, The Netherlands.

' Read file called COPYING for license details.

'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
' Module/Class specific variables
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Public PluginName As String = "MQTT"
Public PluginType As Integer = Plugin.Type_Class
Public PluginFriendlyName As String = "MQTT Client"
Public PluginVersion As String = "1.00"
Public PluginAuthor As String = "Ron Klinkien"
Public PluginProtocols As String[]
Public PluginMaxInstances As Integer = 1

Public KeyName As String
Public LogLabel As String = "[MQTT] "
Public Instance As Integer
Public IsRunning As Boolean
Public ErrorText As String
Public ErrorWhere As String

'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
' Private Variables
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Private $bEnabled As Boolean
Private $sTCPHost As String
Private $iTCPPort As Integer
Private $sUsername As String
Private $sPassword As String
Private $sPubTopic As String
Private $sSubTopic As String
Private $iHeartBeat As Integer
Private $bRetain As Boolean
Private $iQos As Integer
Private $bMQTTDebug As Boolean

Public hMQTT As New Socket
Public tMQTTPing As Timer
Public tMQTTBusy As Timer
Private RecBuf As New String[255]
Private RecBytes As Integer

' queue and command buffer stuff
Private cQueue As New Collection  ' command buffer
Private bBusy As Boolean          ' waiting for delay timer to finish

' message types
Const MQTTCONNECT As Byte = &H10
Const MQTTCONNACK As Byte = &H20
Const MQTTPUBLISH As Byte = &H30
Const MQTTPINGRESP As Byte = &D0
Const MQTTSUBSCRIBE As Byte = &H80
Const MQTTPUBACK As Byte = &H90

' message types
Const MQTT_CONNECT As Integer = 1
Const MQTT_CONNACK As Integer = 2
Const MQTT_PUBLISH As Integer = 3
Const MQTT_PUBACK As Integer = 4
Const MQTT_SUBACK As Integer = 9
Const MQTT_PINGRESP As Integer = 13

'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
' Mandatory Sub for EACH Module/Class to initialize:
' - The cPlugin[x].Settings are copied into local variables
' - Port/Connection will be started (any errors caught)
' - Any other code per Class
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Public Sub StartPlugin(cPl As CPluginEntry)

  KeyName = cPl.KeyName
  Instance = cPl.Instance
  If Instance <> 1 Then LogLabel = Replace(LogLabel, "] ", "#" & Instance & "] ")

  ' Copy configuration items locally
  $bEnabled = cPl.Settings["enabled"]
  $sTCPHost = cPl.Settings["tcphost"]
  $iTCPPort = cPl.Settings["tcpport"]
  $sUsername = cPl.Settings["username"]
  $sPassword = cPl.Settings["password"]
  $sPubTopic = cPl.Settings["pubtopic"]
  $sSubTopic = cPl.Settings["subtopic"]
  $iHeartbeat = cPl.Settings["heartbeat"]
  $bRetain = cPl.Settings["retain"]
  $iQoS = cPl.Settings["qos"]
  $bMQTTDebug = cPl.Settings["debug"]
 
  ' Connect/Initialize connection
  Connect()

End

'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
' Mandatory sub for EACH Module/Class to stop
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Public Sub StopPlugin()

  Try Disconnect()

End

'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
' connect to the host:port
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Public Function Connect() As Boolean

  ' try to close the connection
  Try hMQTT.Close

  ' get a new one
  hMQTT = New Socket As "MQTT"
  hMQTT.Connect($sTCPHost, $iTCPPort)

  ' Write to main logfile we are trying to connect
  Main.WriteLog(LogLabel & PluginFriendlyName & " TCP interface connecting to Server " & $sTCPHost & ":" & $iTCPPort)

  ' Don't set IsRunning=True, this has to be done in _Ready 

  ' All went ok
  Return True

Catch ' some errors
  Main.WriteLog(LogLabel & "ERROR: " & PluginFriendlyName & " TCP interface FAILED to connect to Server " & $sTCPHost & ":" & $iTCPPort)
  Main.WriteLog(LogLabel & "ERROR: " & Error.Text)
  IsRunning = False
  ErrorText = Error.Text
  ErrorWhere = Error.Where

  Return False

End

'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
' disconnect from the host
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Public Function Disconnect() As Boolean

  ' tell MQTT broker that we want to disconnect
  ClientDisconnect()

  ' try stop running timers
  Try tMQTTPing.Stop
  Try tMQTTBusy.Stop

  ' try to close the connection
  Try hMQTT.Close

  Main.WriteLog(LogLabel & PluginFriendlyName & " TCP Server closed.")

  ' all ok
  Return True

Finally
  IsRunning = False
  ErrorText = ""
  ErrorWhere = ""

Catch
  Main.WriteLog(LogLabel & "ERROR: " & Error.Text)
  Return False

End

Public Sub MQTT_Error()

  Log.Plugin_TCP_Error(LogLabel, $sTCPHost, Last.Status)

End

Public Sub MQTT_Read()

  Dim bByte As Byte

  Try bByte = Read #hMQTT As Byte
  If Error Then Main.WriteDebugLog(LogLabel & "Error reading data from network socket! -> " & Error.Text & (" at ") & Error.Where)

  ParseMessage(bByte)

End

Public Sub MQTT_Ready()

  Main.WriteLog(LogLabel & "TCP interface connected.")
  IsRunning = True

    ' start ping timer
  tMQTTPing = New Timer As "tMQTTPing"
  tMQTTPing.Delay = $iHeartBeat * 1000 ' multiply for seconds
  tMQTTPing.Start

  ' define timer for busy
  tMQTTBusy = New Timer As "tMQTTBusy"
  tMQTTBusy.Stop

  ClientConnect("DomotiGa")
  SubscribeTopic($sSubTopic)

End

Public Sub tMQTTPing_Timer()

  ClientHeartBeat()

End

'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
' send connect message
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Private Sub ClientConnect(sId As String)

  Dim bBuf As New Byte[255]
  Dim iCnt As Integer

  ' fixed header
  bBuf[0] = MQTTCONNECT ' connect
  ' bBuf[1] = 12 + Len(sId) + 2 ' remaining length
  bBuf[1] = 12 + Len(sId) + 2 + Len($sUsername) + Len($sPassword) ' remaining length
  ' var header
  bBuf[2] = &H0   ' 0
  bBuf[3] = &H6   ' 6
  bBuf[4] = &H4D  ' M
  bBuf[5] = &H51  ' Q
  bBuf[6] = &H49  ' I
  bBuf[7] = &H73  ' s
  bBuf[8] = &H64  ' d
  bBuf[9] = &H70  ' p
  bBuf[10] = &H3  ' protocol version = 3

  ' connect flag
  bBuf[11] = &H2  ' clean session only
  If $sUsername Then bBuf[11] = BSet(bBuf[11], 7)
  If $sPassword And If Not $sUsername Then
    If $bMQTTDebug Then Main.WriteDebugLog(LogLabel & "You cannot supply a password without a username!")
    Return
  Else
    bBuf[11] = BSet(bBuf[11], 6)
  Endif
  bBuf[12] = &H0  ' MSB keepalive
  bBuf[13] = $iHeartBeat ' LSB
  bBuf[14] = &H0  ' ID string length MSB
  bBuf[15] = Len(sId)  ' ID string length LSB

  ' id
  For iCnt = 1 To Len(sId)
    bBuf.Add(Asc(Mid(sId, iCnt, 1)), 15 + iCnt)
  Next

  ' username
  If $sUsername Then
    For iCnt = 1 To Len($sUsername)
      bBuf.Add(Asc(Mid($sUsername, iCnt, 1)), 15 + iCnt + Len(sId))
    Next
  Endif

  ' password
  If $sPassword Then
    For iCnt = 1 To Len($sPassword)
      bBuf.Add(Asc(Mid($sPassword, iCnt, 1)), 15 + iCnt + Len(sId) + Len($sUsername))
    Next
  Endif

  If $bMQTTDebug Then Main.WriteDebugLog(LogLabel & "Connecting to broker.")
  bBuf.Resize(2 + bBuf[1])
  QueueCommand(bBuf)

End

'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
' send disconnect message
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Private Sub ClientDisconnect()

  Dim bBuf As New Byte[2]

  bBuf[0] = -&H7F + &5F ' disconnect
  bBuf[1] = &H0

  If $bMQTTDebug Then Main.WriteDebugLog(LogLabel & "Disconnecting from broker.")
  QueueCommand(bBuf)

End

'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
' send heartbeat message
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Private Sub ClientHeartBeat()

  Dim bBuf As New Byte[2]

  bBuf[0] = &HC0
  bBuf[1] = &H0

  If $bMQTTDebug Then Main.WriteDebugLog(LogLabel & "Sending heartbeat to broker.")
  QueueCommand(bBuf)

End

'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
' subscribe message
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Private Sub SubscribeTopic(sTopic As String)

  Dim bBuf As New Byte[255]
  Dim iCnt, iTopicLen As Integer

  iTopicLen = Len(sTopic)

  ' fixed header
  bBuf[0] = MQTTSUBSCRIBE     ' subscribe
  bBuf[1] = &H5 + Len(sTopic) ' remaining length
  bBuf[2] = &H0   ' MSB
  bBuf[3] = &HA   ' message id
  bBuf[4] = iTopicLen / 128   ' MSB
  bBuf[5] = iTopiclen Mod 128 ' # bytes of topic

  For iCnt = 1 To Len(sTopic)
    bBuf.Add(Asc(sTopic, iCnt), 5 + iCnt)
  Next
  bBuf.Add(&H0, 5 + Len(sTopic) + iCnt + 1)

  If $bMQTTDebug Then Main.WriteDebugLog(LogLabel & "Subscribing to Topic '" & sTopic & "'")
  bBuf.Resize(&H7 + Len(sTopic))
  QueueCommand(bBuf)

End

'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
' publish data
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Public Sub PublishMsg(sTopic As String, sMsg As String)

  Dim bBuf As New Byte[255]
  Dim iCnt, iTopicLen, iMsgLen As Integer

  sTopic = $sPubTopic &/ sTopic
  iTopicLen = Len(sTopic)
  iMsgLen = Len(sMsg)

  ' remove wildcards
  sTopic = Replace(sTopic, "#", " ")
  sTopic = Replace(sTopic, "+", " ")

  ' publish with retain enabled if set
  If $bRetain Then
    bBuf[0] = BSet(MQTTPUBLISH, 0)
  Else
    bBuf[0] = MQTTPUBLISH
  Endif
  
  ' set chosen QoS
  Select Case $iQoS
    Case 0
      ' default
    Case 1
      bBuf[0] = BSet(bBuf[0], 1)
    Case 2
      bBuf[0] = BSet(bBuf[0], 2)
    Case Else
      If $bMQTTDebug Then Main.WriteDebugLog(LogLabel & "Invalid QoS value '" & $iQoS & "' set!")
      Return
  End Select

  bBuf[1] = iTopicLen + iMsgLen + 2 ' remaining length
  bBuf[2] = iTopicLen / 128         ' MSB topic length
  bBuf[3] = iTopicLen Mod 128       ' LSB
  For iCnt = 1 To Len(sTopic)
    bBuf.Add(Asc(sTopic, iCnt), 3 + iCnt)
  Next
  For iCnt = 1 To Len(sMsg)
    bBuf.Add(Asc(sMsg, iCnt), 3 + iTopicLen + iCnt)
  Next

  If $bMQTTDebug Then Main.WriteDebugLog(LogLabel & "Publishing Message '" & sMsg & "' to Topic '" & sTopic & "'")
  bBuf.Resize(&H4 + Len(sTopic) + Len(sMsg))
  QueueCommand(bBuf)

End

'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
' add command to queue
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Private Sub QueueCommand(aPacket As Byte[])

  ' add command to queue
  cQueue.Add(aPacket, Rnd)

  ' if not busy process it
  If bBusy = False Then DoQueue()

End

'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
' process items in queue
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Private Sub DoQueue()

  Dim aPacket As Byte[] = Null

  For Each aPacket In cQueue
    WriteCommand(aPacket, cQueue.Key)
    Break ' only do first one
  Next

End

'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
' busy reset
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Public Sub tMQTTBusy_Timer()

  bBusy = False
  tMQTTBusy.Stop

  If cQueue.Count Then ' if there are more commands left in queue, send next one
    If $bMQTTDebug Then Main.WriteDebugLog(LogLabel & "Sending next command from Queue (count = " & cQueue.Count & ")")
    DoQueue()
  Endif

End

'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
' writes the packets
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Private Sub WriteCommand(bBuffer As Byte[], sKey As String)

  Dim iCnt As Integer
  Dim bByte As Byte

  If Not $bMQTTDebug Then
    bBuffer.Write(hMQTT, 0, bBuffer.Length)
  Else
    Main.WriteDebugLog(LogLabel & ">", True)
    For Each bByte In bBuffer
      If iCnt >= bBuffer.Length Then Break
      Try Write #hMQTT, CByte(bByte) As Byte
      Main.WriteRFXDebugLog(" " & Hex(bByte, 2), True)
      Inc iCnt
    Next
    Main.WriteRFXDebugLog("\n", True)
  Endif

  ' remove sent command from queue
  cQueue.Remove(sKey)

  tMQTTBusy.Delay = 50 ' 50mS (initial test value)
  tMQTTBusy.Start
  If bBusy = False Then bBusy = True

Catch
   Main.WriteDebugLog(LogLabel & "Not connected to MQTT Broker, cannot Publish! ")
   'Connect()

End

Private Sub ParseMessage(bByte As Byte)

  Dim iType As Integer
  
  If RecBytes = 0 Then ' 1st byte of a packet received
    ' clear
    RecBuf[0] = 0
    RecBuf[1] = 0
    If bByte <> 0 Then
      If $bMQTTDebug Then Main.WriteRFXDebugLog(LogLabel & "< ", 0)
    Endif
  Endif

  iType = Lsr(Val(RecBuf[0]), 4)


  Try RecBuf[RecBytes] = bByte ' store received byte
  Inc RecBytes  ' increment byte counter

  ' connack
  If iType = MQTT_CONNACK And If RecBytes = 4 Then
    If $bMQTTDebug Then
      Main.WriteRFXDebugLog(Hex(bByte, 2) & "\n", 1)
      DecodeConnAck(RecBuf)
    Endif
    RecBytes = 0  ' set to zero to receive next message
  ' puback
  Else If iType = MQTT_PUBACK And If RecBytes = RecBuf[1] + 2 Then
    If $bMQTTDebug Then
      Main.WriteRFXDebugLog(Hex(bByte, 2) & "\n", 1)
      DecodePubAck(RecBuf)
    Endif
    RecBytes = 0  ' set to zero to receive next message
  ' pingresp
  Else If iType = MQTT_PINGRESP And If RecBytes = 2 Then
    If $bMQTTDebug Then
      Main.WriteRFXDebugLog(Hex(bByte, 2) & "\n", 1)
      Main.WriteDebugLog(LogLabel & "Server replied with alive packet.")
    Endif
    RecBytes = 0  ' set to zero to receive next message
  Else If iType = MQTT_SUBACK And If RecBytes = RecBuf[1] + 2 Then
    If $bMQTTDebug Then
      Main.WriteRFXDebugLog(Hex(bByte, 2) & "\n", 1)
      'DecodeSubAck(RecBuf)
      Main.WriteDebugLog(LogLabel & "Subscription ack packet.")
    Endif
    RecBytes = 0  ' set to zero to receive next message
  Else If iType = MQTT_PUBLISH And If RecBytes = RecBuf[1] + 2 Then
    If $bMQTTDebug Then
       Main.WriteRFXDebugLog(Hex(bByte, 2) & "\n", 1)
       Main.WriteDebugLog(LogLabel & "Received published data.")
    Endif
    DecodePublish(RecBuf)
    RecBytes = 0  ' set to zero to receive next message
  Else
    If $bMQTTDebug Then Main.WriteRFXDebugLog(Hex(bByte, 2) & " ", 1) ' write the output to the screen
  Endif
  
  If Error Then
    Main.WriteDebugLog(LogLabel & "ERROR: '" & Error.Text & "' at " & Error.Where)
  Endif

End

Private Sub DecodePublish(bBuffer As String[])

  Dim bByte As Byte
  Dim iCnt As Integer
  Dim sAddress, sMessage As String
  Dim iDeviceId As Integer

  For iCnt = 4 To 3 + bBuffer[3] 
    sAddress &= Chr(bBuffer[iCnt])
  Next
  If $bMQTTDebug Then Main.WriteDebugLog(LogLabel & "Received topic : " & sAddress) 

  For iCnt = 4 + bBuffer[3] To RecBytes - 1
    sMessage &= Chr(bBuffer[iCnt])
  Next
  If $bMQTTDebug Then Main.WriteDebugLog(LogLabel & "Received message : " & sMessage) 
  
  iDeviceId = Devices.Find(Instance, sAddress, Devices.FindInterface("MQTT Interface"))
  If Not iDeviceId Then
    Return
  Endif

  Devices.ValueUpdateV2(iDeviceId, 1, sMessage)

End

Private Sub DecodeConnAck(bBuffer As String[])

  ' 20020000
  Select Case bBuffer[3]
    Case 0
      Main.WriteDebugLog(LogLabel & "Connection accepted by server.")
    Case 1
      Main.WriteDebugLog(LogLabel & "Connection refused by server, wrong protocol version.")
    Case 2
      Main.WriteDebugLog(LogLabel & "Connection refused by server, identifier refused.")
    Case 3
      Main.WriteDebugLog(LogLabel & "Connection refused by server, MQTT service unavailable.")
    Case 4
      Main.WriteDebugLog(LogLabel & "Connection refused by server, bad username or password.")
    Case 5
      Main.WriteDebugLog(LogLabel & "Connection refused by server, client is not authorized.")
    Case Else
      Main.WriteDebugLog(LogLabel & "Received unknown CONNACK status code!")
  End Select

End

Private Sub DecodePubAck(bRecBuf As String[])

  Main.WriteDebugLog(LogLabel & "Subscription accepted by broker.")
  ' TODO: implement decode message id and QoS granted

End

