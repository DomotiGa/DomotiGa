' Gambas class file

' Description:
' CMQTT.class
' Connect to a MQTT broker to publish device data and listen for incoming data.

' Development Status:
' Just started.

' Resources:
' http://public.dhe.ibm.com/software/dw/webservices/ws-mqtt/mqtt-v3r1.html

' DomotiGa - an open source home automation program.
' Copyright (C) Ron Klinkien, The Netherlands.

' Read file called COPYING for license details.

'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
' Module/Class specific variables
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Public PluginName As String = "MQTT"
Public PluginType As Integer = Plugin.Type_Class
Public PluginFriendlyName As String = "MQTT Client/Server"
Public PluginVersion As String = "1.00"
Public PluginAuthor As String = "Ron Klinkien"
Public PluginProtocols As String[]
Public PluginMaxInstances As Integer = 1

Public KeyName As String
Public LogLabel As String = "[MQTT] "
Public InterfaceId As Integer
Public Instance As Integer
Public IsRunning As Boolean
Public ErrorText As String
Public ErrorWhere As String

'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
' Private Variables
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Private $bEnabled As Boolean
Private $sTCPHost As String
Private $iTCPPort As Integer
Private $sClientname As String
Private $sUsername As String
Private $sPassword As String
Private $sPubTopic As String
Private $sSubTopic As String
Private $iHeartBeat As Integer
Private $bRetain As Boolean
Private $iQos As Integer
Private $bMQTTDebug As Boolean

Public hMQTT As New Socket
Public tMQTTPing As Timer
Public tMQTTBusy As Timer
Private RecBuf As New String[255]
Private RecBytes As Integer

' queue and command buffer stuff
Private cQueue As New Collection  ' command buffer
Private bBusy As Boolean          ' waiting for delay timer to finish

' message types
Const MQTTCONNECT As Byte = &H10
Const MQTTCONNACK As Byte = &H20
Const MQTTPUBLISH As Byte = &H30
Const MQTTPINGRESP As Byte = &D0
Const MQTTSUBSCRIBE As Byte = &H80
Const MQTTPUBACK As Byte = &H90

' message types
Const MQTT_CONNECT As Integer = 1
Const MQTT_CONNACK As Integer = 2
Const MQTT_PUBLISH As Integer = 3
Const MQTT_PUBACK As Integer = 4
Const MQTT_SUBACK As Integer = 9
Const MQTT_PINGRESP As Integer = 13

Public tReConnect As Timer
Private iReConnectRetry As Integer = 0 ' retries
Private aReConnectDelay As Integer[] = [0, 1000, 5000, 10000, 30000, 60000, 300000, 900000, 1800000, 3600000, 7200000] ' 1sec, 5sec, 20sec, 30sec, 1min, 5min, 15min, 1/2hour, 1hour, 2hour

'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
' Mandatory subroutine for each Module/Class to initialize:
' - The cPlugin[x].Settings are copied into local variables
' - Port/Connection will be started (any errors caught)
' - Any other code per Class
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Public Sub StartPlugin(cPl As CPluginEntry)

  KeyName = cPl.KeyName
  Instance = cPl.Instance
  If Instance <> 1 Then LogLabel = Replace(LogLabel, "] ", "#" & Instance & "] ")

  ' Copy configuration items locally
  $bEnabled = cPl.Settings["enabled"]
  $sTCPHost = cPl.Settings["tcphost"]
  $iTCPPort = cPl.Settings["tcpport"]
  $sClientname = cPl.Settings["clientname"]
  $sUsername = cPl.Settings["username"]
  $sPassword = cPl.Settings["password"]
  $sPubTopic = cPl.Settings["pubtopic"]
  $sSubTopic = cPl.Settings["subtopic"]
  $iHeartbeat = cPl.Settings["heartbeat"]
  $bRetain = cPl.Settings["retain"]
  $iQoS = cPl.Settings["qos"]
  $bMQTTDebug = cPl.Settings["debug"]

  ' Define timer for reconnect
  tReConnect = New Timer As "tReConnect"
  tReConnect.Delay = iReConnectRetry
  tReConnect.Stop

  InterfaceId = Devices.FindInterface("MQTT Interface")
  If InterfaceId = 0 Then
    ErrorText = "Required InterfaceId can't be retrieved from the database!"
    Main.WriteLog(LogLabel & "ERROR: " & ErrorText)
    IsRunning = False
    Return
  Endif

  ' Connect/Initialize connection
  Connect()

End

'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
' Mandatory sub for each Module/Class to stop
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Public Sub StopPlugin()

  Try Disconnect()

End

'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
' connect to the host:port
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Public Function Connect() As Boolean

  ' try to close the connection
  Try hMQTT.Close

  ' get a new one
  hMQTT = New Socket As "MQTT"
  hMQTT.Connect($sTCPHost, $iTCPPort)

  ' Write to main logfile we are trying to connect
  Main.WriteLog(LogLabel & PluginFriendlyName & " TCP interface connecting to Server " & $sTCPHost & ":" & $iTCPPort)

  ' Don't set IsRunning=True, this has to be done in _Ready 

  ' All went ok
  Return True

Catch ' some errors
  Main.WriteLog(LogLabel & "ERROR: " & PluginFriendlyName & " TCP interface FAILED to connect to Server " & $sTCPHost & ":" & $iTCPPort)
  Main.WriteLog(LogLabel & "ERROR: " & Error.Text)
  IsRunning = False
  ErrorText = Error.Text
  ErrorWhere = Error.Where

  Return False

End

'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
' disconnect from the host
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Public Function Disconnect() As Boolean

  ' tell MQTT broker that we want to disconnect
  ClientDisconnect()

  ' try stop running timers
  Try tReConnect.Stop
  Try tMQTTPing.Stop
  Try tMQTTBusy.Stop

  ' try to close the connection
  Try hMQTT.Close

  Main.WriteLog(LogLabel & PluginFriendlyName & " TCP Server closed.")

  ' all ok
  Return True

Finally
  IsRunning = False
  ErrorText = ""
  ErrorWhere = ""

Catch
  Main.WriteLog(LogLabel & "ERROR: " & Error.Text)
  Return False

End

Public Sub MQTT_Error()

  Dim sMsg As String

  sMsg = Log.Text_TCP_Error(Last.Status, $sTCPHost)
  Main.WriteLog(LogLabel & "ERROR: " & sMsg)

  IsRunning = False
  ErrorText = sMsg
  ReConnect()

End

'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
' reconnect routine
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Public Sub tReConnect_Timer()

  Connect()

End

'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
' peer closed tcp socket
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Public Sub MQTT_Closed()

  Main.WriteDebugLog(LogLabel & "ERROR: TCP socket closed by peer.")
  ReConnect()

End

Public Sub MQTT_Read()

  Dim bByte As Byte

  Try bByte = Read #hMQTT As Byte
  If Error Then Main.WriteDebugLog(LogLabel & "Error reading data from network socket! -> '" & Error.Text & "' at '" & Error.Where & "'")
  ParseMessage(bByte)

End

Public Sub MQTT_Ready()

  Main.WriteLog(LogLabel & "TCP interface connected.")
  IsRunning = True

    ' start ping timer
  tMQTTPing = New Timer As "tMQTTPing"
  tMQTTPing.Delay = $iHeartBeat * 1000 ' multiply for seconds
  tMQTTPing.Start

  ' define timer for busy
  tMQTTBusy = New Timer As "tMQTTBusy"
  tMQTTBusy.Stop

  ' connected so reset retry counter
  iReConnectRetry = 0

  ClientConnect($sClientname)
  SubscribeTopic($sSubTopic)

End

'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
' reconnect routine
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Public Sub ReConnect()

  Inc iReConnectRetry
  If iReConnectRetry < aReConnectDelay.Max Then
    Main.WriteLog(LogLabel & "Retry to connect in " & IIf(aReConnectDelay[iReConnectRetry] > 60000, CStr(aReConnectDelay[iReConnectRetry] / 60000) & " minutes.", CStr(aReConnectDelay[iReConnectRetry] / 1000) & " seconds."))
    tReConnect.Delay = aReConnectDelay[iReConnectRetry]
    tReConnect.Start
  Else
    tReConnect.Stop
  Endif

End

Public Sub tMQTTPing_Timer()

  ClientHeartBeat()

End

'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
' send connect message
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Private Sub ClientConnect(sId As String)

  Dim bBuf As New Byte[255]
  Dim iCnt As Integer

  ' fixed header
  bBuf[0] = MQTTCONNECT ' connect
  ' bBuf[1] = 12 + Len(sId) + 2 ' remaining length
  bBuf[1] = 12 + Len(sId) + 2 + Len($sUsername) + Len($sPassword) ' remaining length
  ' var header
  bBuf[2] = &H0   ' 0
  bBuf[3] = &H6   ' 6
  bBuf[4] = &H4D  ' M
  bBuf[5] = &H51  ' Q
  bBuf[6] = &H49  ' I
  bBuf[7] = &H73  ' s
  bBuf[8] = &H64  ' d
  bBuf[9] = &H70  ' p
  bBuf[10] = &H3  ' protocol version = 3

  ' connect flag
  bBuf[11] = &H2  ' clean session only
  If $sUsername Then bBuf[11] = BSet(bBuf[11], 7)
  If $sPassword And If Not $sUsername Then
    If $bMQTTDebug Then Main.WriteDebugLog(LogLabel & "You cannot supply a password without a username!")
    Return
  Else
    bBuf[11] = BSet(bBuf[11], 6)
  Endif
  bBuf[12] = &H0  ' MSB keepalive
  bBuf[13] = $iHeartBeat ' LSB
  bBuf[14] = &H0  ' ID string length MSB
  bBuf[15] = Len(sId)  ' ID string length LSB

  ' id
  For iCnt = 1 To Len(sId)
    bBuf.Add(Asc(Mid(sId, iCnt, 1)), 15 + iCnt)
  Next

  ' username
  If $sUsername Then
    For iCnt = 1 To Len($sUsername)
      bBuf.Add(Asc(Mid($sUsername, iCnt, 1)), 15 + iCnt + Len(sId))
    Next
  Endif

  ' password
  If $sPassword Then
    For iCnt = 1 To Len($sPassword)
      bBuf.Add(Asc(Mid($sPassword, iCnt, 1)), 15 + iCnt + Len(sId) + Len($sUsername))
    Next
  Endif

  If $bMQTTDebug Then Main.WriteDebugLog(LogLabel & "Connecting to broker.")
  bBuf.Resize(2 + bBuf[1])
  QueueCommand(bBuf)

End

'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
' send disconnect message
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Private Sub ClientDisconnect()

  Dim bBuf As New Byte[2]

  bBuf[0] = -&H7F + &5F ' disconnect
  bBuf[1] = &H0

  If $bMQTTDebug Then Main.WriteDebugLog(LogLabel & "Disconnecting from broker.")
  QueueCommand(bBuf)

End

'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
' send heartbeat message
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Private Sub ClientHeartBeat()

  Dim bBuf As New Byte[2]

  bBuf[0] = &HC0
  bBuf[1] = &H0

  If $bMQTTDebug Then Main.WriteDebugLog(LogLabel & "Sending heartbeat to broker.")
  QueueCommand(bBuf)

End

'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
' subscribe message
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Private Sub SubscribeTopic(sTopic As String)

  Dim bBuf As New Byte[255]
  Dim iCnt, iTopicLen As Integer

  iTopicLen = Len(sTopic)

  ' fixed header
  bBuf[0] = MQTTSUBSCRIBE     ' subscribe
  bBuf[1] = &H5 + Len(sTopic) ' remaining length
  bBuf[2] = &H0   ' MSB
  bBuf[3] = &HA   ' message id
  bBuf[4] = iTopicLen / 128   ' MSB
  bBuf[5] = iTopiclen Mod 128 ' # bytes of topic

  For iCnt = 1 To Len(sTopic)
    bBuf.Add(Asc(sTopic, iCnt), 5 + iCnt)
  Next
  bBuf.Add(&H0, 5 + Len(sTopic) + iCnt + 1)

  If $bMQTTDebug Then Main.WriteDebugLog(LogLabel & "Subscribing to Topic '" & sTopic & "'")
  bBuf.Resize(&H7 + Len(sTopic))
  QueueCommand(bBuf)

End

'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
' publish data
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Public Sub PublishMsg(sTopic As String, sMsg As String)

  Dim bBuf As New Byte[255]
  Dim iCnt, iTopicLen, iMsgLen As Integer

  sTopic = $sPubTopic &/ sTopic
  iTopicLen = Len(sTopic)
  iMsgLen = Len(sMsg)

  ' remove wildcards
  sTopic = Replace(sTopic, "#", " ")
  sTopic = Replace(sTopic, "+", " ")

  ' publish with retain enabled if set
  If $bRetain Then
    bBuf[0] = BSet(MQTTPUBLISH, 0)
  Else
    bBuf[0] = MQTTPUBLISH
  Endif

  ' set chosen QoS
  Select Case $iQoS
    Case 0
      ' default
    Case 1
      bBuf[0] = BSet(bBuf[0], 1)
    Case 2
      bBuf[0] = BSet(bBuf[0], 2)
    Case Else
      If $bMQTTDebug Then Main.WriteDebugLog(LogLabel & "Invalid QoS value '" & $iQoS & "' set!")
      Return
  End Select

  bBuf[1] = iTopicLen + iMsgLen + 2 ' remaining length
  bBuf[2] = iTopicLen / 128         ' MSB topic length
  bBuf[3] = iTopicLen Mod 128       ' LSB
  For iCnt = 1 To Len(sTopic)
    bBuf.Add(Asc(sTopic, iCnt), 3 + iCnt)
  Next
  For iCnt = 1 To Len(sMsg)
    bBuf.Add(Asc(sMsg, iCnt), 3 + iTopicLen + iCnt)
  Next

  If $bMQTTDebug Then Main.WriteDebugLog(LogLabel & "Publishing Message '" & sMsg & "' to Topic '" & sTopic & "'")
  bBuf.Resize(&H4 + Len(sTopic) + Len(sMsg))
  QueueCommand(bBuf)

End

'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
' add command to queue
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Private Sub QueueCommand(aPacket As Byte[])

  ' add command to queue
  cQueue.Add(aPacket, Rnd)

  ' if not busy process it
  If bBusy = False Then DoQueue()

End

'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
' process items in queue
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Private Sub DoQueue()

  Dim aPacket As Byte[] = Null

  For Each aPacket In cQueue
    WriteCommand(aPacket, cQueue.Key)
    Break ' only do first one
  Next

End

'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
' busy reset
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Public Sub tMQTTBusy_Timer()

  bBusy = False
  tMQTTBusy.Stop

  If cQueue.Count Then ' if there are more commands left in queue, send next one
    If $bMQTTDebug Then Main.WriteDebugLog(LogLabel & "Sending next command from Queue (count = " & cQueue.Count & ")")
    DoQueue()
  Endif

End

'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
' writes the packets
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Private Sub WriteCommand(bBuffer As Byte[], sKey As String)

  Dim iCnt As Integer
  Dim bByte As Byte

  If Not $bMQTTDebug Then
    bBuffer.Write(hMQTT, 0, bBuffer.Length)
  Else
    Main.WriteDebugLog(LogLabel & ">", True)
    For Each bByte In bBuffer
      If iCnt >= bBuffer.Length Then Break
      Try Write #hMQTT, CByte(bByte) As Byte
      Main.WriteDebugLogChars(" " & Hex(bByte, 2), True)
      Inc iCnt
    Next
    Main.WriteDebugLogChars("\n", True)
  Endif

  ' remove sent command from queue
  cQueue.Remove(sKey)

  tMQTTBusy.Delay = 10 ' 10mS (initial test value)
  tMQTTBusy.Start
  If bBusy = False Then bBusy = True

Catch
   Main.WriteDebugLog(LogLabel & "Not connected to MQTT Broker, cannot Publish! ")
   Connect()

End

Private Sub ParseMessage(bByte As Byte)

  Dim iType As Integer

  If RecBytes = 0 Then ' 1st byte of a packet received
    ' clear
    RecBuf[0] = 0
    RecBuf[1] = 0
    If bByte <> 0 Then
      If $bMQTTDebug Then Main.WriteDebugLogChars(LogLabel & "< ", 0)
    Endif
  Endif

  iType = Lsr(Val(RecBuf[0]), 4)

  Try RecBuf[RecBytes] = bByte ' store received byte
  Inc RecBytes  ' increment byte counter

  ' connack
  If iType = MQTT_CONNACK And If RecBytes = 4 Then
    If $bMQTTDebug Then
      Main.WriteDebugLogChars(Hex(bByte, 2) & "\n", 1)
      DecodeConnAck(RecBuf)
    Endif
    RecBytes = 0  ' set to zero to receive next message
  ' puback
  Else If iType = MQTT_PUBACK And If RecBytes = RecBuf[1] + 2 Then
    If $bMQTTDebug Then
      Main.WriteDebugLogChars(Hex(bByte, 2) & "\n", 1)
      DecodePubAck(RecBuf)
    Endif
    RecBytes = 0  ' set to zero to receive next message
  ' pingresp
  Else If iType = MQTT_PINGRESP And If RecBytes = 2 Then
    If $bMQTTDebug Then
      Main.WriteDebugLogChars(Hex(bByte, 2) & "\n", 1)
      Main.WriteDebugLog(LogLabel & "Server replied with alive packet.")
    Endif
    RecBytes = 0  ' set to zero to receive next message
  Else If iType = MQTT_SUBACK And If RecBytes = RecBuf[1] + 2 Then
    If $bMQTTDebug Then
      Main.WriteDebugLogChars(Hex(bByte, 2) & "\n", 1)
      'DecodeSubAck(RecBuf)
      Main.WriteDebugLog(LogLabel & "Subscription ack packet.")
    Endif
    RecBytes = 0  ' set to zero to receive next message
  Else If iType = MQTT_PUBLISH And If RecBytes = RecBuf[1] + 3 Then
    If $bMQTTDebug Then
       Main.WriteDebugLogChars(Hex(bByte, 2) & "\n", 1)
       Main.WriteDebugLog(LogLabel & "Received published data.")
    Endif
    DecodePublish(RecBuf)
    RecBytes = 0  ' set to zero to receive next message
  Else
    If $bMQTTDebug Then Main.WriteDebugLogChars(Hex(bByte, 2) & " ", 1) ' write the output to the screen
  Endif

  If Error Then Main.WriteDebugLog(LogLabel & "ERROR: '" & Error.Text & "' at '" & Error.Where & "'")

End

Private Sub DecodePublish(bBuffer As String[])

  Dim iCnt, iDeviceId As Integer
  Dim sTopic, sPayload, sDeviceTypeDescr, sLat, sLon, sAcc, sBatt, sEvent, sAlt, sCog, sVel, sTst As String
  Dim cPayload As Collection

  ' extract topic
  For iCnt = 5 To 4 + bBuffer[4]
    sTopic &= Chr(bBuffer[iCnt])
  Next
  If $bMQTTDebug Then Main.WriteDebugLog(LogLabel & "Received topic : '" & sTopic & "'")

  ' extract payload
  For iCnt = 5 + bBuffer[4] To RecBytes - 1
    sPayload &= Chr(bBuffer[iCnt])
  Next
  If $bMQTTDebug Then Main.WriteDebugLog(LogLabel & "Received payload : '" & sPayload & "'")

  ' lookup device
  iDeviceId = Devices.Find(Instance, sTopic, InterfaceId)
  If iDeviceId Then
    ' what kind of mqtt devicetype is this device set to?
    sDeviceTypeDescr = Devices.FindDeviceTypeDescriptionForDeviceId(iDeviceId)
    Select Case sDeviceTypeDescr
      Case "MQTT Owntracks Client"
        Try cPayload = JSON.Decode(sPayload)
        If cPayload.Count Then
          If cPayload["_type"] = "location" Then
            sLat = cPayload["lat"]
            sLon = cPayload["lon"]
            sAcc = cPayload["acc"]
            sBatt = cPayload["batt"]
            sEvent = cPayload["event"]
            sTst = Util.TimeSinceEpoch(cPayload["tst"])
            If cPayload["alt"] <> Null Then
              sAlt = cPayload["alt"]
            Endif
            If cPayload["cog"] <> Null Then
              sCog = cPayload["cog"]
            Endif
            ' speed in km/hr
            If cPayload["vel"] <> Null Then
              sVel = cPayload["vel"]
            Endif
            If $bMQTTDebug Then
              Main.WriteDebugLog(LogLabel & "Received Owntracks client data:")
              Main.WriteDebugLog(LogLabel & "Latitude: " & sLat)
              Main.WriteDebugLog(LogLabel & "Longitude: " & sLon)
              Main.WriteDebugLog(LogLabel & "Accuracy: " & sAcc)
              Main.WriteDebugLog(LogLabel & "Battery: " & sBatt & "%")
              Main.WriteDebugLog(LogLabel & "Event: " & sEvent)
              Main.WriteDebugLog(LogLabel & "Timestamp: " & sTst)
              If sAlt Then Main.WriteDebugLog(LogLabel & "Altitude: " & sAlt)
              If sCog Then Main.WriteDebugLog(LogLabel & "Heading: " & sCog)
              If sVel Then Main.WriteDebugLog(LogLabel & "Speed: " & sVel)
            Endif
            Devices.ValueUpdate(iDeviceId, 1, sLat)
            Devices.ValueUpdate(iDeviceId, 2, sLon)
            Devices.ValueUpdate(iDeviceId, 3, sEvent)
            Devices.ValueUpdate(iDeviceId, 4, sAcc)
            Devices.ValueUpdate(iDeviceId, 5, sTst)
            If sAlt Then Devices.ValueUpdate(iDeviceId, 6, sAlt)
            If sCog Then Devices.ValueUpdate(iDeviceId, 7, sCog)
            If sVel Then Devices.ValueUpdate(iDeviceId, 8, sVel)
            Devices.Battery(iDeviceId, sBatt)
          Else
            If $bMQTTDebug Then Main.WriteDebugLog(LogLabel & "Owntracks payload type '" & cPayload["_type"] & "' not supported.")
          Endif
        Else
          If $bMQTTDebug Then Main.WriteDebugLog(LogLabel & "Received payload is not using Owntracks location format '" & sPayload & "'!")
        Endif
      Case "MQTT Generic Device"
        Devices.ValueUpdate(iDeviceId, 1, sPayload)
    End Select
  Endif

End

Private Sub DecodeConnAck(bBuffer As String[])

  ' 20020000
  Select Case bBuffer[3]
    Case 0
      Main.WriteDebugLog(LogLabel & "Connection accepted by server.")
    Case 1
      Main.WriteDebugLog(LogLabel & "Connection refused by server, wrong protocol version.")
    Case 2
      Main.WriteDebugLog(LogLabel & "Connection refused by server, identifier refused.")
    Case 3
      Main.WriteDebugLog(LogLabel & "Connection refused by server, MQTT service unavailable.")
    Case 4
      Main.WriteDebugLog(LogLabel & "Connection refused by server, bad username or password.")
    Case 5
      Main.WriteDebugLog(LogLabel & "Connection refused by server, client is not authorized.")
    Case Else
      Main.WriteDebugLog(LogLabel & "Received unknown CONNACK status code!")
  End Select

End

Private Sub DecodePubAck(bRecBuf As String[])

  Main.WriteDebugLog(LogLabel & "Subscription accepted by broker.")
  ' TODO: implement decode message id and QoS granted

End

