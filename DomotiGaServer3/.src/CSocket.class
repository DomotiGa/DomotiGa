' Gambas class file

' Description:
' CSocket.class
' Support none-SSL and SSL TCP sockets

' Development Status:
' Just started.

' DomotiGa - an open source home automation program.
' Copyright (C) Ron Klinkien, The Netherlands.

' Read file called COPYING for license details.

'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
' Define external OpenSSL library calls. We support 0.9.8/1.0.x/1.1.x
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Library "libssl"
Private Extern SSL_new(pCTX As Pointer) As Pointer
Private Extern SSL_free(pSSL As Pointer)
Private Extern SSL_shutdown(pSSL As Pointer) As Integer
Private Extern SSL_set_fd(pSSL As Pointer, iFd As Integer) As Integer
Private Extern SSL_read(pSSL As Pointer, pData As Pointer, iLen As Integer) As Integer
Private Extern SSL_write(pSSL As Pointer, pData As Pointer, iLen As Integer) As Integer
Private Extern SSL_accept(pSSL As Pointer) As Integer
Private Extern SSL_get_error(pSSL As Pointer, iRC As Integer) As Integer

'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
' My events
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Event {Closed}
Event {Found}
Event {Error}(sError As String)
Event {Read}(sData As String)
Event {Ready}
Event {Write}

'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
' Constants
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Public Const SSL_ERROR_NONE As Integer = 0
Public Const SSL_ERROR_SSL As Integer = 1
Public Const SSL_ERROR_WANT_READ As Integer = 2
Public Const SSL_ERROR_WANT_WRITE As Integer = 3
Public Const SSL_ERROR_WANT_X509_LOOKUP As Integer = 4
Public Const SSL_ERROR_SYSCALL As Integer = 5
Public Const SSL_ERROR_ZERO_RETURN As Integer = 6
Public Const SSL_ERROR_WANT_CONNECT As Integer = 7
Public Const SSL_ERROR_WANT_ACCEPT As Integer = 8

Public Const PROTOCOL_NONE As Integer = 0
Public Const PROTOCOL_HTTP As Integer = 1
Public Const PROTOCOL_HTTP_WEBSOCKET As Integer = 2
Public Const PROTOCOL_WEBSOCKET As Integer = 3

'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
' Properties
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Property EndOfLine As Integer
Property Read Handle As Integer
Property Host As String
Property Read LocalHost As String
Property Read LocalPort As Integer
Property Path As String
Property Port As Integer
Property Read RemoteHost As String
Property Read RemotePort As Integer
Property Read Status As Integer
Property Timeout As Integer
Property Tag As Variant
Property Protocol As Integer

Property HTTPCode As Integer
Property HTTPTimeOut As Integer
Property HTTPKeepAlive As Integer
Property HTTPSize As Integer
Property HTTPMethods As String[]
Property HTTPContentTypes As String[]
Property HTTPHeaders As String[]
Property HTTPRequestInUrl As String

'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
' Variables
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Private $iEndOfLine As Integer = gb.Unix
Private $iTimeout As Integer = 0
Private $iEncrypt As Integer = Net.None ' 0=Net.None, 1=Net.SSL
Private $iProtocol As Integer = PROTOCOL_NONE
Private $iSSLBufferSize As Integer = 1024 ' The SSL buffer size for reading the socket
Private $pCTX As Pointer
Private $pSSL As Pointer
Private $bSSLAcceptHandshake As Boolean
Private $sDataIn As String
Private $sDataOut As String
Public MySocket As New Socket

Public $tHTTPTimer As Timer
Private $iHTTPCode As Integer
Private $iHTTPSize As Integer = 65535
Private $cHTTPMethods As New String[]
Private $cHTTPContentTypes As New String[]
Private $cHTTPHeaders As New String[]
Private $sHTTPRequestInUrl As String
Private $iHTTPTimeOut As Integer = 200 '*0.005
Private $iHTTPKeepAlive As Integer = 15000
Private $sHTTPMethod As String
Private $cHTTPConnection As New String[]
Private $bHTTPDeflate As Boolean = False
Private $sHTTPCrossOrigin As String
Private $sHTTPAccessControlRequestHeaders As String

Private $sWebSocketProtocol As String
Private $bWebSocketEnabled As Boolean
Private $sWebSocketHandShake As String

'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
' Called when Class is created
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Public Sub _new()

  $cHTTPMethods.Insert(["POST", "GET", "OPTIONS", "HEAD", "PUT", "DELETE", "TRACE", "CONNECT"])

End

'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
' Called when Class is destroyed, free/close used variables
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Public Sub _free()

  If $pSSL <> Null Then
    Try SSL_shutdown($pSSL)
    Try SSL_free($pSSL)
    $pSSL = Null
  Endif

  Try $tHTTPTimer.Stop
  Try Close #MySocket

End

'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
' Read None-SSL and SSL data from socket
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Public Sub MySocket_Read()

  Dim sData As String
  Dim pData As Pointer
  Dim iLen As Integer
  Dim iRet As Integer

  If $iEncrypt = Net.SSL Then

    If $pSSL = Null Then
      Raise Error("SSL Object has Null value (SSL_read)")
      Return
    Endif 

    If Not $bSSLAcceptHandshake Then
      iRet = SSL_accept($pSSL)
      If iRet = 1 Then
        $bSSLAcceptHandshake = True

        ' Raise Ready event if we are a client, SSL handshake is done
        If MySocket.Server = Null Then
          Raise Ready
        Endif
      Else
        If iRet = -1 Then
          Try iRet = SSL_get_error($pSSL, iRet)
          If iRet <> SSL_ERROR_WANT_READ And If iRet <> SSL_ERROR_WANT_WRITE Then
            If $pSSL <> Null Then
              Try SSL_shutdown($pSSL)
              Try SSL_free($pSSL)
              $pSSL = Null
            Endif

            Try Close #MySocket

            Raise Error("SSL handshake failed RC=" & iRet & " (" & Display_SSL_ERROR(iRet) & ")")
            Return
          Endif
        Endif

      Endif
    Endif

    ' Don't continue if the handshake didn succeed
    If Not $bSSLAcceptHandshake Then Return

    ' Allocate a read buffer for the read routine
    pData = Alloc($iSSLBufferSize)

    Repeat
      iLen = SSL_read($pSSL, pData, $iSSLBufferSize)

      If iLen < 0 Then
        '
        iRet = SSL_get_error($pSSL, iLen)

      Else If iLen = 0 Then
        ' Socket gone or almost gone
      Else
        ' We have read data from the socket, append it to our string
        sData &= String@(pData, iLen)
      Endif

    Until iLen <= 0

    Free(pData)

  Else
    ' No SSL, just read the socket
    Read #Last, sData, Lof(Last)
  Endif

  ' Data read, raise the read event for further processing
  If sData Then

    If $iProtocol = PROTOCOL_HTTP Or If ($iProtocol = PROTOCOL_HTTP_WEBSOCKET And Not $bWebSocketEnabled) Or If ($iProtocol = PROTOCOL_WEBSOCKET And Not $bWebSocketEnabled) Then

      If $sDataIn Then
        ' Don't continue, the other loop will pick of the changes
        $sDataIn &= sData
        Return
      Else
        $sHTTPMethod = ""
        $cHTTPConnection.Clear()
        $bHTTPDeflate = False
        $sHTTPCrossOrigin = ""
        $sHTTPAccessControlRequestHeaders = ""

        $sDataIn &= sData

        If Protocol_HTTP_Read() Then
          Raise Read($sDataIn)
        Endif

        $sDataIn = ""
      Endif

    Else
      If $bWebSocketEnabled Then
      Else
        $sDataIn = ""
        Raise Read(sData)
      Endif
    Endif
  Endif

End

'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
' Handle HTTP data and only return the body of the request upstream
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Private Sub Protocol_HTTP_Read() As Boolean

  Dim iWait As Integer = 1
  Dim iCount As Integer
  Dim iPos As Integer
  Dim iLen As Integer
  Dim sHTTPHeader As String
  Dim cHTTPHeader As New Collection
  Dim sHTTPHeaderTemp As String
  Dim sHTTPProtocol As String
  Dim iHTTPContentLength As Integer = -1
  Dim sHTTPContentType As String
  Dim bHTTPChunked As Boolean = False

  Try $tHTTPTimer.Stop

  ' At least wait until we retrieve the http headers
  For iCount = iWait To ($iHTTPTimeOut + 1) Step 1
    iPos = InStr($sDataIn, gb.CrLf & gb.CrLf)
    If iPos >= 1 Then Break
    Wait 0.005
  Next

  ' Problem with reading valid http data
  If iWait > $iHTTPTimeOut Then
    Close()
    Raise Closed()
    Return False
  Endif

  sHTTPHeader = Left($sDataIn, iPos)
  iPos = InStr(sHTTPHeader, Chr(13))
  If iPos >= 1 Then
    sHTTPHeaderTemp = Left(sHTTPHeader, iPos - 1)
  Else
    Close()
    Raise Closed()
    Return False
  Endif

  ' Look for the http method
  iPos = InStr(sHTTPHeaderTemp, " ") - 1
  If iPos >= 1 Then
    $sHTTPMethod = Left(sHTTPHeaderTemp, iPos)
  Else
    Close()
    Raise Closed()
    Return False
  Endif

  iPos = RInStr(sHTTPHeaderTemp, " ") + 1
  If iPos > 1 Then
    sHTTPProtocol = Mid(sHTTPHeaderTemp, iPos)

    If sHTTPProtocol <> "HTTP/1.0" And If sHTTPProtocol <> "HTTP/1.1" Then
      $iHTTPCode = 505 'HTTP Version Not Supported
      Send()
      Close()
      Return False
    Endif
  Else
    Close()
    Return False
  Endif

  ' Only allow certain methods
  If Not $cHTTPMethods.Exist($sHTTPMethod) Then
    $iHTTPCode = 405 'Not Allowed
    Send()
    Close()
    Return False
  Endif

  For Each sHTTPHeaderTemp In Split(Mid(sHTTPHeader, iPos + Len(sHTTPProtocol) + 1), gb.CrLf)
    iPos = InStr(sHTTPHeaderTemp, ":")
    If iPos > 0
      cHTTPHeader[UCase(Left(sHTTPHeaderTemp, iPos - 1))] = Trim(Right(sHTTPHeaderTemp, -1 * (iPos + 1)))
    Endif
  Next

  If cHTTPHeader.Exist("ACCEPT-ENCODING") Then
    If InStr(UCase(cHTTPHeader["ACCEPT-ENCODING"]), "DEFLATE") Then $bHTTPDeflate = True
  Endif

  If cHTTPHeader.Exist("CONTENT-LENGTH") Then
    Try iHTTPContentLength = CInt(cHTTPHeader["CONTENT-LENGTH"])
    If Error Then
      $iHTTPCode = 411 'Length Required
      Send()
      Close()
      Return False
    Endif

    If iHTTPContentLength < 0 Then
      $iHTTPCode = 400 'Bad Request
      Send()
      Close()
      Return False
    Endif
  Else
    If cHTTPHeader.Exist("TRANSFER-ENCODING") Then
      If InStr(UCase(cHTTPHeader["TRANSFER-ENCODING"]), "CHUNKED") Then bHTTPChunked = True

      If Not bHTTPChunked Then
        $iHTTPCode = 400 'Bad Request
        Send()
        Close()
        Return False
      Endif
    Endif
  Endif

  If cHTTPHeader.Exist("CONTENT-TYPE") Then
    If InStr(cHTTPHeader["CONTENT-TYPE"], ";") Then cHTTPHeader["CONTENT-TYPE"] = Left(cHTTPHeader["CONTENT-TYPE"], InStr(cHTTPHeader["CONTENT-TYPE"], ";") - 1)

    sHTTPHeaderTemp = UCase($cHTTPContentTypes.Join(";"))
    $cHTTPContentTypes = Split(sHTTPHeaderTemp, ";")
  Endif

  If $cHTTPContentTypes.Count > 0 Then
    If cHTTPHeader.Exist("CONTENT-TYPE") Or If Not $cHTTPContentTypes.Exist(sHTTPContentType) Then
      $iHTTPCode = 415 'Unsupported Media Type
      Send()
      Close()
      Return False
    Endif
  Endif

  If cHTTPHeader.Exist("ORIGIN") Then
    If InStr(cHTTPHeader["ORIGIN"], "http://localhost") Then
      $sHTTPCrossOrigin = "*"
    Else
      $sHTTPCrossOrigin = cHTTPHeader["ORIGIN"]
    Endif

    ' Maybe we got a "Access-Control-Request-Headers" too?
    If cHTTPHeader.Exist("ACCESS-CONTROL-REQUEST-HEADERS") Then
      $sHTTPAccessControlRequestHeaders = cHTTPHeader["ACCESS-CONTROL-REQUEST-HEADERS"]
    Endif
  Endif

  If cHTTPHeader.Exist("CONNECTION") Then
  iPos = InStr(UCase(sHTTPHeader), Chr(10) & "CONNECTION:")
    $cHTTPConnection = Split(UCase(Replace(cHTTPHeader["CONNECTION"], " ", "")), ",")

    ' Don't accept upgrades on normal HTTP requests
    If $cHTTPConnection.Exist("UPGRADE") And If $iProtocol = PROTOCOL_HTTP Then
      $iHTTPCode = 400 'Bad Request
      Send()
      Close()
      Return False
    Endif
  Endif

  ' HTTP/1.0 doesn't support keep-alive properly
  If sHTTPProtocol = "HTTP/1.0" Then
    $cHTTPConnection.Clear()
    $cHTTPConnection.Add("CLOSE")
  Endif

  ' Any HTTP/1.1 request is required to have "Host: ..." field
  If sHTTPProtocol = "HTTP/1.1" And If Not cHTTPHeader.Exist("HOST") Then
    $iHTTPCode = 400 'Bad Request
    Send()
    Close()
    Return False
  Endif

  ' Check for "Expect: 100-continue" option & HTTP/1.1
  If sHTTPProtocol = "HTTP/1.1" And If cHTTPHeader.Exist("EXPECT") And If UCase(cHTTPHeader["EXPECT"]) = "100-CONTINUE" Then

    ' When it isn't chunked mode, reject the request if the body is too large
    If Not bHTTPChunked Then
      If iHTTPContentLength > $iHTTPSize Then
        $iHTTPCode = 417 'Expectation Failed
        Send()
        Close()
        Return False
      Endif
   Endif

    ' Do a special check if no body is received - only then reply
    If (Len(sHTTPHeader) + 3) = Len($sDataIn) Then
      Begin()
      $iEndOfLine = gb.Windows
      Print("HTTP/1.1 100 Continue")
      Print("")
      Try Send(False)
    Endif
  Endif

  ' When it isn't chunked mode, reject the request if the body is too large
  If Not bHTTPChunked Then
    If iHTTPContentLength > $iHTTPSize Then
      $iHTTPCode = 413 'Request Entity Too Large
      Send()
      Close()
      Return False
    Endif
  Endif

  ' Check if we have an upgrade request to websocket
  If $iProtocol = PROTOCOL_HTTP_WEBSOCKET Or If $iProtocol = PROTOCOL_WEBSOCKET Then

    If UCase(cHTTPHeader["UPGRADE"]) = "WEBSOCKET" And If $cHTTPConnection.Exist("UPGRADE") Then

      ' WebSocket upgrade only can be done via a GET
      If $sHTTPMethod <> "GET" Then
        $iHTTPCode = 400 'Bad Request
        Send()
        Close()
        Return False
      Endif

      ' We only support RFC6455 , version=13
      If cHTTPHeader.Exist("SEC-WEBSOCKET-KEY") And If Len(UnBase64(cHTTPHeader["SEC-WEBSOCKET-KEY"])) = 16 And If cHTTPHeader.Exist("SEC-WEBSOCKET-VERSION") And If cHTTPHeader["SEC-WEBSOCKET-VERSION"] = 13 Then

        If $sWebSocketProtocol And If cHTTPHeader.Exist("SEC-WEBSOCKET-PROTOCOL") Then
        Endif

        $sWebSocketHandShake = MakeWebSocketHandShake(cHTTPHeader["SEC-WEBSOCKET-KEY"])
        $iHTTPCode = 101 'Switching Protocols
        Send()
        $bWebSocketEnabled = True
        Return False
      Else
        $iHTTPCode = 400 'Bad Request
        Send()
        Close()
        Return False
      Endif

      Return False
    Else
      ' WebSocket has to be upgraded
      If $iProtocol = PROTOCOL_WEBSOCKET Then
        $iHTTPCode = 400 'Bad Request
        Send()
        Close()
        Return False
      Endif
    Endif
  Else
    ' A normal HTTP connection can't be upgraded
    If cHTTPHeader.Exist("UPGRADE") Or If $cHTTPConnection.Exist("UPGRADE") Then
      $iHTTPCode = 400 'Bad Request
      Send()
      Close()
      Return False
    Endif
  Endif

  ' Check for possible URL requests
  If iHTTPContentLength = 0 And If $sHTTPRequestInUrl Then
    ' First get the first line, this is the URL and remove the HTTP/1.x
    sHTTPHeaderTemp = Trim(Left(sHTTPHeader, InStr(sHTTPHeader, Chr(13)) - 9))
    iPos = InStr(sHTTPHeaderTemp, $sHTTPRequestInUrl)
    If iPos >= 1 Then
      sHTTPHeaderTemp = Mid(sHTTPHeaderTemp, iPos + Len($sHTTPRequestInUrl))
      Try $sDataIn = URL.Decode(sHTTPHeaderTemp)
      If Error Then
        $iHTTPCode = 400 'Bad Request
        Send()
        Close()
        Return False
      Endif
      Return True
    Endif
  Endif

  ' It is possible we didn't receive all data, so loop until we think we have it
  iPos = InStr($sDataIn, gb.CrLf & gb.CrLf) - 3
  sHTTPHeaderTemp = gb.CrLf & "0" & gb.CrLf & gb.CrLf

  For iCount = iWait To ($iHTTPTimeOut + 2) Step 1

    If bHTTPChunked Then
      If Right($sDataIn, Len(sHTTPHeaderTemp)) = sHTTPHeaderTemp Then Break
    Else
      iLen = Len($sDataIn) - iPos
      If iLen >= iHTTPContentLength Then Break
    Endif

    Wait 0.005
  Next

  ' Check for possible timeout
  If iCount > ($iHTTPTimeOut + 1) Then
    $iHTTPCode = 408 'Request Timeout
    Send()
    Close()
    Return False
  Endif

  If bHTTPChunked Then
    sHTTPHeaderTemp = Mid($sDataIn, InStr($sDataIn, gb.CrLf & gb.CrLf) + 4)
    $sDataIn = ""

    While sHTTPHeaderTemp
      iPos = InStr(sHTTPHeaderTemp, gb.CrLf)
      Try iLen = Val("&H" & Left(sHTTPHeaderTemp, iPos - 1))
      If Error Then
        $iHTTPCode = 400 'Bad Request
        Send()
        Close()
        Return False
      Endif

      sHTTPHeaderTemp = Mid(sHTTPHeaderTemp, iPos + 2)

      If iLen + 2 > Len(sHTTPHeaderTemp) Then
        $iHTTPCode = 400 'Bad Request
        Send()
        Close()
        Return False
      Endif

      ' Copy the data into our input buffer and remove it
      $sDataIn &= Left(sHTTPHeaderTemp, iLen)
      sHTTPHeaderTemp = Mid(sHTTPHeaderTemp, iLen + 3)

      ' Check if we are still inside the expected size
      If Len($sDataIn) > $iHTTPSize Then
        $iHTTPCode = 413 'Request Entity Too Large
        Send()
        Close()
        Return False
      Endif

      ' Check if the buffer still looks ok
      If sHTTPHeaderTemp And If InStr(sHTTPHeaderTemp, gb.CrLf) = 0 Then
        $iHTTPCode = 400 'Bad Request
        Send()
        Close()
        Return False
      Endif
    Wend

    If $sHTTPMethod = "OPTIONS" Then
      Send()
      Return False
    Endif

  Else
    If iLen < iHTTPContentLength Then
      $iHTTPCode = 500 'Internal Server Error
      Send()
      Close()
      Return False
    Endif

    If $sHTTPMethod = "OPTIONS" Then
      Send()
      Return False
    Else
      $sDataIn = Mid($sDataIn, InStr($sDataIn, gb.CrLf & gb.CrLf) + 4)
    Endif
  Endif

  ' We are a persistent connection, start our timer
  ' We need to exclude HTTP/1.0 and upgraded connections
  If Not $cHTTPConnection.Exist("CLOSE") And Not $cHTTPConnection.Exist("UPGRADE") Then
    If $tHTTPTimer = Null Then
      $tHTTPTimer = New Timer As "HTTPTimer"
      $tHTTPTimer.Delay = $iHTTPKeepAlive
      $tHTTPTimer.Start
    Else
      $tHTTPTimer.Delay = $iHTTPKeepAlive
      $tHTTPTimer.Start
    Endif
  Endif

  Return True

End

'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
' Create HTTP data, upstream is unaware of HTTP
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Private Sub Protocol_HTTP_Write()

  Dim sDataOut As String
  Dim cCz As New Compress
  Dim sDeflateData As String
  Dim sStr As String
  Dim bServer As Boolean
  Dim bContentType As Boolean

  ' Check if we should respond with an error
  Select $iHTTPCode
    Case 100 ' Continue
    Case 101 ' Switching Protocols
    Case 200 ' OK
    Case 400
      sDataOut = "400 Bad Request"
    Case 405
      sDataOut = "405 Not Allowed"
    Case 408
      sDataOut = "408 Request Timeout"
    Case 411
      sDataOut = "411 Length Required"
    Case 413
      sDataOut = "413 Request Entity Too Large"
    Case 415
      sDataOut = "415 Unsupported Media Type"
    Case 417
      sDataOut = "417 Expectation Failed"
    Case 500
      sDataOut = "500 Internal Server Error"
    Case 505
      sDataOut = "505 HTTP Version Not Supported"
  End Select

  ' Something went wrong, construct output and quit
  If $iHTTPCode >= 400 Then
    sDataOut = "HTTP/1.1 " & sDataOut & gb.CrLf
    bServer = False
    For Each sStr In $cHTTPHeaders
      If InStr(UCase(sStr), "SERVER:") = 1 Then
        sDataOut &= sStr & gb.CrLf
        bServer = True
        Break
      Endif
    Next

    If Not bServer Then sDataOut &= "Server: Gambas Server" & gb.CrLf
    sDataOut &= "Connection: close" & gb.CrLf

    If $iHTTPCode = 405 And $cHTTPMethods.Count > 0 Then
      sDataOut &= "Allow: " & $cHTTPMethods.Join(", ") & gb.CrLf
    Endif

    sDataOut &= gb.CrLf
    $sDataOut = sDataOut

    ' Reset code to zero, it needs to be set with every send call
    $iHTTPCode = 0

    Return
  Endif

  ' We are upgrading to WebSockets
  If $iHTTPCode = 101 Then
    sDataOut = "HTTP/1.1 101 Switching Protocols" & gb.CrLf
    sDataOut &= "Upgrade: websocket" & gb.CrLf
    sDataOut &= "Connection: Upgrade" & gb.CrLf
    sDataOut &= "Sec-WebSocket-Accept: " & $sWebSocketHandShake & gb.CrLf
    'If $sHTTPCrossOrigin Then sDataOut &= "Sec-WebSocket-Origin: " & $sHTTPCrossOrigin & gb.CrLf
    sDataOut &= gb.CrLf
    $sDataOut = sDataOut

    ' Reset code to zero, it needs to be set with every send call
    $iHTTPCode = 0

    Return
  Endif

  ' With an Options request, just respond and don't process further
  If $sHTTPMethod = "OPTIONS" Then
    sDataOut = "HTTP/1.1 200 OK" & gb.CrLf
    If $sHTTPCrossOrigin Then
      sDataOut &= "Access-Control-Allow-Origin: " & $sHTTPCrossOrigin & gb.CrLf
      sDataOut &= "Access-Control-Allow-Methods: " & $cHTTPMethods.Join(", ") & gb.CrLf
      If $sHTTPAccessControlRequestHeaders Then 
        sDataOut &= "Access-Control-Allow-Headers: " & $sHTTPAccessControlRequestHeaders & gb.CrLf
      Endif
    Else
      sDataOut &= "Allow: " & $cHTTPMethods.Join(", ") & gb.CrLf
    Endif

    sDataOut &= "Content-Length: 0" & gb.CrLf
    sDataOut &= gb.CrLf
    $sDataOut = sDataOut

    ' Reset code to zero, it needs to be set with every send call
    $iHTTPCode = 0

    Return
  Endif

  ' If we *send* send a compressed stream, try to compress
  If $bHTTPDeflate Then
    cCz.Type = "zlib"
    Try sDeflateData = cCz.String($sDataOut)
    If Not Error Then
      If Len(sDeflateData) >= Len($sDataOut) Then
        ' Most likely the string/data is to small
        $bHTTPDeflate = False
      Endif
    Else
      ' don't do anything
      $bHTTPDeflate = False
    Endif
  Endif

  sDataOut = "HTTP/1.1 200 OK" & gb.CrLf
  'Print "Date: " & Format$(DateAdd(Now, gb.Minute, CInt(Main.fAstroAutoTimezone * -60)), "ddd dd mmm yyyy hh:nn:ss") & " GMT"

  If $cHTTPConnection.Exist("CLOSE") Then
    sDataOut &= "Connection: close" & gb.CrLf
  Else
    sDataOut &= "Connection: keep-alive" & gb.CrLf
  Endif

  If $bHTTPDeflate Then
    sDataOut &= "Content-Length: " & Len(sDeflateData) & gb.CrLf
  Else
    sDataOut &= "Content-Length: " & Len($sDataOut) & gb.CrLf
  Endif
  If $bHTTPDeflate Then sDataOut &= "Content-Encoding: deflate" & gb.CrLf
  If $sHTTPCrossOrigin Then sDataOut &= "Access-Control-Allow-Origin: " & $sHTTPCrossOrigin & gb.CrLf

  For Each sStr In $cHTTPHeaders
    sDataOut &= sStr & gb.CrLf
    sStr = UCase(sStr)
    If InStr(sStr, "SERVER:") = 1 Then bServer = True
    If InStr(sStr, "CONTENT-TYPE:") = 1 Then bContentType = True
  Next

  If Not bServer Then sDataOut &= "Server: Gambas Server" & gb.CrLf
  If Not bContentType Then sDataOut &= "Content-Type: text/plain" & gb.CrLf

  sDataOut &= gb.CrLf

  ' Writes compress data when possible
  If $bHTTPDeflate Then
    $sDataOut = sDataOut & sDeflateData
  Else
    $sDataOut = sDataOut & $sDataOut
  Endif

  ' Reset code to zero, it needs to be set with every send call
  $iHTTPCode = 0

End

'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
' HTTP Timer to terminate inactive persistent connections
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Public Sub HTTPTimer_Timer()

  Close()

End

'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
' Raise a Write event if the socket is ready for writing
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Public Sub MySocket_Write()

  If $iEncrypt = Net.SSL Then
    ' Not sure this works?
    Raise Write
  Else
    Raise Write
  Endif

End

'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
' Generate the handshake key for WebSockets
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Private Sub MakeWebSocketHandShake(sKey As String) As String

  Dim sSpecial As String = "258EAFA5-E914-47DA-95CA-C5AB0DC85B11"
  Dim sSum As String
  Dim iCount As Integer
  Dim sResult As String

  ' Append the uuid to the key
  sKey &= sSpecial

  ' Generate the SHA1 hash
  Shell "echo -n \"" & sKey & "\" | sha1sum" To sSum
  sSum = Left(sSum, -4)

  For iCount = 1 To Len(sSum) Step 2
   sResult &= Chr(Val("&H" & Mid(sSum, iCount, 2)))
  Next

  ' Now base64 our result
  Return Base64(sResult)

End

'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
' Start a new line/print session
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Public Sub Begin()

  $sDataOut = ""

End

'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
' Add the line with a proper linefeed character(s)
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Public Sub Print(sData As String, Optional bEOL As Boolean = True)

  If bEOL Then
    Select $iEndOfLine
      Case gb.Unix
        $sDataOut &= sData & Chr$(10)
      Case gb.Windows
        $sDataOut &= sData & Chr$(13) & Chr$(10)
      Case gb.Mac
        $sDataOut &= sData & Chr$(13)
      Default
        $sDataOut &= sData & Chr$(10)
    End Select
  Else
    $sDataOut &= sData
  Endif

End

'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
' Drop the data stored in the internal buffer
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Public Sub Drop()

  $sDataOut = ""

End

'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
' Send the data in the internal buffer, as line/print
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Public Sub Send(Optional bProtocol As Boolean = True)

  Dim pData As Pointer
  Dim iRet As Integer
  Dim sStream As Stream

  If bProtocol Then
    If $iProtocol = PROTOCOL_HTTP Or If ($iProtocol = PROTOCOL_HTTP_WEBSOCKET And Not $bWebSocketEnabled) Or If ($iProtocol = PROTOCOL_WEBSOCKET And Not $bWebSocketEnabled) Then
      Protocol_HTTP_Write()
    Else
    Endif
  Endif

  If Not $sDataOut Then Return

  If $iEncrypt = Net.SSL Then

    If $pSSL = Null Then
      Error.Raise("SSL Object has Null value (SSL_write)")
      Return
    Endif 

    If Not $bSSLAcceptHandshake Then
      iRet = SSL_accept($pSSL)
      If iRet = 1 Then
        $bSSLAcceptHandshake = True
      Else
        If iRet = -1 Then
          Try iRet = SSL_get_error($pSSL, iRet)
          If iRet <> SSL_ERROR_WANT_READ And If iRet <> SSL_ERROR_WANT_WRITE Then
            If $pSSL <> Null Then
              Try SSL_shutdown($pSSL)
              Try SSL_free($pSSL)
              $pSSL = Null
            Endif

            Try Close #MySocket

            Error.Raise("SSL handshake failed RC=" & iRet & " (" & Display_SSL_ERROR(iRet) & ")")
            Return
          Endif
        Endif
      Endif
    Endif

    ' Don't continue if the handshake didn't succeed
    If Not $bSSLAcceptHandshake Then Return

    pData = Alloc(Len($sDataOut))
    sStream = Memory pData For Read Write
    Write #sStream, $sDataOut, Len($sDataOut)
    Try iRet = SSL_write($pSSL, pData, Len($sDataOut))
    Free(pData)

    If iRet <= 0 Then
      Try iRet = SSL_get_error($pSSL, iRet)
      Error.Raise("SSL Write Failed RC=" & iRet & " (" & Display_SSL_ERROR(iRet) & ")")
      Return
    Endif

  Else
    MySocket.Blocking = True
    Try Write #MySocket, $sDataOut, Len($sDataOut)
    MySocket.Blocking = False
  Endif

  $sDataOut = ""

  ' If HTTP Protocol, please run a Close() here
  If bProtocol Then
    If $iProtocol = PROTOCOL_HTTP Then

      ' Close the connection if the client requested it
      If $cHTTPConnection.Exist("CLOSE") Then
        Close()
      Endif
    Else
    Endif
  Endif

End

'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
' Socket is closed by server
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Public Sub Close()

  Try $tHTTPTimer.Stop

  If $iEncrypt = Net.SSL Then
    If $pSSL <> Null Then
      Try SSL_shutdown($pSSL)
      Try SSL_free($pSSL)
      $pSSL = Null
    Endif
    Try Close #MySocket
  Else
    Try Close #MySocket
  Endif

  Object.Detach(MySocket)

  Raise Closed()

End

'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
' Socket is closed by client
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Public Sub MySocket_Ready()

  If $iEncrypt <> Net.SSL Then
    Raise Ready
  Endif

End

'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
' Socket is closed by client
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Public Sub MySocket_Closed()

  Try $tHTTPTimer.Stop

  Raise Closed

End

'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
' Assigns the just created socket to our SSLSocket
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Public Sub AssignSocket(sServerSocket As CServerSocket)

  Dim iRet As Integer

  MySocket = sServerSocket.Accept()
  $iTimeout = sServerSocket.Timeout
  $iEncrypt = sServerSocket.Encrypt
  $pCTX = sServerSocket.SSLCTX
  Object.Attach(MySocket, Me, "MySocket")

  If $iEncrypt = Net.SSL Then

    If $pCTX = Null Then
      Error.Raise("SSL CTX is NULL value")
      Return
    Endif

    $pSSL = SSL_new($pCTX)

    If $pSSL = Null Then
      Error.Raise("SSL is NULL value")
      Return
    Endif

    iRet = SSL_set_fd($pSSL, MySocket.Handle)

    ' When <> 1, then something went wrong during set fd
    If iRet = 0 Then
      Try Close #MySocket

      Error.Raise("SSL set_fd failed")
      Return
    Endif

    ' File-Handle assigned, now try to accept the connection
    iRet = SSL_accept($pSSL)

    ' Check return value of SSL_accept
    Select iRet
      Case 0 ' Handshake failed, stop the SSL session
        Try SSL_shutdown($pSSL)
        Try SSL_free($pSSL)
        $pSSL = Null
        Try Close #MySocket

        Try iRet = SSL_get_error($pSSL, iRet)
        Error.Raise("SSL handshake failed RC=" & iRet & " (" & Display_SSL_ERROR(iRet) & ")")
        Return
      Case 1 ' Succesfull
        $bSSLAcceptHandshake = True
      Default ' Error happened, maybe we should retry
        $bSSLAcceptHandshake = False
        Try iRet = SSL_get_error($pSSL, iRet)
        If iRet <> SSL_ERROR_WANT_READ Then 
          ' Something went wrong, just stop the SSL session
          Try SSL_shutdown($pSSL)
          Try SSL_free($pSSL)
          $pSSL = Null
          Try Close #MySocket

          Try iRet = SSL_get_error($pSSL, iRet)
          Error.Raise("SSL handshake failed RC=" & iRet & " (" & Display_SSL_ERROR(iRet) & ")")
          Return
        Endif
    End Select
  Endif

End

'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
' Connect as a client to a server
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Public Sub Connection(Optional sHostOrPath As String, Optional iPort As Integer = 0)

  If sHostOrPath And iPort Then
    MySocket.Connect(sHostOrPath, iPort)
  Else If sHostOrPath Then
    MySocket.Connect(sHostOrPath)
  Else
    MySocket.Connect()
  Endif

End

'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
' Display a readable SSL_ERROR
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Private Sub Display_SSL_ERROR(iRet As Integer) As String

  Select iRet
    Case SSL_ERROR_NONE
    Case SSL_ERROR_SSL
      Return "ERROR_SSL"
    Case SSL_ERROR_WANT_READ
      Return "ERROR_WANT_READ"
    Case SSL_ERROR_WANT_WRITE
      Return "ERROR_WANT_WRITE"
    Case SSL_ERROR_WANT_X509_LOOKUP
      Return "ERROR_WANT_X509_LOOKUP"
    Case SSL_ERROR_SYSCALL
      Return "ERROR_SYSCALL"
    Case SSL_ERROR_ZERO_RETURN
      Return "ERROR_ZERO_RETURN"
    Case SSL_ERROR_WANT_CONNECT
      Return "ERROR_WANT_CONNECT"
    Case SSL_ERROR_WANT_ACCEPT
      Return "ERROR_WANT_ACCEPT"
    Default
      Return "UNKNOWN"
  End Select

End

'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
' Properties
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Function EndOfLine_Read() As Integer

  Return $iEndOfLine

End

Function EndOfLine_Write(iEndOfLine As Integer)

  Select iEndOfLine
    Case gb.Unix
      $iEndOfLine = gb.Unix
    Case gb.Windows
      $iEndOfLine = gb.Windows
    Case gb.Mac
      $iEndOfLine = gb.Mac
    Default
      $iEndOfLine = gb.Unix
  End Select

End

Function TimeOut_Read() As Integer

  Return $iTimeout

End

Function TimeOut_Write(iTimeout As Integer)

  $iTimeout = iTimeout

End

Function Tag_Read() As Variant

  Return MySocket.Tag

End

Function Tag_Write(vTag As Variant)

  MySocket.Tag = vTag

End

Function Host_Read() As String

  Return MySocket.Host

End

Function Host_Write(sHost As String)

  MySocket.Host = sHost

End

Function Port_Read() As Integer

  Return MySocket.Port

End

Function Port_Write(iPort As Integer)

  MySocket.Port = iPort

End

Function Handle_Read() As Integer

  Return MySocket.Handle

End

Function LocalHost_Read() As String

  Return MySocket.LocalHost

End


Function LocalPort_Read() As Integer

  Return MySocket.LocalPort

End

Function RemoteHost_Read() As String

  Return MySocket.RemoteHost

End

Function RemotePort_Read() As Integer

  Return MySocket.RemotePort

End

Function Status_Read() As Integer

  Return MySocket.Status

End

Function Path_Read() As String

  Return MySocket.Path

End

Function Path_Write(sPath As String)

  MySocket.Path = sPath

End

Function Protocol_Read() As Integer

  Return $iProtocol

End

Function Protocol_Write(iProtocol As Integer)

  $iProtocol = iProtocol

End

Function HTTPCode_Read() As Integer

  Return $iHTTPCode

End

Function HTTPCode_Write(iHTTPCode As Integer)

  $iHTTPCode = iHTTPCode

End

Function HTTPSize_Read() As Integer

  Return $iHTTPSize

End

Function HTTPSize_Write(iHTTPSize As Integer)

  $iHTTPSize = iHTTPSize

End

Function HTTPMethods_Read() As String[]

  Return $cHTTPMethods

End

Function HTTPMethods_Write(cHTTPMethods As String[])

  $cHTTPMethods = cHTTPMethods

End

Function HTTPContentTypes_Read() As String[]

  Return $cHTTPContentTypes

End

Function HTTPContentTypes_Write(cHTTPContentTypes As String[])

  $cHTTPContentTypes = cHTTPContentTypes

End

Function HTTPHeaders_Read() As String[]

  Return $cHTTPHeaders

End

Function HTTPHeaders_Write(cHTTPHeaders As String[])

  $cHTTPHeaders = cHTTPHeaders

End

Function HTTPRequestInUrl_Read() As String

  Return $cHTTPHeaders

End

Function HTTPRequestInUrl_Write(sHTTPRequestInUrl As String)

  $sHTTPRequestInUrl = sHTTPRequestInUrl

End

Function HTTPTimeOut_Read() As Integer

  Return $iHTTPTimeOut * 5

End

Function HTTPTimeOut_Write(iHTTPTimeOut As Integer)

  $iHTTPTimeOut = iHTTPTimeOut / 5

End

Function HTTPKeepAlive_Read() As Integer

  Return $iHTTPKeepAlive

End

Function HTTPKeepAlive_Write(iHTTPKeepAlive As Integer)

  $iHTTPKeepAlive = iHTTPKeepAlive

End
