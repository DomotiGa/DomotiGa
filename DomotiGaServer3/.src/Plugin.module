' Gambas module file

' Description:
' Plugin.module
' This module stores all the interface information
'
' Development Status:
' Initial testing build

' Credits:
' Based on an idea of Teun Hagen, coded by Alexander Kuiper

' DomotiGa - an open source home automation program.
' Copyright (C) Ron Klinkien, The Netherlands.

' Read file called COPYING for license details.

' TODO:
' Main, Astro, etc - special settings_* aren't supported YET

'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
' Variables
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Public $bDebug As Boolean

'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
' cPluginList contain all the modules/interfaces available on the system
' Key format is "<pluginname#<instance>". E.g. Key=ups#1
' NOTE: E.g. Key=ups#0 is a special key, this one always exists and 
'       defines that the Module/Class is available
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Public cPluginList As New Collection

'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
' cPluginEnabled contains the shortlist of modules/classes,
' should only be used by FMain.class
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Public cPluginEnabled As New Collection

'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
' cPluginRunTask contains the modules/classes list which 
' have to be called every minute for crontab check. This
' only applies for OpenZWave and DSC.
' NOTE: The module/class will have "PluginRunTask=True"
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Public cPluginRunTask As New Collection

'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
' Constants
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Public Const Type_Unknown As Integer = 0 ' When unitialized
Public Const Type_Module As Integer = 1 ' e.g. Email, NMA
Public Const Type_Class As Integer = 2  ' e.g. UPS, RFXComTRX

'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
' Init - Register all known plugins
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Public Sub Init()

  Register(Type_Class, "Asterisk", "CAsterisk", Null)
  'Register(Type_Module, "Bluetooth", "Bluetooth", Bluetooth)
  'Register(Type_Module, "Bwired", "Bwired", Bwired)
  Register(Type_Class, "CTX35", "CCTX35", Null)
  Register(Type_Class, "CUL", "CCUL", Null)
  Register(Type_Class, "CurrentCost", "CCurrentCost", Null)
  Register(Type_Class, "Denon", "CDenon", Null)
  'Register(Type_Module, "Digitemp", "Digitemp", Digitemp)
  Register(Type_Class, "DMXPlayer", "CDMXPlayer", Null)
  Register(Type_Class, "Domotica", "CDomotica", Null)
  'Register(Type_Class, "DSC", "CDSC", Null)
  Register(Type_Class, "EIB", "CEIB", Null)
  Register(Type_Class, "ELVMAX", "CELVMAX", Null)
  Register(Type_Class, "EZcontrol", "CEZcontrol", Null)
  Register(Type_Class, "FritzBox", "CFritzBox", Null)
  Register(Type_Class, "GenericIO", "CGenericIO", Null)
  Register(Type_Class, "GPS", "CGPS", Null)
  'Register(Type_Module, "HDDTemp", "HDDTemp", HDDTemp)
  Register(Type_Class, "HomeMatic", "CHomeMatic", Null)
  Register(Type_Class, "IPort", "CIPort", Null)
  Register(Type_Class, "IRMan", "CIRMan", Null)
  Register(Type_Class, "IRTrans", "CIRTrans", Null)
  Register(Type_Class, "IViewer", "CIViewer", Null)
  Register(Type_Class, "JeeLabs", "CJeeLabs", Null)
  'Register(Type_Class, "JSONRPC", "CJSONRPC", Null)
  Register(Type_Class, "K8055", "CK8055", Null)
  Register(Type_Class, "KMTronicUDP", "CKMTronicUDP", Null)
  Register(Type_Class, "LEDMatrix", "CLEDMatrix", Null)
  Register(Type_Class, "LGTV", "CLGTV", Null)
  Register(Type_Class, "LIRC", "CLIRC", Null)
  Register(Type_Class, "Meteohub", "CMeteohub", Null)
  Register(Type_Class, "Mochad", "CMochad", Null)
  Register(Type_Class, "MQTT", "CMQTT", Null)
  Register(Type_Class, "Ncid", "CNcid", Null)
  'Register(Type_Module, "NMA", "NMA", NMA)
  Register(Type_Class, "Onkyo", "COnkyo", Null)
  Register(Type_Class, "OpenTherm", "COpenTherm", Null)
  Register(Type_Class, "OWFS", "COWFS", Null)
  Register(Type_Class, "OWW", "COWW", Null)
  'Register(Type_Module, "P2000", "P2000", P2000)
  'Register(Type_Module, "Pachube", "Pachube", Pachube)
  'Register(Type_Module, "Ping", "Ping", Ping)
  Register(Type_Class, "Pioneer", "CPioneer", Null)
  Register(Type_Class, "PLCBUS", "CPLCBUS", Null)
  Register(Type_Class, "Plugwise", "CPlugwise", Null)
  'Register(Type_Module, "Prowl", "Prowl", Prowl)
  'Register(Type_Module, "PVoutput", "PVoutput", PVoutput)
  'Register(Type_Module, "Pushover", "Pushover", Pushover)
  Register(Type_Class, "PwrCtrl", "CPwrCtrl", Null)
  Register(Type_Class, "RaZberry", "CRaZberry", Null)
  'Register(Type_Module, "RRDTool", "RRDTool", RRDTool)
  Register(Type_Class, "RFXComRX", "CRFXComRX", Null)
  Register(Type_Class, "RFXComTRX", "CRFXComTRX", Null)
  Register(Type_Class, "RFXComTX", "CRFXComTX", Null)
  'Register(Type_Class, "RFXComxPL", "CRFXComxPL", Null)
  'Register(Type_Module, "ServerStats", "ServerStats", ServerStats)
  Register(Type_Class, "SharpTV", "CSharpTV", Null)
  'Register(Type_Module, "Shell", "Shell", Shell)
  Register(Type_Class, "SmartMeter", "CSmartMeter", Null)
  'Register(Type_Class, "SmartVISUServer", "CSmartVISUServer", Null)
  'Register(Type_Class, "SMS", "CSMS", Null)
  'Register(Type_Module, "Sounds", "Sounds", Sounds)
  'Register(Type_Class, "SqueezeServer", "CSqueezeServer", Null)
  Register(Type_Class, "TelnetServer", "CTelnetServer", Null)
  Register(Type_Class, "Temp08", "CTemp08", Null)
  'Register(Type_Module, "TemperaturNu", "TemperaturNu", TemperaturNu)
  'Register(Type_Module, "Thermostat", "Thermostat", Thermostat)
  'Register(Type_Module, "TVGuide", "TVGuide", TVGuide)
  'Register(Type_Module, "Twitter", "Twitter", Twitter)
  Register(Type_Class, "UPS", "CUPS", Null)
  'Register(Type_Module, "VideoServer", "VideoServer", VideoServer)
  Register(Type_Class, "VISCA", "CVISCA", Null)
  Register(Type_Class, "Visonic", "CVisonic", Null)
  'Register(Type_Module, "VoiceText", "VoiceText", VoiceText)
  'Register(Type_Module, "WeatherUG", "WeatherUG", WeatherUG)
  Register(Type_Class, "Weeder", "CWeeder", Null)
  'Register(Type_Module, "X10Cmd", "X10Cmd", X10Cmd)
  'Register(Type_Class, "XBMCxPL", "CXBMCxPL", Null)
  'Register(Type_Class, "XMLRPC", "CXMLRPC", Null)
  'Register(Type_Class, "xPL", "CxPL", Null)
  Register(Type_Class, "YouLess", "CYouLess", Null)
  'Register(Type_Class, "ZWave", "CZWave", Null)

End

'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
' Register interfaces/modules
' sType = Module or Class
' sPluginName = Displayname like UPS, Twitter, Visonic
' sClassName = Class name, will loaded during Setup
' oModule = Object reference to *.module
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Public Sub Register(sType As Byte, sPluginName As String, sClassName As String, oModule As Object)

  Dim rResult As Result
  Dim cPl As CPluginEntry
  Dim hField As ResultField
  Dim oTemp As Object
  Dim sTemp As String
  Dim iTemp As Integer
  Dim sTableName As String = "settings_" & LCase(sPluginName)

  ' Only allow module & class
  If sType <> Type_Module And sType <> Type_Class Then
    Main.WriteLog("[Plugin] ERROR: Unknown Module/Class type specific (" & sType & ")")
    Return
  Endif 

  ' Plugin name can't contain a "#" character
  If InStr(LCase(sPluginName), "#") Then
    Main.WriteLog("[Plugin] ERROR: Module/Class '" & sClassName & "' name can't contain a '#' character")
    Return
  Endif

  ' Try to load the module/class first. If it fails, don't continue
  Try Class.Load(sClassName)
  If Error Then
    Main.WriteLog("[Plugin] ERROR: Failed to load Module/Class '" & sClassName & "'")
    Return
  Endif

  ' Check if settings_<sPluginName> exists
  If TableExists(sTableName) = False Then
    Main.WriteLog("[Plugin] ERROR: Table '" & sTableName & "' doesn't exist in the database")
    Return
  Endif

  ' A module is already loaded/initialized. We just symbolic link to the object reference
  ' A module is like a Class, but only 1 instance exists and doesn't have to be created

  ' Assign the Module to the oTemp or create the Class temporary
  ' NOTE: We need to *only* cleanup the class at the end
  Select sType
    Case Type_Module
      oTemp = oModule
    Case Type_Class
      oTemp = Object.New(sClassName)
  End Select

  ' Try to get the PluginName, don't continue if it fails. Most likely an invalid Module/Class
  Try sTemp = oTemp.PluginName
  If Error Then
    Main.WriteLog("Plugin] ERROR: Module/Class '" & sPluginName & "' looks to be invalid, the 'PluginName' is missing")
    Return
  Endif

  ' Try to get the PluginFriendlyName, don't continue if it fails. Most likely an invalid Module/Class
  Try sTemp = oTemp.PluginFriendlyName
  If Error Then
    Main.WriteLog("Plugin] ERROR: Module/Class '" & sPluginName & "' looks to be invalid, the 'PluginFriendlyName' is missing")
    Return
  Endif

  ' Safety check: that Class matches loaded module
  If LCase(sPluginName) <> LCase(oTemp.PluginName) Then
    Main.WriteLog("[Plugin] ERROR: Plugin Mismatch Name='" & sPluginName & "', Module/Class='" & oTemp.PluginName & "'")
    Return
  Endif

  ' Get the first row of the settings_<sPluginName>
  rResult = GetSettingsTable(sTableName, 0)

  If rResult = Null Then
    Main.WriteLog("[Plugin] ERROR: Unable to retrieve data from the table '" & sTableName & "' (id=0)")
    Main.WriteLog("[Plugin] ERROR: Unable to initialize Module/Class '" & sPluginName & "'")
    Return
  Endif

  If rResult.Count = 0 Then
    Main.WriteLog("[Plugin] ERROR: No data retrieved from the table '" & sTableName & "' (id=0)")
    Main.WriteLog("[Plugin] ERROR: Unable to initialize Module/Class '" & sPluginName & "'")
    Return
  Endif

  cPl = New CPluginEntry
  cPl.Type = sType
  cPl.Name = sPluginName
  cPl.KeyName = LCase(sPluginName) & "#0"
  cPl.Instance = 0

  ' Store for modules the *.module in instance #0, this one will always exist
  If sType = Type_Module Then
    cPl.Interface = oModule
  Else
    cPl.Interface = Null
  Endif

  Try cPl.MaxInstances = oTemp.PluginMaxInstances
  If Error Then
    Main.WriteLog("[Plugin] ERROR: Module/Class '" & sPluginName & "' looks to be invalid, the 'PluginMaxInstances' is missing")
    Return
  Endif

  ' Store the ClassName if it is a Type_Class
  If sType = Type_Class Then
    cPl.ClassName = sClassName
  Else
    cPl.ClassName = ""
  Endif

  ' All initialized, put it in the collection
  cPluginList[LCase(sPluginName) & "#0"] = cPl

  ' Now retrieve row=1 for modules and all other rows for classes
  If sType = Type_Module Then
    rResult = GetSettingsTable(sTableName, 1)
  Else
    rResult = GetSettingsTable(sTableName)
  Endif

  If rResult = Null Or rResult.Count = 0 Then
    Return
  Endif

  For Each rResult
    cPl = New CPluginEntry
    cPl.Type = sType
    cPl.Name = sPluginName
    cPl.KeyName = LCase(sPluginName) & "#" & rResult!id
    cPl.Instance = rResult!id
    cPl.MaxInstances = oTemp.PluginMaxInstances

    cPl.Interface = Null

    Select sType
      Case Type_Module
        cPl.ClassName = ""
      Case Type_Class
        cPl.ClassName = sClassName
    End Select

    For Each hField In rResult.Fields
      cPl.Settings[LCase(hField.Name)] = rResult[hField.Name]
    Next

    ' All initialized, put it in the collection
    cPluginList[LCase(sPluginName) & "#" & rResult!id] = cPl
  Next

' Don't crash DomotiGa if we hit an error
Catch
  Main.WriteLog("[Plugin] ERROR: '" & Error.Text & "' while registering Plugin '" & sPluginName & "'")
  
End

'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
' Start All modules/classes in cPluginList
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Public Sub StartAll()

  Dim cPl As CPluginEntry
  Dim cReported As New Collection
  Dim bRunTask As Boolean

  ' Loop through all inteface and start them
  For Each cPl In cPluginList

    ' Skip the #0 entries, these can't be started
    If InStr(cPl.KeyName, "#0") = 0 Then

      ' Also only start enabled modules/classes
      If cPl.Settings["enabled"] Then

        ' Put this plugin in the enabled list
        cPluginEnabled[LCase(cPl.Name)] = "enabled"

        If cPl.Type = Type_Class Then
          cPl.Interface = Object.New(cPl.ClassName)
        Endif

        ' Print module enabled information - only once
        ' We don't do it in the module/class, because that isn't reliable enough
        If cReported.Exist(cPl.Name) = False Then 
          Main.WriteLog("[Plugin] " & cPl.Interface.PluginFriendlyName & " enabled.")
          cReported[cPl.Name] = True
        Endif

        Try Object.Call(cPl.Interface, "StartPlugin", [cPl])
        If Error Then
          Main.WriteLog("[Plugin] ERROR: Module/Class '" & cPl.Name & "' doesn't have a StartPlugin Function. ERROR: '" & Error.Text & "' at " & Error.Where)
        Endif

        ' Check if the PluginRunTask exist, then we need to call it every minute
        Try bRunTask = cPl.Interface.PluginRunTask
        If Not Error Then
          If bRunTask Then
            cPluginRunTask[cPl.KeyName] = "active"
          Endif
        Endif

      Endif
    Endif
  Next

End

'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
' Stop All modules/classes in cPluginList
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Public Sub StopAll()

  Dim cPl As CPluginEntry
  Dim cReported As New Collection

  ' Destroy all objects
  For Each cPl In cPluginList

    ' Skip the #0 entries, these can't be stopped
    If InStr(cPl.KeyName, "#0") = 0 Then
      Try Object.Call(cPl.Interface, "StopPlugin")

      ' If it is a Class type, destroy the object
      If cPl.Type = Type_Class Then
        cPl.Interface = Null
      Endif

      ' Remove possible RunTask
      If cPluginRunTask.Exist(cPl.KeyName) Then
        cPluginRunTask.Remove(cPl.KeyName)
      Endif

    Endif
  Next

End

'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
' Restart Interface & Instance after FSettings
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Public Sub Restart(sPluginName As String, Optional iInstance As Integer = 1)

  Dim rResult As Result
  Dim cPl As CPluginEntry
  Dim cPlNew As CPluginEntry
  Dim hField As ResultField
  Dim bRunTask As Boolean
  Dim sTableName As String = "settings_" & LCase(sPluginName)

  ' First instance *has* to exist
  If cPluginList.Exist(LCase(sPluginName) & "#0") = False Then
    Main.WriteLog("[Plugin] ERROR: Module/Class '" & sPluginName & "' isn't properly initialized")
    Return
  Endif 

  ' Check if settings_<sPluginName> exists
  If TableExists(sTableName) = False Then
    Main.WriteLog("[Plugin] ERROR: Table '" & sTableName & "' doesn't exist in the database")
    Return
  Endif

  rResult = GetSettingsTable(sTableName, iInstance)

  ' Remove possible RunTask
  If cPluginRunTask.Exist(LCase(sPluginName) & "#" & iInstance) Then
    cPluginRunTask.Remove(LCase(sPluginName) & "#" & iInstance)
  Endif

  ' Module/Class exists - if something changed we need to restart
  ' Covers an interface removed or modified
  If cPluginList.Exist(LCase(sPluginName) & "#" & iInstance) Then

    ' Get a local copy
    cPl = cPluginList[LCase(sPluginName) & "#" & iInstance]

    ' Stop the interface/instance
    If cPl.Interface <> Null Then
      Try Object.Call(cPl.Interface, "StopPlugin")
      If Error Then
        Main.WriteLog("[Plugin] ERROR: Module/Class '" & sPluginName & "' doesn't have a StopPlugin Function. ERROR: '" & Error.Text & "' at " & Error.Where)
      Endif
    Endif

    ' Report for enabled ones, that it is disabled now
    If cPl.Settings["enabled"] Then
      Main.WriteLog("[Plugin] " & cPl.Interface.PluginFriendlyName & ", Instance #" & iInstance & " disabled.")
    Endif

    ' If it is a Class type, destroy the object
    If cPl.Type = Type_Class Then
      cPl.Interface = Null
    Endif

    ' Row doesn't exist anymore, stop interface/instance and remove from list
    If rResult = Null Or rResult.Count = 0 Then
      cPluginList.Remove(LCase(sPluginName) & "#" & iInstance)
      Return
    Else

      ' Empty the collection and fill it again
      cPl.Settings.Clear()
      For Each hField In rResult.Fields
        cPl.Settings[LCase(hField.Name)] = rResult[hField.Name]
      Next

      ' If the module is enabled (or still is) start now
      If cPl.Settings["enabled"] Then

        ' If it is Class type, create object first
        If cPl.Type = Type_Class Then
          cPl.Interface = Object.New(cPl.ClassName)
        Endif

        ' Report that it is enabled
        Main.WriteLog("[Plugin] " & cPl.Interface.PluginFriendlyName & ", Instance #" & iInstance & " enabled.")

        Try Object.Call(cPl.Interface, "StartPlugin", [cPl])
        If Error Then
          Main.WriteLog("[Plugin] ERROR: Module/Class '" & sPluginName & "' doesn't have a StartPlugin Function. ERROR: '" & Error.Text & "' at " & Error.Where)
        Endif

        ' Check if the PluginRunTask exist, then we need to call it every minute
        Try bRunTask = cPl.Interface.PluginRunTask
        If Not Error Then
          If bRunTask Then
            cPluginRunTask[LCase(sPluginName) & "#" & iInstance] = "active"
          Endif
        Endif

      Endif

    Endif

  Else

    ' TODO: Interface = Null - this doesn't work nicely for Type=Module

    ' Instance doesn't exist yet, we need to initialize it
    cPl = cPluginList[LCase(sPluginName) & "#0"]

    ' Copy information from instance 0
    cPlNew = New CPluginEntry
    cPlNew.Type = cPl.Type
    cPlNew.Name = cPl.Name
    cPlNew.KeyName = LCase(sPluginName) & "#" & iInstance
    cPlNew.Instance = iInstance
    cPlNew.ClassName = cPl.sClassName
    cPlNew.Interface = Null
    For Each hField In rResult.Fields
      cPlNew.Settings[LCase(hField.Name)] = rResult[hField.Name]
    Next

    cPluginList[LCase(sPluginName) & "#" & iInstance] = cPlNew

    ' If the module is enabled start now
    If cPlNew.Settings["enabled"] Then

      ' If it is Class type, create object first
      If cPlNew.Type = Type_Class Then
        cPlNew.Interface = Object.New(cPl.ClassName)
      Endif

      Try Object.Call(cPlNew.Interface, "StartPlugin", [cPlNew])
      If Error Then
        Main.WriteLog("[Plugin] ERROR: Module/Class '" & sPluginName & "' doesn't have a StartPlugin Function. ERROR: '" & Error.Text & "' at " & Error.Where)
      Endif

      ' Check if the PluginRunTask exist, then we need to call it every minute
      Try bRunTask = cPlNew.Interface.PluginRunTask
      If Not Error Then
        If bRunTask Then
          cPluginRunTask[LCase(sPluginName) & "#" & iInstance] = "active"
        Endif
      Endif

    Endif

  Endif

  ' Update the cPluginEnabled list now
  If cPluginEnabled.Exist(LCase(sPluginName)) Then
    cPluginEnabled.Remove(LCase(sPluginName))
  Endif

  ' Loop through all plugins and tag enabled modules/classes
  For Each cPl In cPluginList
    If LCase(cPl.Name) = LCase(sPluginName) Then
      If cPl.Instance >= 1 Then
        If cPl.Settings["enabled"] Then cPluginEnabled[LCase(sPluginName)] = "enabled"
      Endif
    Endif
  Next

End

'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
' return if plugin is registered
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Public Sub IsPluginRegistered(sPluginName As String, Optional iInstance As Integer = 1) As Boolean

  If cPluginList.Exist(LCase(sPluginName) & "#" & iInstance) Then
    Return True
  Else
    ' If the Instance doesn't exist, check for #0 and error if not existing
    If cPluginList.Exist(LCase(sPluginName) & "#0") = False Then
      Main.WriteLog("[Plugin] ERROR: Module/Class '" & sPluginName & "' isn't properly initialized")
    Endif

    Return False
  Endif

End 

'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
' Return True if plugin is enabled
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Public Sub IsPluginEnabled(sPluginName As String, Optional iInstance As Integer = 1) As Boolean

  Dim bEnabled As Boolean

  If iInstance = 0 Then
    Return cPluginEnabled.Exist(LCase(sPluginName))
  Else

    ' First check if the Plugin & Instance do exist in our Plugin list
    If IsPluginRegistered(sPluginName, iInstance) Then

      ' First check if the module/interface is enabled
      Try bEnabled = GetPluginObject(sPluginName, iInstance).Settings["enabled"]

      ' Check for errors, it is possible the Object doesn't have a valid "Settings[enabled]" (faulty module/interface)
      If Error Then
        Main.WriteLog("[Plugin] ERROR: Module/Class '" & sPluginName & "' looks to be invalid, the 'Settings[enabled]' is missing")
        bEnabled = False
      Endif
    Else
      bEnabled = False
    Endif
  Endif

  Return bEnabled

End

'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
' return if plugin is enabled and running
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Public Sub IsPluginRunning(sPluginName As String, Optional iInstance As Byte = 1) As Boolean

  Dim bRunning As Boolean

  ' First check if the Plugin & Instance do exist in our Plugin list
  If IsPluginRegistered(sPluginName, iInstance) Then

    ' First check/try IsRunning variable
    Try bRunning = GetPluginObject(sPluginName, iInstance).Interface.IsRunning

    ' Check for errors, it is possible the Object doesn't have an "IsRunning" (faulty module/interface)
    If Error Then
      Main.WriteLog("[Plugin] ERROR: Module/Class '" & sPluginName & "' looks to be invalid, the 'IsRunning' is missing")
      bRunning = False
    Endif
  Else
    bRunning = False
  Endif

  Return bRunning

End 

'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
' Pointer to the Object ... Don't modify data !
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Public Sub GetPluginObject(sPluginName As String, Optional iInstance As Byte = 1) As Object

  If cPluginList.Exist(LCase(sPluginName) & "#" & iInstance) Then
    Try Return cPluginList[LCase(sPluginName) & "#" & iInstance]
  Else
    Return Null
  Endif
End 

'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
' Send command to plugin. The "SendCommand" routine is a
' fixed name, but doesn't have to exist
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Public Sub SendCommand(sPluginName As String, iInstance As Byte, sAddress As String, sCmd As String) As Boolean

  ' The Plugin needs to be enabled
  If isPluginEnabled(sPluginName, iInstance) Then

    ' The Plugin needs to be in IsRunning state
    If isPluginRunning(sPluginName, iInstance) Then

      ' Send the command to the right interface/instance
      Try GetPluginObject(sPluginName, iInstance).Interface.SendCommand(sAddress, sCmd)

      ' Throw an error, because we are sending a SendCommand to a plugin without the routine
      If Not Error Then
        Return True
      Else
        Main.WriteDebugLog("[Plugin] Module/Class '" & sPluginName & "' doesn't have a 'SendCommand' function, most likely you are trying to control a ReadOnly interface")
        Return False
      Endif
    Else
      Main.WriteLog("[Plugin] ERROR: Can't control device because '" & sPluginName & "' is error state!")
      Return False 
    Endif

  Else
    Main.WriteDebugLog("[Plugin] Can't control device because '" & sPluginName & "' is disabled!")
    Return False 
  Endif
End

'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
' Check if settings_* table exists in the database
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Public Sub TableExists(sTableName As String) As Boolean

  Dim rResult As Result

  If Not sTableName Then Return False
  sTableName = LCase(sTableName)

  ' START: Temporary hack - need to be fixed
  If sTableName = "settings_smartmeter" Then sTableName = "settings_nta8130"
  ' END: Temporary hack - need to be fixed

  Try rResult = Main.hDB.Exec("SHOW TABLES")
  If Error Or rResult = Null Then
    Main.WriteLog("[Plugin] ERROR: Can't retrieve table list from the database")
    Return False
  Endif

  If rResult.Count Then
    For Each rResult
      If rResult["Tables_in_" & Main.sSQLDatabase] = sTableName Then Return True
    Next
  Endif

  Return False

End

'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
' Get the configuration from the settings table
' If iRow = -1 give all the rows back (except row=0, this is default)
' If iRow >= 0 give only the requested row back
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Public Sub GetSettingsTable(sTableName As String, Optional iRow As Integer = -1) As Result

  sTableName = LCase(sTableName)

  ' START: Temporary hack - need to be fixed
  If sTableName = "settings_smartmeter" Then sTableName = "settings_nta8130"
  ' END: Temporary hack - need to be fixed

  If iRow >= 0 Then
    Try Return Main.hDB.Exec("SELECT * FROM " & sTableName & " WHERE id = &1", iRow)
  Else
    Try Return Main.hDB.Exec("SELECT * FROM " & sTableName & " WHERE id >= 1 ORDER BY id")
  Endif

End

'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
' The RunTask will be called every minute by EventLoop
' In registered, it should only do crontab alike checks
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Public Sub RunTask()

  Dim vValue As Variant

  ' Go through the whole list, and try to start RunTask
  For Each vValue In cPluginRunTask
    If cPluginList.Exist(cPluginRunTask.Key) Then
      Try Object.Call(cPluginList[cPluginRunTask.Key].Interface, "RunTask")

      If Error Then
        Main.WriteLog("[Plugin] ERROR: Module/Class '" & cPluginRunTask.Key & "' doesn't have a RunTask Function, but it has the 'PluginRunTask=True'. ERROR: '" & Error.Text & "' at " & Error.Where)

        ' Remove the entry, because it isn't usefull to run it in the next minute
        ' NOTE: After a restart it will show up again, this is per design
        cPluginRunTask.Remove(cPluginRunTask.Key)
      Endif
    Endif
  Next

End

