' Gambas class file

' Description:
' SmartMeter.class
' Provide support for parsing the output of a NTA8130 compatible smart meter.

' Development Status:
' DSMR 2.X unstable / not tested
' DSMR 2.2+ stable
' DSMR 3.0 stable
' DSMR 4.0 stable

' Links:
' http://www.domoticaforum.eu/viewtopic.php?f=16&t=6104

' DomotiGa - an open source home automation program.
' Copyright (C) Ron Klinkien, The Netherlands.

' Read file called COPYING for license details.

'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
' Module/Class specific variables
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Public PluginName As String = "SmartMeter"
Public PluginFriendlyName As String = "SmartMeter"
Public PluginVersion As String = "2.00"
Public PluginAuthor As String = "Ron Klinkien, Jesse Kerkhoven"
Public PluginProtocols As String[]
Public PluginMaxInstances As Integer = 1

Public KeyName As String
Public LogLabel As String = "[SmartMeter] "
Public InterfaceId As Integer
Public Instance As Integer
Public IsRunning As Boolean
Public ErrorText As String
Public ErrorWhere As String

'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
' Private Variables
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Private $bEnabled As Boolean
Private $sTCPHost As String
Private $iTCPPort As Integer
Private $sInterface As String
Private $sSerPort As String
Private $sBaud As String
Private $iDatabits As Integer
Private $iStopbits As Integer
Private $iParity As Integer
Private $bDebug As Boolean

' Interface objects
Public hMySocket As CSocket
Public hMySerial As CSerialPort

Private $sMsgData As String

'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
' Mandatory subroutine for each Module/Class to initialize:
' - The cPlugin[x].Settings are copied into local variables
' - Port/Connection will be started (any errors caught)
' - Any other code per Class
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Public Sub StartPlugin(cPl As CPluginEntry)

  KeyName = cPl.KeyName
  Instance = cPl.Instance
  If Instance <> 1 Then LogLabel = Replace(LogLabel, "] ", "#" & Instance & "] ")

  ' Copy configuration items locally
  $bEnabled = cPl.Settings["enabled"]
  $sTCPHost = cPl.Settings["tcphost"]
  $iTCPPort = cPl.Settings["tcpport"]
  $sInterface = cPl.Settings["type"]
  $sSerPort = cPl.Settings["serialport"]
  $sBaud = cPl.Settings["baudrate"]
  $iDatabits = cPl.Settings["databits"]
  $iStopbits = cPl.Settings["stopbits"]
  $iParity = cPl.Settings["parity"]
  $bDebug = cPl.Settings["debug"]

  InterfaceId = Devices.FindInterface("SmartMeter Interface")
  If InterfaceId = 0 Then
    ErrorText = "Required InterfaceId can't be retrieved from the database!"
    WriteLog("ERROR: " & ErrorText)
    IsRunning = False
    Return
  Endif

  ' Connect/Initialize connection
  If InStr($sInterface, "tcp") Then
    ConnectTCP()
  Else
    ConnectSerial()
  Endif

  ' load test data if found
  If $bDebug Then
    Try ProcessReceivedPacket(File.Load(Main.sBaseDir & "/debug/smartmeter.log"))
  Endif

End

'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
' Mandatory sub for each Module/Class to stop
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Public Sub StopPlugin()

  Try Disconnect()

End

'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
' Easy helper for WriteLog
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Private Sub WriteLog(sLog As String)

  Main.WriteLog(LogLabel & sLog)
  If $bDebug Then Main.WriteDebugLog(LogLabel & sLog)

End

'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
' Easy helper for WriteDebugLog
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Private Sub WriteDebugLog(sLog As String)

  If $bDebug Then Main.WriteDebugLog(LogLabel & sLog)

End

'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
' connect to the host:port
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Private Sub ConnectTCP() As Boolean

  Dim iReconnectRetry As Integer = 0

  ' try to close the connection
  Try hMySocket.Close
  Try iReconnectRetry = hMySocket.ReconnectRetry

  ' get a new one - but also pass on our previous reconnect counter
  hMySocket = New CSocket(iReconnectRetry) As "MySocket"

  hMySocket.DataType = &HFF + gb.Byte
  hMySocket.Connect($sTCPHost, $iTCPPort)

  ' Write to main logfile we are trying to connect
  WriteLog(PluginFriendlyName & " TCP interface connecting to " & $sTCPHost & ":" & $iTCPPort)

  ' Don't set IsRunning=True, this has to be done in _Ready 

  ' All went ok
  Return True

Catch ' some errors
  WriteLog("ERROR: " & PluginFriendlyName & " TCP interface FAILED to connect to " & $sTCPHost & ":" & $iTCPPort)
  WriteLog("ERROR: " & Error.Text)
  IsRunning = False
  ErrorText = Error.Text
  ErrorWhere = Error.Where

  Return False

End

'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
' connect to the serial port
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Private Sub ConnectSerial() As Boolean

  Dim iReconnectRetry As Integer = 0

  ' try to close the port
  Try hMySerial.Close
  Try iReconnectRetry = hMySerial.ReconnectRetry

  ' get a new one
  hMySerial = New CSerialPort(iReconnectRetry) As "MySerial"

  With hMySerial
    .DataType = &HFF + gb.Byte
    .PortName = $sSerPort
    .Speed = $sBaud
    .Parity = $iParity
    .DataBits = $iDatabits
    .StopBits = $iStopbits
    .FlowControl = 0
    .Open()
  End With

  ' Write to main logfile we connected successfully
  WriteLog(PluginFriendlyName & " serial interface connected to port " & $sSerPort)
  IsRunning = True

  ' Initialize variables
  Run()

  ' All went ok
  Return True

Catch ' some errors
  WriteLog("ERROR: " & PluginFriendlyName & " serial interface FAILED to connect to port " & $sSerPort)
  WriteLog("ERROR: " & Error.Text)
  IsRunning = False
  ErrorText = Error.Text
  ErrorWhere = Error.Where

  Return False

End

'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
' disconnect from the host
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Private Sub Disconnect() As Boolean

  ' try to close the connection
  Try hMySocket.Close
  Try hMySerial.Close

  ' try stop running timers
  StopTimers()

  WriteLog(PluginFriendlyName & IIf($sInterface = "tcp", " TCP connection closed.", " Port closed."))
  
  ' all ok
  Return True

Finally
  IsRunning = False
  ErrorText = ""
  ErrorWhere = ""

Catch
  WriteLog("ERROR: '" & Error.Text & "' at '" & Error.Where & "'")
  Return False

End

'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
'
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Private Sub StopTimers()

End

'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
' Run after succesfull connect
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Private Sub Run()

  ' Empty internal buffer
  $sMsgData = ""

End

'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
' peer closed tcp socket
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Public Sub MySocket_Closed()

  WriteLog("ERROR: TCP socket closed by peer.")
  StopTimers()

  IsRunning = False
  ErrorText = "TCP socket closed by peer"

End

'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
' error while connected/connecting to tcp host
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Public Sub MySocket_Error(sMsg As String)

  WriteLog("ERROR: " & sMsg)

  IsRunning = False
  ErrorText = sMsg

End

'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
' host ip address found
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Public Sub MySocket_Found()

  Log.Plugin_DNS_Found(LogLabel, $sTCPHost)

End

'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
' tcp socket is connected
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Public Sub MySocket_Ready()

  WriteLog("TCP interface connected.")
  IsRunning = True

  Run()

End

'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
' Called when we should reconnect to the tcp host
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Public Sub MySocket_Reconnect()

  ConnectTCP()

End

'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
' received data from the tcp port. vVar is gb.String
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Public Sub MySocket_Read(vVar As Variant)

  Dim bData As Byte

  If vVar Then
    For Each bData In vVar
      ProcessReceivedChar(bData)
    Next
  Endif

End

'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
' Handle errors
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Public Sub MySerial_Error(sMsg As String)

  WriteLog("ERROR: " & sMsg)

End

'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
' read data char for char
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Public Sub MySerial_Read(vVar As Variant)

  Dim bData As Byte

  If vVar Then
    For Each bData In vVar
      ProcessReceivedChar(bData)
    Next
  Endif

End

'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
' Handle reconnect(s)
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Public Sub MySerial_Reconnect()

  ' ReConnect/Initialize connection
  ConnectSerial()

End

'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
'
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Private Sub ProcessReceivedChar(bTemp As Byte)

  $sMsgData &= Chr(bTemp)

  If bTemp = 33 Then ' Buffer until end of record, which is a '!' character
    ProcessReceivedPacket($sMsgData)
    $sMsgData = ""
  Endif

End

'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
' parse P1 telegram
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Private Sub ProcessReceivedPacket(sTelegram As String)

  Dim aTelegram, aRecord, aReading, aGasRecord As String[]
  Dim aMBusId, aMBusType, aMBusReading, aMBusUnit, aMBusValve, aMBusTime As New String[4]
  Dim sLine, sSupplier, sEquipmentIdPower, sReadingPowerNormalUnit, sReadingPowerLowUnit, sReadingPowerGenNormalUnit, sReadingPowerGenLowUnit, sCurrentPowerUsageUnit, sCurrentPowerGenUnit, sPowerThresholdUnit As String
  Dim sMsgCode, sMsgText, sCurrentTariff, sValve As String
  Dim fReadingPowerNormal, fReadingPowerLow, fReadingPowerGenNormal, fReadingPowerGenLow, fCurrentPowerUsage, fCurrentPowerGen, fPowerThreshold As Float
  Dim iCurrentTariff, iSwitchPos, iChannel, iType, iDeviceId As Integer

  ' Dump whole telegram message for debugging purpose
  If $bDebug Then WriteDebugLog("< " & sTelegram)

  aTelegram = Split(sTelegram, "\r\n")
  For Each sLine In aTelegram
    If sLine = "" Then Continue
    If $bDebug Then WriteDebugLog("< " & sLine)
    Select Case Left(sLine, 1)
      Case "/" ' header
        If $bDebug Then WriteDebugLog("Received start of P1 data telegram.")
        ' decode meter supplier
        Select Case Mid(sLine, 2, 3)
          Case "KMP"
            sSupplier = "Kamstrup"
          Case "ISk"
            sSupplier = "IskraEmeco"
          Case "XMX"
            sSupplier = "Landis+Gyr"
          Case "KFM"
            sSupplier = "Kaifa"
          Case Else
            sSupplier = "Unknown (" & Mid(sLine, 2, 3) & ")"
        End Select
        If $bDebug Then
          WriteDebugLog("Meter supplier is '" & sSupplier & "'")
          WriteDebugLog("Meter information '" & sLine & "'")
        Endif
      Case "!" ' end of datagram
        If $bDebug Then WriteDebugLog("Received end of P1 data telegram.")
      Case Else ' data
        aRecord = Scan(sLine, "*:*(*)*")
        If aRecord.Count = 4 Then
          Select Case aRecord[1]
            Case "96.1.1" ' identifier
              sEquipmentIdPower = DecodeSerial(aRecord[2])
              If $bDebug Then WriteDebugLog("Equipment identifier (Power) is '" & sEquipmentIdPower & "'")
            Case "1.8.2" ' meter reading normal tariff
              aReading = ParseReading(aRecord[2])
              If aReading.Count = 2 Then
                fReadingPowerNormal = CFloat(aReading[0])
                sReadingPowerNormalUnit = aReading[1]
              Endif
              If $bDebug Then WriteDebugLog("Meter reading power usage (T2/Normal tariff) is " & fReadingPowerNormal & " " & sReadingPowerNormalUnit)
            Case "1.8.1" ' meter reading low tariff
              aReading = ParseReading(aRecord[2])
              If aReading.Count = 2 Then
                fReadingPowerLow = CFloat(aReading[0])
                sReadingPowerLowUnit = aReading[1]
              Endif
              If $bDebug Then WriteDebugLog("Meter reading power usage (T1/Low tariff) is " & fReadingPowerLow & " " & sReadingPowerLowUnit)
            Case "2.8.2" ' meter reading delivered to net normal tariff
              aReading = ParseReading(aRecord[2])
              If aReading.Count = 2 Then
                fReadingPowerGenNormal = CFloat(aReading[0])
                sReadingPowerGenNormalUnit = aReading[1]
              Endif
              If $bDebug Then WriteDebugLog("Meter reading power generated (T2/Normal tariff) is " & fReadingPowerGenNormal & " " & sReadingPowerGenNormalUnit)
            Case "2.8.1" ' meter reading delivered to net low tariff
              aReading = ParseReading(aRecord[2])
              If aReading.Count = 2 Then
                fReadingPowerGenLow = CFloat(aReading[0])
                sReadingPowerGenLowUnit = aReading[1]
              Endif
              If $bDebug Then WriteDebugLog("Meter reading power generated (T1/Low tariff) is " & fReadingPowerGenLow & " " & sReadingPowerGenLowUnit)
            Case "96.14.0"
              iCurrentTariff = CInt(aRecord[2])
              sCurrentTariff = IIf(iCurrentTariff = 1, "Low", "Normal")
              If $bDebug Then WriteDebugLog("Current tariff is T" & iCurrentTariff & " " & sCurrentTariff)
            Case "1.7.0" ' current power usage
              aReading = ParseReading(aRecord[2])
              If aReading.Count = 2 Then
                fCurrentPowerUsage = CFloat(aReading[0])
                sCurrentPowerUsageUnit = aReading[1]
              Endif
              If $bDebug Then WriteDebugLog("Current power usage (+P) is " & fCurrentPowerUsage & " " & sCurrentPowerUsageUnit)
            Case "2.7.0" ' current power generated
              aReading = ParseReading(aRecord[2])
              If aReading.Count = 2 Then
                fCurrentPowerGen = CFloat(aReading[0])
                sCurrentPowerGenUnit = aReading[1]
              Endif
              If $bDebug Then WriteDebugLog("Current power generated (-P) is " & fCurrentPowerGen & " " & sCurrentPowerGenUnit)
            Case "17.0.0" ' power threshold
              aReading = ParseReading(aRecord[2])
              If aReading.Count = 2 Then
                fPowerThreshold = CFloat(aReading[0])
                sPowerThresholdUnit = aReading[1]
              Endif
              If $bDebug Then WriteDebugLog("Electricity threshold is " & fPowerThreshold & " " & sPowerThresholdUnit)
            Case "96.3.10" ' in/out/enabled
              iSwitchPos = CInt(aRecord[2])
              If $bDebug Then WriteDebugLog("Electricity switch position is " & iSwitchPos)
            Case "96.13.1" ' message
              sMsgCode = aRecord[2]
              If $bDebug Then WriteDebugLog("Message Code is '" & sMsgCode & "'")
            Case "96.13.0" ' message text
              sMsgText = aRecord[2]
              If $bDebug Then WriteDebugLog("Message Text is '" & sMsgText & "'")
            ' optional MBus connected meters (channel 1-4)
            Case "96.1.0" ' channel identifiers
              If aRecord[0] <> "0-0" Then
                iChannel = CInt(Right(aRecord[0]))
                aMBusId[iChannel - 1] = DecodeSerial(aRecord[2])
              Endif
            Case "24.1.0" ' device type
              iChannel = CInt(Right(aRecord[0]))
              iType = CInt(aRecord[2])
              Select Case iType
                Case 3
                  aMBusType[iChannel - 1] = "Gas"
                Case 5
                  aMBusType[iChannel - 1] = "Heat"
                Case 6
                  aMBusType[iChannel - 1] = "Cooling"
                Case 8
                  aMBusType[iChannel - 1] = "Cold Water"
                Case 9
                  aMBusType[iChannel - 1] = "Warm Water"
              End Select
            Case "24.2.1" ' gas for dsmr 4
              iChannel = CInt(Right(aRecord[0]))
              aMBusTime[iChannel - 1] = "20" & Left(aRecord[2], 2) & "-" & Mid(aRecord[2], 3, 2) & "-" & Mid(aRecord[2], 5, 2) & " " & Mid(aRecord[2], 7, 2) & ":" & Mid(aRecord[2], 9, 2) & ":" & Mid(aRecord[2], 11, 2)
              aRecord[3] = Scan(aRecord[3], "*(*)*")[1] ' remove () from data
              aGasRecord = ParseReading(aRecord[3])
              If aGasRecord.Count = 2 Then
                aMBusReading[iChannel - 1] = CFloat(aGasRecord[0])
                aMBusUnit[iChannel - 1] = aGasRecord[1]
                If $bDebug Then
                  WriteDebugLog("Companion 4 record layout found.")
                  WriteDebugLog("MBus Meter on Channel #" & iChannel & ":")
                  WriteDebugLog("Reading : " & aMBusReading[iChannel - 1] & " " & aMBusUnit[iChannel - 1])
                  WriteDebugLog("Timestamp : " & aMBusTime[iChannel - 1])
                Endif
              Endif
            Case "24.3.0" ' gas for dsmr 2.2+ and 3 
              iChannel = CInt(Right(aRecord[0]))
              aMBusTime[iChannel - 1] = "20" & Left(aRecord[2], 2) & "-" & Mid(aRecord[2], 3, 2) & "-" & Mid(aRecord[2], 5, 2) & " " & Mid(aRecord[2], 7, 2) & ":" & Mid(aRecord[2], 9, 2) & ":" & Mid(aRecord[2], 11, 2)
              aGasRecord = Scan(aRecord[3], "(*)(*)(*)(*)(*)(*)")
              If aGasRecord.Count = 6 Then ' Companion layout
                aMBusReading[iChannel - 1] = CFloat(aGasRecord[5])
                aMBusUnit[iChannel - 1] = aGasRecord[4]
                If $bDebug Then
                  WriteDebugLog("Companion 2.2+ or 3 record layout found.")
                  WriteDebugLog("MBus Meter on Channel #" & iChannel & ":")
                  WriteDebugLog("Reading : " & aMBusReading[iChannel - 1] & " " & aMBusUnit[iChannel - 1])
                  WriteDebugLog("Timestamp : " & aMBusTime[iChannel - 1])
                Endif
              Else ' Kamstrup/Iskraemeco layout
                aGasRecord = Scan(aRecord[3], "*(*)(*)(*)(*)(*)")
                If aGasRecord.Count = 6 Then ' Kamstrup layout
                  aMBusUnit[iChannel - 1] = aGasRecord[5]
                Endif
                If $bDebug Then
                  WriteDebugLog("Kamstrup/Iskraemeco 2.2+ or 3 record layout found.")
                  WriteDebugLog("MBus Meter on Channel #" & iChannel & ":")
                  WriteDebugLog("Reading available on separate line.")
                  WriteDebugLog("Timestamp : " & aMBusTime[iChannel - 1])
                Endif
                ' data is on next line parse it later
              Endif
            Case "24.4.0" ' valve position
              iChannel = CInt(Right(aRecord[0]))
              Select Case CInt(aRecord[2])
                Case 1
                  sValve = "Open"
                Case 2
                  sValve = "Closed"
                Case 3
                  sValve = "Released"
                Case Else
                  sValve = "Unknown"
              End Select
              aMBusValve[iChannel - 1] = sValve
            Case Else
              If $bDebug Then WriteDebugLog("to decode : " & aRecord[1])
          End Select
        Endif
        aRecord = Scan(sLine, "(*)") ' possible mbus meter value on seperate line
        If aRecord.Count = 1 Then
          aMBusReading[iChannel - 1] = CFloat(aRecord[0])
        Endif
    End Select
  Next
  ' walk through mbus channelsIF $bDebug THEN
  If $bDebug Then WriteDebugLog("Listing MBus Meters found:")
  For iChannel = 1 To 4
    If Len(aMBusReading[iChannel - 1]) Then
      If $bDebug Then
        WriteDebugLog("MBus Meter on Channel #" & iChannel & ":")
        WriteDebugLog("Id : " & aMBusId[iChannel - 1])
        WriteDebugLog("Type : " & aMBusType[iChannel - 1])
        WriteDebugLog("Reading : " & aMBusReading[iChannel - 1] & " " & aMBusUnit[iChannel - 1])
        WriteDebugLog("Timestamp : " & aMBusTime[iChannel - 1])
        WriteDebugLog("Valve Pos. : " & aMBusValve[iChannel - 1])
      Endif
      ' optional mbus meters
      iDeviceId = Devices.Find(Instance, "P1-MBus" & iChannel, InterfaceId, "P1-GASUSAGE")
      ' update value
      If iDeviceId Then 
        Devices.ValueUpdate(iDeviceId, 1, aMBusReading[iChannel - 1])
        Devices.ValueUpdate(iDeviceId, 2, aMBusValve[iChannel - 1])
        Devices.ValueUpdate(iDeviceId, 3, aMBusType[iChannel - 1])
        Devices.ValueUpdate(iDeviceId, 4, aMBusTime[iChannel - 1])
      Endif
    Endif
  Next
  ' power usage
  iDeviceId = Devices.Find(Instance, "P1-PowerUsed", InterfaceId, "P1-POWERUSAGE")
  If iDeviceId Then
    Devices.ValueUpdate(iDeviceId, 1, CStr(fCurrentPowerUsage))
    Devices.ValueUpdate(iDeviceId, 2, CStr(fReadingPowerLow))
    Devices.ValueUpdate(iDeviceId, 3, CStr(fReadingPowerNormal))
    Devices.ValueUpdate(iDeviceId, 4, sCurrentTariff)
  Endif
  ' power generated
  iDeviceId = Devices.Find(Instance, "P1-PowerDelivered", InterfaceId, "P1-POWERDELIVER")
  If iDeviceId Then
    Devices.ValueUpdate(iDeviceId, 1, CStr(fCurrentPowerGen))
    Devices.ValueUpdate(iDeviceId, 2, CStr(fReadingPowerGenLow))
    Devices.ValueUpdate(iDeviceId, 3, CStr(fReadingPowerGenNormal))
    Devices.ValueUpdate(iDeviceId, 4, sCurrentTariff)
  Endif

Catch ' some errors
  WriteDebugLog("ERROR: while parsing telegram " & Error.Text & " at " & Error.Where)
  WriteDebugLog("Current line was '" & sLine & "'")

End

Private Sub ParseReading(sReading As String) As String[]

  Return Split(sReading, "*")

End

Private Sub DecodeSerial(sData As String) As String

  Dim iCnt As Integer
  Dim sSerial As String

  For iCnt = 1 To Len(sData) Step 2
    sSerial &= Chr(Val("&H" & Mid(sData, iCnt, 2)))
  Next
  Return sSerial

End

