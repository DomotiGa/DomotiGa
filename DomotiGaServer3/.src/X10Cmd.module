' Gambas module file

' Description:
' X10Cmd.module
' Use Heyu or other command to control X10 devices.

' Development Status:
' Writing is working, maybe better error checking is needed.

' DomotiGa - an open source home automation program.
' Copyright(C) 2008-2011 Ron Klinkien.

' Reading device status written by Renaud.

' Read file called COPYING for license details.

PRIVATE sOutput AS String
PRIVATE sMonitorBuffer AS String
PRIVATE pMonitor AS Process
PRIVATE cQueue AS NEW Collection  ' command buffer
PRIVATE bX10CmdBusy AS Boolean  ' waiting for command to finish

'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
' send a command with heyu or other command
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
PUBLIC SUB SendCommand(sDevice AS String, sValue AS String)

  DIM sCommand AS String

  SELECT CASE LCase(sValue)
    CASE "on", "off"
      SELECT Main.iX10Cmdtype
        CASE 0 ' heyu
          sCommand = Main.sX10CmdCommand & " " & LCase(sValue) & " " & sDevice
        CASE 1 ' cm15ademo
          sCommand = Main.sX10CmdCommand & " " & LCase(sDevice) & " " & LCase(sValue)
      END SELECT
      QueueCommand(sCommand)
   CASE ELSE
      Main.WriteDebugLog(("[X10Cmd] Unsupported command '") & sValue & "'")
  END SELECT

END

'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
' add command to queue
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
PUBLIC SUB QueueCommand(sCmd AS String)

  ' add command to queue
  cQueue.Add(sCmd, Rnd)

  ' if interface is not busy process it
  IF bX10CmdBusy = FALSE THEN DoQueue()

END

'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
' process items in queue
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
PUBLIC SUB DoQueue()

  DIM sCmd AS String

  FOR EACH sCmd IN cQueue
    RunCommand(sCmd, cQueue.Key)
    BREAK ' only do first one
  NEXT

END

'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
' run command
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
PUBLIC SUB RunCommand(sCmd AS String, sKey AS String)

  SHELL sCmd & " 2>&1" FOR READ AS "X10Cmd"
  IF Main.bX10CmdDebug THEN Main.WriteDebugLog(("[X10Cmd] Run: ") & sCmd)
  ' remove command from queue
  cQueue.Remove(sKey)
  IF bX10CmdBusy = FALSE THEN bX10CmdBusy = TRUE

END

'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
' got output, save it
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
PUBLIC SUB X10Cmd_Read()

  DIM sLine AS String

  READ #LAST, sLine, -256
  sOutput &= sLine

END

'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
' command has finished, process it's output
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
PUBLIC SUB X10Cmd_Kill()

  IF Main.bX10CmdDebug THEN Main.WriteDebugLog(("[X10Cmd] Result: ") & sOutput)
  sOutput = NULL

  bX10CmdBusy = FALSE
  IF cQueue.Count THEN ' if there are more commands left in queue, send next one
    IF Main.bX10CmdDebug THEN Main.WriteDebugLog(("[X10Cmd] Sending next command from Queue (count = " & cQueue.Count & ")"))
    DoQueue()
  ENDIF

END

'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
' start heyu monitor
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
PUBLIC SUB Monitor()

  pMonitor = EXEC [Main.sX10CmdCommand, "monitor"] FOR READ AS "X10CmdMonitor"

END

'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
' read monitor output
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
PUBLIC SUB X10CmdMonitor_Read()

  DIM sLine AS String

  TRY READ #LAST, sLine, -256
  IF ERROR THEN Main.WriteDebugLog(("[X10Cmd] Error reading data from Heyu monitor output-> ") & Error.Text)
  IF Len(sLine) > 0 THEN
    sMonitorBuffer &= sLine
    IF InStr(sMonitorBuffer, "func") > 0 THEN
      ParseMonitorMessage(sMonitorBuffer)
      sMonitorBuffer = NULL
    ENDIF
  ENDIF

END

'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
' parse monitor output
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
PRIVATE SUB ParseMonitorMessage(sMessage AS String)

  DIM iDeviceId AS Integer
  DIM aFirstLine, aSecondLine AS String[]
  DIM sAddress, sOrder AS String

  IF Main.bX10CmdDebug THEN Main.WriteDebugLog(("[X10Cmd] Monitor get: ") & sMessage)

  ' Message sample :
  ' 1 line : 09/19 18:44:53  rcvi addr unit       4 : hu I4  (_no_alias_)
  ' 2 line : 09/19 18:44:53  rcvi func          Off : hc I

  aFirstLine = Scan(sMessage, "*addr unit* : hu*(*")
  aSecondLine = Scan(sMessage, "*func*: hc*")

  IF aFirstLine.Count = 4 AND aSecondLine.Count = 3 THEN
    sAddress = Trim(aFirstLine[2])

    IF Len(sAddress) = 2 THEN
      sAddress = Left(sAddress, 1) & "0" & Right(sAddress, 1)
    ENDIF
    sOrder = Trim(aSecondLine[1])

    IF Main.bX10CmdGlobalX10 THEN
      iDeviceId = Devices.FindAll(sAddress, 9999, "X10")
    ELSE
      iDeviceId = Devices.Find(sAddress, Devices.FindInterface("X10Cmd Interface"), "X10")
    ENDIF

    ' if found then update it's value
    IF iDeviceId THEN Devices.ValueUpdate(iDeviceId, sOrder, "", "", "")
  ENDIF

END

'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
' stop monitor
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
PUBLIC SUB Monitor_Stop()

  pMonitor.Kill

END
