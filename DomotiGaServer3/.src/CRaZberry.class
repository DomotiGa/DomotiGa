' Gambas class file

' Description:
' CRaZberry.class
' Provide support for RaZberry Z-Wave interface.
'
' Supported CommandClasses:
' - Switch Binary (37)
' - Switch Multilevel (38)
' - Sensor Binary (48)
' - Sensor Multilevel (49)
' - Meter (50)
' - SetPoint (67)
' - Battery (128)
' - Sensor Alarm (156)

' Development Status:
' Working

' DomotiGa - an open source home automation program.
' Copyright (C) Ron Klinkien, The Netherlands.

' Read file called COPYING for license details.

'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
' Module/Class specific variables
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Public PluginName As String = "RaZberry"
Public PluginFriendlyName As String = "RaZberry Z-Wave"
Public PluginVersion As String = "1.10"
Public PluginAuthor As String = "Ron Klinkien"
Public PluginProtocols As String[]
Public PluginMaxInstances As Integer = 1

Public KeyName As String
Public LogLabel As String = "[RaZberry] "
Public InterfaceId As Integer
Public Instance As Integer
Public IsRunning As Boolean
Public ErrorText As String
Public ErrorWhere As String

'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
' Private Variables
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Private $bEnabled As Boolean
Private $sTCPHost As String
Private $iTCPPort As Integer
Private $sUsername As String
Private $sPassword As String
Private $iPollTime As Integer
Private $bDebug As Boolean

' RaZberry controller and network information
Private $cZWaveNetwork As New JSONCollection

Public hRaZberryInit As HttpClient
Public hRaZberryCmd As HttpClient
Public bInit As Boolean
Public $iUpdateTime As Integer
Public $iNewUpdateTime As Integer
Public sBuffer As String
Public tRaZberry As Timer

' node data
Private cCommandClassId As New Collection

' queue and command buffer stuff
Private cQueue As New Collection   ' command buffer
Private bHttpBusy As Boolean       ' already fetching?

'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
' Z-Wave Constants
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Private Const BASIC_TYPE_CONTROLLER As Byte = &H01
Private Const BASIC_TYPE_STATIC_CONTROLLER As Byte = &H02
Private Const BASIC_TYPE_SLAVE As Byte = &H03
Private Const BASIC_TYPE_ROUTING_SLAVE As Byte = &H04

Private Const GENERIC_TYPE_GENERIC_CONTROLLER As Byte = &H01
Private Const GENERIC_TYPE_STATIC_CONTROLLER As Byte = &H02
Private Const GENERIC_TYPE_AV_CONTROL_POINT As Byte = &H03
Private Const GENERIC_TYPE_DISPLAY As Byte = &H04
Private Const GENERIC_TYPE_THERMOSTAT As Byte = &H08
Private Const GENERIC_TYPE_WINDOW_COVERING As Byte = &H09
Private Const GENERIC_TYPE_REPEATER_SLAVE As Byte = &H0F
Private Const GENERIC_TYPE_SWITCH_BINARY As Byte = &H10
Private Const GENERIC_TYPE_SWITCH_MULTILEVEL As Byte = &H11
Private Const GENERIC_TYPE_SWITCH_REMOTE As Byte = &H12
Private Const GENERIC_TYPE_SWITCH_TOGGLE As Byte = &H13
Private Const GENERIC_TYPE_ZIP_GATEWAY As Byte = &H14
Private Const GENERIC_TYPE_ZIP_NODE As Byte = &H15
Private Const GENERIC_TYPE_VENTILATION As Byte = &H16
Private Const GENERIC_TYPE_SENSOR_BINARY As Byte = &H20
Private Const GENERIC_TYPE_SENSOR_MULTILEVEL As Byte = &H21
Private Const GENERIC_TYPE_METER_PULSE As Byte = &H30
Private Const GENERIC_TYPE_METER As Byte = &H31
Private Const GENERIC_TYPE_ENTRY_CONTROL As Byte = &H40
Private Const GENERIC_TYPE_SEMI_INTEROPERABLE As Byte = &H50
Private Const GENERIC_TYPE_SENSOR_ALARM As Byte = &HA1
Private Const GENERIC_TYPE_NON_INTEROPERABLE As Byte = &HFF

Private Const COMMAND_CLASS_NO_OPERATION As Byte = &H00 ' 0
Private Const COMMAND_CLASS_BASIC As Byte = &H20 ' 32
Private Const COMMAND_CLASS_CONTROLLER_REPLICATION As Byte = &H21 ' 33
Private Const COMMAND_CLASS_APPLICATION_STATUS As Byte = &H22 ' 34
Private Const COMMAND_CLASS_ZIP_SERVICES As Byte = &H23 ' 35
Private Const COMMAND_CLASS_ZIP_SERVER As Byte = &H24 ' 36
Private Const COMMAND_CLASS_SWITCH_BINARY As Byte = &H25 ' 37
Private Const COMMAND_CLASS_SWITCH_MULTILEVEL As Byte = &H26 ' 38
Private Const COMMAND_CLASS_SWITCH_ALL As Byte = &H27 ' 39
Private Const COMMAND_CLASS_SWITCH_TOGGLE_BINARY As Byte = &H28 ' 40
Private Const COMMAND_CLASS_SWITCH_TOGGLE_MULTILEVEL As Byte = &H29 ' 41
Private Const COMMAND_CLASS_CHIMNEY_FAN As Byte = &H2A ' 42
Private Const COMMAND_CLASS_SCENE_ACTIVATION As Byte = &H2B ' 43
Private Const COMMAND_CLASS_SCENE_ACTUATOR_CONF As Byte = &H2C ' 44
Private Const COMMAND_CLASS_SCENE_CONTROLLER_CONF As Byte = &H2D ' 45
Private Const COMMAND_CLASS_ZIP_CLIENT As Byte = &H2E ' 46
Private Const COMMAND_CLASS_ZIP_ADV_SERVICES As Byte = &H2F ' 47
Private Const COMMAND_CLASS_SENSOR_BINARY As Byte = &H30 ' 48
Private Const COMMAND_CLASS_SENSOR_MULTILEVEL As Byte = &H31 ' 49
Private Const COMMAND_CLASS_METER As Byte = &H32 ' 50
Private Const COMMAND_CLASS_ZIP_ADV_SERVER As Byte = &H33 ' 51
Private Const COMMAND_CLASS_ZIP_ADV_CLIENT As Byte = &H34 ' 52
Private Const COMMAND_CLASS_METER_PULSE As Byte = &H35 ' 53
Private Const COMMAND_CLASS_THERMOSTAT_HEATING As Byte = &H38 ' 56
Private Const COMMAND_CLASS_THERMOSTAT_MODE As Byte = &H40 ' 64
Private Const COMMAND_CLASS_THERMOSTAT_OPERATING_STATE As Byte = &H42 ' 66
Private Const COMMAND_CLASS_THERMOSTAT_SETPOINT As Byte = &H43 ' 67
Private Const COMMAND_CLASS_THERMOSTAT_FAN_MODE As Byte = &H44 ' 68
Private Const COMMAND_CLASS_THERMOSTAT_FAN_STATE As Byte = &H45 ' 69
Private Const COMMAND_CLASS_CLIMATE_CONTROL_SCHEDULE As Byte = &H46 ' 70
Private Const COMMAND_CLASS_THERMOSTAT_SETBACK As Byte = &H47 ' 71
Private Const COMMAND_CLASS_DOOR_LOCK_LOGGING As Byte = &H4C ' 76
Private Const COMMAND_CLASS_SCHEDULE_ENTRY_LOCK As Byte = &H4E ' 78
Private Const COMMAND_CLASS_BASIC_WINDOW_COVERING As Byte = &H50 ' 80
Private Const COMMAND_CLASS_MTP_WINDOW_COVERING As Byte = &H51 ' 81
Private Const COMMAND_CLASS_CRC_16_ENCAP As Byte = &H56 ' 86
Private Const COMMAND_CLASS_ASSOCIATION_GROUP_INFORMATION As Byte = &H59 ' 89
Private Const COMMAND_CLASS_DEVICE_RESET_LOCALLY As Byte = &H5A ' 90
Private Const COMMAND_CLASS_CENTRAL_SCENE As Byte = &H5B ' 91
Private Const COMMAND_CLASS_ZWAVE_PLUS As Byte = &H5E ' 94
Private Const COMMAND_CLASS_MULTI_INSTANCE As Byte = &H60 ' 96
Private Const COMMAND_CLASS_DOOR_LOCK As Byte = &H62 ' 98
Private Const COMMAND_CLASS_USER_CODE As Byte = &H63 ' 99
Private Const COMMAND_CLASS_CONFIGURATION As Byte = &H70 ' 112
Private Const COMMAND_CLASS_ALARM As Byte = &H71 ' 113
Private Const COMMAND_CLASS_MANUFACTURER_SPECIFIC As Byte = &H72 ' 114
Private Const COMMAND_CLASS_POWERLEVEL As Byte = &H73 ' 115
Private Const COMMAND_CLASS_PROTECTION As Byte = &H75 ' 117
Private Const COMMAND_CLASS_LOCK As Byte = &H76 ' 118
Private Const COMMAND_CLASS_NODE_NAMING As Byte = &H77 ' 119
Private Const COMMAND_CLASS_FIRMWARE_UPDATE_MD As Byte = &H7A ' 122
Private Const COMMAND_CLASS_GROUPING_NAME As Byte = &H7B ' 123
Private Const COMMAND_CLASS_REMOTE_ASSOCIATION_ACTIVATE As Byte = &H7C ' 124
Private Const COMMAND_CLASS_REMOTE_ASSOCIATION As Byte = &H7D ' 125
Private Const COMMAND_CLASS_BATTERY As Byte = &H80 ' 128
Private Const COMMAND_CLASS_CLOCK As Byte = &H81 ' 129
Private Const COMMAND_CLASS_HAIL As Byte = &H82 ' 130
Private Const COMMAND_CLASS_WAKE_UP As Byte = &H84 ' 132
Private Const COMMAND_CLASS_ASSOCIATION As Byte = &H85 ' 133
Private Const COMMAND_CLASS_VERSION As Byte = &H86 ' 134
Private Const COMMAND_CLASS_INDICATOR As Byte = &H87 ' 135
Private Const COMMAND_CLASS_PROPRIETARY As Byte = &H88 ' 136
Private Const COMMAND_CLASS_LANGUAGE As Byte = &H89 ' 137
Private Const COMMAND_CLASS_TIME As Byte = &H8A ' 138
Private Const COMMAND_CLASS_TIME_PARAMETERS As Byte = &H8B ' 139
Private Const COMMAND_CLASS_GEOGRAPHIC_LOCATION As Byte = &H8C ' 140
Private Const COMMAND_CLASS_COMPOSITE As Byte = &H8D ' 141
Private Const COMMAND_CLASS_MULTI_INSTANCE_ASSOCIATION As Byte = &H8E ' 142
Private Const COMMAND_CLASS_MULTI_CMD As Byte = &H8F ' 143
Private Const COMMAND_CLASS_ENERGY_PRODUCTION As Byte = &H90 ' 144
Private Const COMMAND_CLASS_MANUFACTURER_PROPRIETARY As Byte = &H91 ' 145
Private Const COMMAND_CLASS_SCREEN_MD As Byte = &H92 ' 146
Private Const COMMAND_CLASS_SCREEN_ATTRIBUTES As Byte = &H93 ' 147
Private Const COMMAND_CLASS_SIMPLE_AV_CONTROL As Byte = &H94 ' 148
Private Const COMMAND_CLASS_AV_CONTENT_DIRECTORY_MD As Byte = &H95 ' 149
Private Const COMMAND_CLASS_AV_RENDERER_STATUS As Byte = &H96 ' 150
Private Const COMMAND_CLASS_AV_CONTENT_SEARCH_MD As Byte = &H97 ' 151
Private Const COMMAND_CLASS_SECURITY As Byte = &H98 ' 152
Private Const COMMAND_CLASS_AV_TAGGING_MD As Byte = &H99 ' 153
Private Const COMMAND_CLASS_IP_CONFIGURATION As Byte = &H9A ' 154
Private Const COMMAND_CLASS_ASSOCIATION_COMMAND_CONFIGURATION As Byte = &H9B ' 155
Private Const COMMAND_CLASS_SENSOR_ALARM As Byte = &H9C ' 156
Private Const COMMAND_CLASS_SILENCE_ALARM As Byte = &H9D ' 157
Private Const COMMAND_CLASS_SENSOR_CONFIGURATION As Byte = &H9E ' 158
Private Const COMMAND_CLASS_MARK As Byte = &HEF ' 239
Private Const COMMAND_CLASS_NON_INTEROPERABLE As Byte = &HF0 ' 240

'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
' Mandatory subroutine for each Module/Class to initialize:
' - The cPlugin[x].Settings are copied into local variables
' - Port/Connection will be started (any errors caught)
' - Any other code per Class
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Public Sub StartPlugin(cPl As CPluginEntry)

  KeyName = cPl.KeyName
  Instance = cPl.Instance
  If Instance <> 1 Then LogLabel = Replace(LogLabel, "] ", "#" & Instance & "] ")

  ' Copy configuration items locally
  $bEnabled = cPl.Settings["enabled"]
  $sTCPHost = cPl.Settings["tcphost"]
  $iTCPPort = cPl.Settings["tcpport"]
  $sUsername = cPl.Settings["username"]
  $sPassword = cPl.Settings["password"]
  $iPollTime = cPl.Settings["polltime"]
  $bDebug = cPl.Settings["debug"]

  InterfaceId = Devices.FindInterface("RaZberry Z-Wave Interface")
  If InterfaceId = 0 Then
    ErrorText = "Required InterfaceId can't be retrieved from the database!"
    Main.WriteLog(LogLabel & "ERROR: " & ErrorText)
    IsRunning = False
    Return
  Endif

  ' Connect/Initialize connection 
  Run()

End

'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
' Mandatory sub for each Module/Class to stop
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Public Sub StopPlugin()

  Try Disconnect()

End

'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
' init
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Private Sub Run()

  bInit = True
  Initialize()

  ' define poll timer
  tRaZberry = New Timer As "tRaZberry"
  tRaZberry.Delay = $iPollTime * 1000 ' multiply for seconds
  tRaZberry.Stop

  Main.WriteLog(LogLabel & PluginFriendlyName & " initializing.")

  ' all ok
  IsRunning = True

Catch
  Main.WriteLog(LogLabel & "ERROR: " & PluginFriendlyName & " FAILED to initialize")
  Main.WriteLog(LogLabel & "ERROR: " & Error.Text)
  IsRunning = False
  ErrorText = Error.Text
  ErrorWhere = Error.Where

  IsRunning = False

End

Public Sub tRaZberry_Timer()

  GetUpdates()

End

'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
'
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Private Sub GetURL(sCmd As String) As String

  If $sUsername And If $sPassword Then
    Return "https://" & $sUsername & ":" & $sPassword & "@" & $sTCPHost & ":" & $iTCPPort & sCmd
  Else
    Return "http://" & $sTCPHost & ":" & $iTCPPort & sCmd
  Endif

End

'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
'
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Private Sub Initialize() As Boolean

  Dim sURL As String = GetURL("/ZWaveAPI/Data/" & $iUpdateTime)
  Dim sFile As String = Main.sBaseDir &/ "razberry.log"

  ' for development/debugging only
  If Exist(sFile) And If $bDebug Then
    If $bDebug Then Main.WriteDebugLog(LogLabel & "Initializing data read from file '" & sFile & "'")
    sBuffer = File.Load(sFile)
    ParseRaZberryData(sBuffer)
    sBuffer = Null
    Return
  Endif

  If $bDebug Then Main.WriteDebugLog(LogLabel & "Initializing data by fetching '" & sURL & "'")

  hRaZberryInit = New HttpClient As "hRaZberryInit"
  hRaZberryInit.URL = sURL
  hRaZberryInit.Async = True
  hRaZberryInit.TimeOut = 3
  hRaZberryInit.Get

Catch ' some errors
  Main.WriteLog(LogLabel & "ERROR: '" & Error.Text & "' at '" & Error.Where & "'")

End

'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
' save init json to log file
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Public Sub WriteJSON(sData As String)

  Dim sFile As String = Main.sBaseDir &/ "logs" &/ "razberry.log"
  Dim hFile As File

  If $bDebug Then Main.WriteDebugLog(LogLabel & "Writing Initializing data to file '" & sFile & "'")
  hFile = Open sFile For Create
  Write #hFile, sData
  Close #hFile

Catch ' some errors
  Main.WriteLog(LogLabel & "ERROR: '" & Error.Text & "' at '" & Error.Where & "'")

End

'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
' collect razberry data
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Public Sub hRaZberryInit_Read()

  If Lof(Last) Then sBuffer &= Read #Last, Lof(Last)

End

'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
' razberry data fetched
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Public Sub hRaZberryInit_Finished()

  Select hRaZberryInit.Code
    Case 200
      ' too noisy
      ' If $bDebug Then Main.WriteDebugLog(LogLabel & "Received '" & sBuffer & "'")
      ParseRaZberryData(sBuffer)
      If $bDebug Then WriteJSON(sBuffer)
    Case Else
      Main.WriteDebugLog(LogLabel & "Unknown error occured while trying to get razberry init data! HTTP=" & Last.Code & ", Buffer=" & sBuffer)
  End Select

  sBuffer = Null
  Try hRaZberryInit.Close

End

'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
' Handle error
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Public Sub hRaZberryInit_Error()

  Log.Plugin_CURL_Error(LogLabel, $sTCPHost, Last.Status)
  sBuffer = Null

End

'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
' Parse Controller Z-Way data
' It is called for Initialization and Updates
' If controller is changed, we get all the controller information again
' If node(s) are added/updated/removed, we get all the node information again
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Private Sub ParseRaZberryData(sData As String)

  Dim cData As JSONCollection
  Dim aUpdate As New String[]
  Dim iNodeId As Integer

  Try cData = JSON.Decode(sData, True) 
  If Error Then
    Main.WriteLog(LogLabel & "ERROR: During decoding JSON data!")
    Return
  Endif

  ' Check if we got 
  If Not cData Then
    Main.WriteLog(LogLabel & "ERROR: Received invalid JSON data!")
    Return
  Endif

  If Not cData.Exist("updateTime") Then
    Main.WriteLog(LogLabel & "ERROR: Didn't receive mandatory 'updateTime' in JSON data!")
    Return
  Endif

  $iNewUpdateTime = cData["updateTime"]

  For Each cData

    If cData.Key = "updateTime" Then
    Else If cData.Key = "controller" Then
      ' If we received new/update controller information, process it
      ParseControllerInfo(cData["controller"])
    Else If cData.Key = "devices" Then 
      ' If we received new/update node(s) information, process it
      ParseDeviceInfo(cData["devices"])
    Else If InStr(cData.Key, ".") Then
      ' This looks to be an update request, split it in an useable array
      aUpdate = Split(cData.Key, ".")

      ' Possible formats:
      ' controller.data.controllerState
      ' devices.6.data.genericType
      ' devices.5.instances.1.commandClasses.37.data.level
      ' devices.8.instances.0.commandClasses.48.data.1
      ' devices.5.instances.1.commandClasses.50.data.2
      ' devices.7.instances.0.commandClasses.156.data.5.sensorState

      Select aUpdate[0]
        Case "controller"
          ' We ignore controller updates
        Case "devices"

          If aUpdate.Count >= 4 Then
            ' Retrieve NodeId
            Try iNodeId = aUpdate[1]
            If Error Then
              Main.WriteLog(LogLabel & "ERROR: Skipping device, unable to detect Z-Wave NodeId '" & aUpdate[1] & "'")
              Continue
            Endif

            ' Only allow valid Z-Wave NodeIds
            If iNodeId < 1 Or If iNodeId > 232 Then
              Main.WriteLog(LogLabel & "ERROR: Skipping device, invalid Z-Wave NodeId '" & iNodeId & "'")
              Continue
            Endif

            ' Lets check if the node is known by us, else there is a discover problem
            If Not $cZWaveNetwork.Exist(iNodeId) Then
              Main.WriteLog(LogLabel & "ERROR: Skipping device, Z-Wave NodeId '" & iNodeId & "' unknown in our list")
              Continue
            Endif

            ' Device Node Info Update, can happen for sleeping device after inclusion
            If aUpdate[2] = "data" Then
              UpdateNodeInfo(aUpdate[3], cData[cData.Key], $cZWaveNetwork[iNodeId])
            Else
            Endif

          Endif

        Default
          ' Unknown update
      End Select

    Else
      ' Unknown update field
      If $bDebug Then Main.WriteDebugLog(LogLabel & "ERROR: Unknown Update key '" & cData.Key & "' received")
    Endif
  Next

  ' Finally update to our latest timestamp
  ' we don 't want to do it earlier, because if an error happens, we loose track of changes
  $iUpdateTime = $iNewUpdateTime

Catch ' some errors
  Main.WriteDebugLog(LogLabel & "ERROR: '" & Error.Text & "' at '" & Error.Where & "'")

End

'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
' Update Z-Wave Controller Information. It can be supplied during initial startup or during updates
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Private Sub UpdateControllerInfo(sKey As String, cData As JSONCollection, cZWaveNode As JSONCollection)

  Dim sTag As String

  Select sKey
    Case "homeId"
      sTag = "homeid"
    Case "nodeId"
      sTag = "controllerid"
    Case "SDK"
      sTag = "sdkversion"
    Case "APIVersion"
      sTag = "apiversion"
    Case "softwareRevisionVersion"
      sTag = "zwayversion"
    Case "softwareRevisionDate"
      sTag = "zwaybuilddate"
    Case "softwareRevisionId"
      sTag = "zwayrevisionid"
    Case "vendor"
      sTag = "manufacturername"
    Case "ZWaveChip"
      sTag = "zwavechip"
    Case "isPrimary"
      sTag = "primary"
    Case "isRealPrimary"
      sTag = "realprimary"
    Case "libType"
      sTag = "librarytype"
  End Select

  ' Only store a mapped name, all others we aren't interested in
  If sTag Then

    ' Check if the "value" exists, else there is something wrong with the data
    If cData.Exist("value") Then

      ' Now add the mapped value into the Z-Wave nodeinfo
      cZWaveNode.Add(cData["value"], sTag)
    Else
      ' This is never a valid error scenario
      Main.WriteDebugLog(LogLabel & "ERROR: Data doesn't contain a 'value' field. Z-Wave Controller, Data='" & JSON.Encode(cData) & "'")
    Endif
  Endif

End

'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
' Parse Controller Information
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Private Sub ParseControllerInfo(cData As JSONCollection)

  Dim cController As New JSONCollection

  cController.Add(0, "homeid")
  cController.Add(0, "controllerid")
  cController.Add("", "sdkversion")
  cController.Add("", "apiversion")
  cController.Add("", "zwayversion")
  cController.Add("", "zwaybuilddate")
  cController.Add("", "zwayrevisionid")
  cController.Add("", "manufacturername")
  cController.Add("", "zwavechip")
  cController.Add(False, "primary")
  cController.Add(False, "realprimary")
  cController.Add("", "librarytype")

  ' Go through all data entries and parse them
  For Each cData["data"]
    If TypeOf(cData["data"][cData["data"].Key]) = gb.Object And If Object.Type(cData["data"][cData["data"].Key]) = "JSONCollection" Then
      UpdateControllerInfo(cData["data"].Key, cData["data"][cData["data"].Key], cController)
    Endif
  Next

  ' Add the controller information to the internal Z-Wave Network
  $cZWaveNetwork.Add(cController, "controller")

  If $bDebug Then
    Main.WriteDebugLog(LogLabel & "---")
    Main.WriteDebugLog(LogLabel & "Controller Info")
    Main.WriteDebugLog(LogLabel & "---")
    Main.WriteDebugLog(LogLabel & "Home Id: 0x" & Hex(cController["homeid"], 7))
    Main.WriteDebugLog(LogLabel & "Node Id: " & cController["controllerid"])
    Main.WriteDebugLog(LogLabel & "Primary Role: " & Util.DisplayBool(cController["primary"]))
    Main.WriteDebugLog(LogLabel & "Primary Capability: " & Util.DisplayBool(cController["realprimary"]))
    Main.WriteDebugLog(LogLabel & "ManufacturerName: " & cController["manufacturername"])
    Main.WriteDebugLog(LogLabel & "Z-Wave Chip: " & cController["zwavechip"])
    Main.WriteDebugLog(LogLabel & "Library Type: " & cController["librarytype"])
    Main.WriteDebugLog(LogLabel & "SDK Version: " & cController["sdkversion"])
    Main.WriteDebugLog(LogLabel & "API Version: " & cController["apiversion"])
    Main.WriteDebugLog(LogLabel & "---")
    Main.WriteDebugLog(LogLabel & "Z-Way Version")
    Main.WriteDebugLog(LogLabel & "Version: " & cController["zwayversion"] & " (" & cController["zwayrevisionid"] & ")")
    Main.WriteDebugLog(LogLabel & "Date: " & cController["zwaybuilddate"])
    Main.WriteDebugLog(LogLabel & "---")
    Main.WriteDebugLog(LogLabel & "Update Timestamp: " & Util.TimeSinceEpoch($iNewUpdateTime) & " (" & $iNewUpdateTime & ")")
  Endif

End

'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
' Update Z-Wave Node Information. It can be supplied during initial startup or during updates
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Private Sub UpdateNodeInfo(sKey As String, cData As JSONCollection, cZWaveNode As JSONCollection)

  Dim sTag As String

  If Not cZWaveNode Then
    If $bDebug Then Main.WriteDebugLog(LogLabel & "ERROR: Received a Node Info Update for key='" & sKey & "', but node doesn't exist")
    Return
  Endif

  ' Map Z-Way names to internal
  Select sKey
    Case "vendorString"
      sTag = "manufacturername"
    Case "manufacturerId"
      sTag = "manufacturerid"
    Case "isRouting"
      sTag = "routing"
    Case "isListening"
      sTag = "listening"
    Case "sensor250"
      sTag = "sensor250"
    Case "sensor1000"
      sTag = "sensor1000"
    Case "beaming"
      sTag = "beaming"
    Case "nodeInfoFrame"
      sTag = "nodeinfoframe"
    Case "neighbours"
      sTag = "neighbors"
    Case "basicType"
      sTag = "basicid"
    Case "genericType"
      sTag = "genericid"
    Case "specificType"
      sTag = "specificid"
    Case "deviceTypeString"
      sTag = "devicetype"
    Case "ZWLib"
      sTag = "libraryversion"
    Case "SDK"
      sTag = "sdkversion"
    Case "isFailed"
      sTag = "state"
    Case "applicationMajor", "applicationMinor", "ZWProtocolMajor", "ZWProtocolMinor"
      sTag = sKey
  End Select

  ' Only store a mapped name, all others we aren't interested in
  If sTag Then

    ' Node Info is updated with a RaZberry update, lets report it
    If $iUpdateTime > 0 Then
      If $bDebug Then Main.WriteDebugLog(LogLabel & "Received Node Info Update for Z-Wave NodeId '" & cZWaveNode["node_id"] & "'" & ", Key '" & sTag & "', Value '" & cData["value"] & "'")
    Endif

    ' Check if the "value" exists, else there is something wrong with the data
    If cData.Exist("value") Then

      ' Now add the mapped value into the Z-Wave nodeinfo
      cZWaveNode.Add(cData["value"], sTag)

      ' Add other special (none Z-Way) values based on the input
      Select sTag
        Case "sensor250", "sensor1000"
          If cData["value"] Then cZWaveNode.Add(True, "frequentlistening")
        Case "basicid"
          cZWaveNode.Add(GetBasicTypeName(cData["value"]), "basic")
        Case "genericid"
          cZWaveNode.Add(GetGenericTypeName(cData["value"]), "generic")
        Case "specificid"
          cZWaveNode.Add(GetSpecificTypeName(cZWaveNode["genericid"], cData["value"]), "specific")
        Case "state"
          cZWaveNode.Add(IIf(cData["value"], "Dead", "Alive"), "state")
        Case "applicationMajor"
          If InStr(cZWaveNode["applicationversion"], ".") Then
            cZWaveNode["applicationversion"] = Mid(cZWaveNode["applicationversion"], InStr(cZWaveNode["applicationversion"], ".") + 1)
          Endif
          cZWaveNode.Add(cZWaveNode[sTag] & "." & cZWaveNode["applicationversion"], "applicationversion")
          cZWaveNode.Remove(sTag)
        Case "applicationMinor"
          If InStr(cZWaveNode["applicationversion"], ".") Then
            cZWaveNode["applicationversion"] = Left(cZWaveNode["applicationversion"], InStr(cZWaveNode["applicationversion"], ".") - 1)
          Endif
          cZWaveNode.Add(cZWaveNode["applicationversion"] & "." & cZWaveNode[sTag], "applicationversion")
          cZWaveNode.Remove(sTag)
        Case "ZWProtocolMajor"
          If InStr(cZWaveNode["protocolversion"], ".") Then
            cZWaveNode["protocolversion"] = Mid(cZWaveNode["protocolversion"], InStr(cZWaveNode["protocolversion"], ".") + 1)
          Endif
          cZWaveNode.Add(cZWaveNode[sTag] & "." & cZWaveNode["protocolversion"], "protocolversion")
          cZWaveNode.Remove(sTag)
        Case "ZWProtocolMinor"
          If InStr(cZWaveNode["protocolversion"], ".") Then
            cZWaveNode["protocolversion"] = Left(cZWaveNode["protocolversion"], InStr(cZWaveNode["protocolversion"], ".") - 1)
          Endif
          cZWaveNode.Add(cZWaveNode["protocolversion"] & "." & cZWaveNode[sTag], "protocolversion")
          cZWaveNode.Remove(sTag)
      End Select
    Else
      ' This is never a valid error scenario
      Main.WriteDebugLog(LogLabel & "ERROR: Data doesn't contain a 'value' field. Z-Wave NodeId=" & CZWaveNode["node_id"] & ", Data='" & JSON.Encode(cData) & "'")
    Endif
  Endif

End

'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
' Parse Device Information
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Private Sub ParseDeviceInfo(cData As JSONCollection)

  Dim cZWaveNode As JSONCollection
  Dim cNode, cInstance As New JSONCollection
  Dim iNodeId As Integer
  Dim iInstanceId As Integer
  Dim aBytes As Byte[]
  Dim iScale As Integer
  Dim iType As Integer

  Dim iBattery, iScaleId, iSensorType, iScaleMulti, iDeviceId As Integer
  Dim sDeviceTypeAutoCreate, sScale As String
  Dim vValues, vValue, vValue2, vValue3, vValue4, vValueTemp As Variant

  ' Remove all nodes from the Z-Wave Network, they will be re-added automatically
  ' The API doesn't tell us which devices are removed, just which nodes there are (left)
  For Each $cZWaveNetwork
    ' Only skip the controller, we need to keep it
    If $cZWaveNetwork.Key <> "controller" Then
      $cZWaveNetwork.Remove($cZWaveNetwork.Key)
    Endif
  Next

  ' Don't continue if the controller record is missing, something went horrorible wrong
  If Not $cZWaveNetwork.Exist("controller") Then
    Main.WriteLog(LogLabel & "ERROR: Device List supplied, but no controller information available. Looks like a bug?")
    Return
  Endif

  ' devices found
  If cData.Count Then
    If $bDebug Then
      Main.WriteDebugLog(LogLabel & "---")
      Main.WriteDebugLog(LogLabel & "Interface Reported " & cData.Count & " device(s).")
    Endif

    ' go through each node
    For Each cNode In cData

      cZWaveNode = New JSONCollection

      ' The Z-Wave NodeId is in the key
      Try iNodeId = CInt(cData.Key)
      If Error Then
        Main.WriteDebugLog(LogLabel & "ERROR: Skipping device, unable to detect Z-Wave NodeId '" & cData.Key & "'")
        Continue
      Endif

      ' Only allow valid Z-Wave NodeIds
      If iNodeId < 1 Or If iNodeId > 232 Then
        Main.WriteDebugLog(LogLabel & "ERROR: Skipping device, invalid Z-Wave NodeId '" & iNodeId & "'")
        Continue
      Endif

      ' Add Z-Wave NodeId and default values into a new record
      cZWaveNode.Add(iNodeId, "node_id")
      cZWaveNode.Add(0, "basicid")
      cZWaveNode.Add("", "basic")
      cZWaveNode.Add(0, "genericid")
      cZWaveNode.Add("", "generic")
      cZWaveNode.Add(0, "specificid")
      cZWaveNode.Add("", "specific")
      cZwaveNode.Add("", "manufacturername")
      cZWaveNode.Add(0, "manufacturerid")
      cZWaveNode.Add(False, "routing")
      cZWaveNode.Add(False, "listening")
      cZWaveNode.Add(False, "frequentlistening")
      cZWaveNode.Add(False, "beaming")
      aBytes = New Byte[]
      cZWaveNode.Add(aBytes, "nodeinfoframe")
      cZWaveNode.Add(False, "wakeup")
      cZWaveNode.Add(False, "battery")
      cZWaveNode.Add(False, "security")
      cZWaveNode.Add(False, "multiinstance")
      aBytes = New Byte[]
      cZWaveNode.Add(aBytes, "neigbors")
      cZWaveNode.Add("", "devicetype")
      cZWaveNode.Add("", "libraryversion")
      cZWaveNode.Add("", "sdkversion")
      cZWaveNode.Add("", "applicationversion")
      cZWaveNode.Add("", "protocolversion")
      cZWaveNode.Add("", "state")

      ' Now process each node record
      For Each cNode["data"]
        If TypeOf(cNode["data"][cNode["data"].Key]) = gb.Object And If Object.Type(cNode["data"][cNode["data"].Key]) = "JSONCollection" Then
          UpdateNodeInfo(cNode["data"].Key, cNode["data"][cNode["data"].Key], cZWaveNode)
        Endif 
      Next

      ' We should always have instance(s)
      If Not cNode.Exist("instances") Then
        Return
      Endif

      ' Check for instances, battery, wakeup and security
      Try cZWaveNode.Add(CBool(IIf(cNode["instances"]["0"]["commandClasses"]["132"], True, False)), "wakeup")
      Try cZWaveNode.Add(CBool(IIf(cNode["instances"]["0"]["commandClasses"]["128"], True, False)), "battery")
      Try cZWaveNode.Add(CBool(IIf(cNode["instances"]["0"]["commandClasses"]["152"], True, False)), "security")
      Try cZWaveNode.Add(IIf(cNode["instances"].Count > 1, True, False), "multiinstance")
      If Error Then cZWaveNode.Add(False, "multiinstance")

      ' LastSeen

      ' If device is the controller, just add it to the ZWaveNode and go to the next device
      If iNodeId = $cZWaveNetwork["controller"]["controllerid"] Then
        Try cZWaveNode.Add($cZWaveNetwork["controller"]["sdkversion"], "sdkversion")
        If Error Then cZWaveNode.Add("", "sdkversion")

        $cZWaveNetwork.Add(cZWaveNode, cZWaveNode["node_id"])

        If $bDebug Then Main.WriteDebugLog(LogLabel & "Detected controller as node #" & iNodeId & ", skipping...") 
        Continue
      Endif

      ' Determine auto-create devicetype
      Select cZWaveNode["genericid"]
        Case &H01, &H02
          sDeviceTypeAutoCreate = "Z-Wave Controller"
        Case &H08
          sDeviceTypeAutoCreate = "Z-Wave Thermostat"
        Case &H10
          sDeviceTypeAutoCreate = "Z-Wave Switch"
        Case &H11
          Select cZWaveNode["specificid"]
            Case &H05, &H06, &H07
              sDeviceTypeAutoCreate = "Z-Wave Motor Control"
            Default
              sDeviceTypeAutoCreate = "Z-Wave Dimmer"
          End Select
        Case &H12
          sDeviceTypeAutoCreate = "Z-Wave Remote Switch"
        Case &H20, &H21, &H30, &H31, &HA1
          sDeviceTypeAutoCreate = "Z-Wave Sensor"
        Case &H40
          Select cZWaveNode["specificid"]
            Case &H01, &H02, &H03
              sDeviceTypeAutoCreate = "Z-Wave Door Lock"
            Default
              sDeviceTypeAutoCreate = "Z-Wave Entry Control"
          End Select
        Default
          sDeviceTypeAutoCreate = "Z-Wave Generic"
      End Select

      ' If the devicetype is empty, overrule it
      If Not cZWaveNode["devicetype"] Then
        cZWaveNode.Add(sDeviceTypeAutoCreate, "devicetype")
      Endif

      If $bDebug Then
        Main.WriteDebugLog(LogLabel & "---")
        Main.WriteDebugLog(LogLabel & "Node #" & iNodeId)
        Main.WriteDebugLog(LogLabel & "ManufacturerName: " & cZWaveNode["manufacturername"])
        Main.WriteDebugLog(LogLabel & "ManufacturerId: " & cZWaveNode["manufacturerid"])
        Main.WriteDebugLog(LogLabel & "DeviceType: " & cZWaveNode["devicetype"])
        Main.WriteDebugLog(LogLabel & "BasicType: " & cZWaveNode["basic"])
        Main.WriteDebugLog(LogLabel & "GenericType: " & cZWaveNode["generic"])
        Main.WriteDebugLog(LogLabel & "SpecificType: " & cZWaveNode["specific"])
        Main.WriteDebugLog(LogLabel & "Listening: " & Util.DisplayBool(cZWaveNode["listening"]))
        Main.WriteDebugLog(LogLabel & "Frequent Listening (FLiRS): " & Util.DisplayBool(cZWaveNode["frequentlistening"]))
        Main.WriteDebugLog(LogLabel & "SDK Version: " & cZWaveNode["sdkversion"])
        Main.WriteDebugLog(LogLabel & "Application Version: " & cZWaveNode["applicationversion"])
        Main.WriteDebugLog(LogLabel & "Protocol Version: " & cZWaveNode["protocolversion"])
        Main.WriteDebugLog(LogLabel & "WakeUp: " & Util.DisplayBool(cZWaveNode["wakeup"]))
        Main.WriteDebugLog(LogLabel & "Battery: " & Util.DisplayBool(cZWaveNode["battery"]))
        Main.WriteDebugLog(LogLabel & "Multiple Instances: " & Util.DisplayBool(cZWaveNode["multiinstance"]))
      Endif

      ' go through each instance
      For Each cInstance In cNode["instances"]

        ' devices.2.instances.0.data
        Try iInstanceId = CInt(cNode["instances"].Key)
        If Error Then
          Main.WriteDebugLog(LogLabel & "ERROR: Skipping device, invalid instance '" & cNode["instances"].Key & "' for node " & cZWaveNode["node_id"])
          Continue
        Endif

        ' Skip instance 0 if it has more, since it should be mapped to other instances
        If iInstanceId = 0 And If cZWaveNode["multiinstance"] Then Continue
        If $bDebug Then Main.WriteDebugLog(LogLabel & "Instance #" & iInstanceId)

        ' CommandClasses need to exist
        If Not cInstance.Exist("commandClasses") Then
          Continue
        Endif

        ' ### NEW CODE ####

        ' Command_Class_Basic
        ' Use basic = 32 In nodeinfoframe To determine If we need To put an empty value In value1? in instance=0/1

        ' We should try Multilevel (dimmer) before a Switch
        ' Command_Class_Switch_Multilevel (38)
        If cInstance["commandClasses"].Exist(COMMAND_CLASS_SWITCH_MULTILEVEL) Then
          UpdateNodeCommandClass_SwitchMultiLevel(iInstanceId, cInstance["commandClasses"][COMMAND_CLASS_SWITCH_MULTILEVEL]["data"]["level"], cZWaveNode)

        ' Command_Class_Switch_Binary (37)
        Else If cInstance["commandClasses"].Exist(COMMAND_CLASS_SWITCH_BINARY) Then
          UpdateNodeCommandClass_SwitchBinary(iInstanceId, cInstance["commandClasses"][COMMAND_CLASS_SWITCH_BINARY]["data"]["level"], cZWaveNode)
        Endif

        ' Command_Class_Sensor_Binary (48)
        If cInstance["commandClasses"].Exist(COMMAND_CLASS_SENSOR_BINARY) Then
          For Each cInstance["commandClasses"][COMMAND_CLASS_SENSOR_BINARY]["data"]
            If IsNumber(cInstance["commandClasses"][COMMAND_CLASS_SENSOR_BINARY]["data"].Key) Then
              iType = CInt(cInstance["commandClasses"][COMMAND_CLASS_SENSOR_BINARY]["data"].Key)
              UpdateNodeCommandClass_SensorBinary(iInstanceId, iScale, cInstance["commandClasses"][COMMAND_CLASS_SENSOR_BINARY]["data"][iType], cZWaveNode)
            Endif
          Next
        Endif

        ' Command_Class_Sensor_Multilevel (49)

        ' Command_Class_Meter (50)
        If cInstance["commandClasses"].Exist(COMMAND_CLASS_METER) Then
          For Each cInstance["commandClasses"][COMMAND_CLASS_METER]["data"]
            If IsNumber(cInstance["commandClasses"][COMMAND_CLASS_METER]["data"].Key) Then
              iScale = CInt(cInstance["commandClasses"][COMMAND_CLASS_METER]["data"].Key)
              UpdateNodeCommandClass_Meter(iInstanceId, iScale, cInstance["commandClasses"][COMMAND_CLASS_METER]["data"][iScale], cZWaveNode)
            Endif
          Next
        Endif

        ' Command_Class_SetPoint (67)

        ' Command_Class_Battery (128)

        ' Command_Class_Sensor_Alarm (156)

        ' ### NEW CODE ####

        ' battery level if available
        If cZWaveNode["battery"] Then Try iBattery = cInstance["commandClasses"]["128"]["data"]["last"]["value"]

        ' dimmer
        ' use SwitchMultilevel first, if not available use SwitchBinary
        If cInstance["commandClasses"]["38"] Then

          Try cCommandClassId.Add(38, iNodeId & ":" & iInstanceId)
          vValue = cInstance["commandClasses"]["38"]["data"]["level"]["value"]
          If $bDebug Then Main.WriteDebugLog(LogLabel & "Dimmer Device: " & vValue)
          Select vValue
            Case "99"
              vValue = "On"
            Case "0"
              vValue = "Off"
            Case Else
              vValue = "Dim " & vValue
          End Select

          ' update device
        ' switch
        Else If cInstance["commandClasses"]["37"] Then

          Try cCommandClassId.Add(37, iNodeId & ":" & iInstanceId)
          vValue = cInstance["commandClasses"]["37"]["data"]["level"]["value"]
          If $bDebug Then Main.WriteDebugLog(LogLabel & "Switch Device: " & Util.DisplayBool(vValue))
          vValue = IIf(vValue = 255, "On", "Off")
          ' update device
        Endif

        ' sensor multilevel, binary switch eg pir
        If cInstance["commandClasses"]["48"] Then
          If $cZWaveNetwork["controller"]["zwayversion"] = "v1.3.1" Then
            vValue = cInstance["commandClasses"]["48"]["data"][cInstance["commandClasses"]["48"]["data"].Key]["level"]["value"]
          Else ' 1.4 or higher
            For Each vValues In cInstance["commandClasses"]["48"]["data"]
              If IsNumber(cInstance["commandClasses"]["48"]["data"].Key) Then
                Select Case cInstance["commandClasses"]["48"]["data"][cInstance["commandClasses"]["48"]["data"].Key]["sensorTypeString"]["value"]
                  Case "General purpose"
                    vValue = cInstance["commandClasses"]["48"]["data"][cInstance["commandClasses"]["48"]["data"].Key]["level"]["value"]
                    If $bDebug Then Main.WriteDebugLog(LogLabel & "General purpose: " & vValue)
                  Case Else
                    If $bDebug Then Main.WriteDebugLog(LogLabel & "Unknown commandclass 48 type: " & cInstance["commandClasses"]["48"]["data"][cInstance["commandClasses"]["48"]["data"].Key]["sensorTypeString"]["value"])
                    Continue
                End Select
                ' update device

                If $bDebug Then Main.WriteDebugLog(LogLabel & "Multilevel binary switch device: " & Util.DisplayBool(vValue))
                Select Case cZWaveNode["manufacturername"] & " " & cZWaveNode["devicetype"]
                  Case "Aeon Labs Routing Binary Sensor"
                    vValue = IIf(vValue = True, "Open", "Close")
                End Select
              Endif
            Next
          Endif
        Endif

        ' sensor humid, light, temp or power
        If cInstance["commandClasses"]["49"] Then

          For Each vValues In cInstance["commandClasses"]["49"]["data"]
            If IsNumber(cInstance["commandClasses"]["49"]["data"].Key) Then
              vValue4 = cInstance["commandClasses"]["49"]["data"][cInstance["commandClasses"]["49"]["data"].Key]["val"]["value"]
              Select Case cInstance["commandClasses"]["49"]["data"][cInstance["commandClasses"]["49"]["data"].Key]["sensorTypeString"]["value"]
                Case "Power"
                  If $bDebug Then Main.WriteDebugLog(LogLabel & "Power Sensor: " & vValue4)
                Case "Temperature"
                  If $bDebug Then Main.WriteDebugLog(LogLabel & "Temp Sensor: " & vValue4)
                Case "Humidity"
                  If $bDebug Then Main.WriteDebugLog(LogLabel & "Humid Sensor: " & vValue4)
                Case "Luminiscence"
                  If $bDebug Then Main.WriteDebugLog(LogLabel & "Luminiscence Sensor: " & vValue4)
              End Select
              ' update device
            Endif
          Next
        Endif

        ' security
        If cInstance["commandClasses"]["99"] Then
          For Each vValues In cInstance["commandClasses"]["99"]["data"]
            If IsNumber(cInstance["commandClasses"]["99"]["data"].Key) Then
              vValueTemp = cInstance["commandClasses"]["99"]["data"].Key
              If $bDebug Then Main.WriteDebugLog(LogLabel & "User Id: " & vValueTemp)
              vValueTemp = cInstance["commandClasses"]["99"]["data"][cInstance["commandClasses"]["99"]["data"].Key]["status"]["value"]
              If $bDebug Then Main.WriteDebugLog(LogLabel & "User Code: " & vValueTemp)
              ' update device
            Endif
          Next
        Endif

        ' meter sensors
        If cInstance["commandClasses"]["50"] Then
          For Each vValues In cInstance["commandClasses"]["50"]["data"]
            If IsNumber(cInstance["commandClasses"]["50"]["data"].Key) Then
              iScaleId = cInstance["commandClasses"]["50"]["data"].Key
              iSensorType = cInstance["commandClasses"]["50"]["data"][cInstance["commandClasses"]["50"]["data"].Key]["sensorType"]["value"]
              sScale = cInstance["commandClasses"]["50"]["data"][cInstance["commandClasses"]["50"]["data"].Key]["scaleString"]["value"]
              If iScaleId = 0 Or If iScaleId = 2 Or If iScaleId = 6 Then
                If iSensorType = 1 Then
                  iScaleMulti = 1
                  If sScale = "kWh" Then
                    iScaleMulti = 1000
                  Endif
                Endif
                vValueTemp = cInstance["commandClasses"]["50"]["data"][cInstance["commandClasses"]["50"]["data"].Key]["val"]["value"]
                If $bDebug Then Main.WriteDebugLog(LogLabel & "Meter Sensor: " & vValueTemp & sScale)
                ' update values
                If iScaleId = 0 Then
                  vValue3 = vValueTemp
                Else If iScaleId = 2 Then
                  vValue2 = vValueTemp
                Endif
              Endif
            Endif
          ' update device
          Next
        Endif

        ' true meters
        If cInstance["commandClasses"]["50"] Then
          For Each vValues In cInstance["commandClasses"]["50"]["data"]
            If IsNumber(cInstance["commandClasses"]["50"]["data"].Key) Then
              iScaleId = cInstance["commandClasses"]["50"]["data"].Key
              iSensorType = cInstance["commandClasses"]["50"]["data"][cInstance["commandClasses"]["50"]["data"].Key]["sensorType"]["value"]
              sScale = cInstance["commandClasses"]["50"]["data"][cInstance["commandClasses"]["50"]["data"].Key]["scaleString"]["value"]
              If iScaleId = 0 Or If iScaleId = 2 Or If iScaleId = 6 Then
                If iSensorType = 1 Then Continue
              Endif
              iScaleMulti = 1
              If sScale = "kWh" Then
                iScaleMulti = 1000
              Endif
              vValueTemp = cInstance["commandClasses"]["50"]["data"][cInstance["commandClasses"]["50"]["data"].Key]["val"]["value"]
              If iScaleId = 0 Then
                ' KwH value3
                If $bDebug Then Main.WriteDebugLog(LogLabel & "Meter Value2: " & vValueTemp & sScale)
                vValue3 = vValueTemp
              Else If iScaleId = 2 Then
                ' W value2
                If $bDebug Then Main.WriteDebugLog(LogLabel & "Meter Value3: " & vValueTemp & sScale)
                vValue2 = vValueTemp
              Endif
              ' update
            Endif
          ' update device
          Next
        Endif

        ' thermostat
        If cInstance["commandClasses"]["67"]
          Try cCommandClassId.Add(67, iNodeId & ":" & iInstanceId)
          vValue2 = cInstance["commandClasses"]["67"]["data"]["1"]["setVal"]["value"]
          If $bDebug Then Main.WriteDebugLog(LogLabel & "Thermostat SetValue: " & vValue2)
        Endif

        If cZWaveNode["battery"] And If $bDebug Then Main.WriteDebugLog(LogLabel & "Battery Value: " & iBattery & "%")

        ' update device value(s)
        iDeviceId = Devices.Find(Instance, iNodeId & IIf((iInstanceId > 1), ":" & iInstanceId, ""), InterfaceId, sDeviceTypeAutoCreate, cZWaveNode["manufacturername"] & " " & cZWaveNode["devicetype"])
        If iDeviceId Then
          If vValue Then Devices.ValueUpdate(iDeviceId, 1, vValue)
          If vValue2 Then Devices.ValueUpdate(iDeviceId, 2, vValue2)
          If vValue3 Then Devices.ValueUpdate(iDeviceId, 3, vValue3)
          If vValue4 Then Devices.ValueUpdate(iDeviceId, 4, vValue4)
          If cZWaveNode["battery"] Then Devices.Battery(iDeviceId, iBattery)
        Endif

        If $bDebug Then
          If vValue Then Main.WriteDebugLog(LogLabel & "Value1: " & vValue)
          If vValue2 Then Main.WriteDebugLog(LogLabel & "Value2: " & vValue2)
          If vValue3 Then Main.WriteDebugLog(LogLabel & "Value3: " & vValue3)
          If vValue4 Then Main.WriteDebugLog(LogLabel & "Value4: " & vValue4)
        Endif

        ' reset vars for next device
        vValue = ""
        vValue2 = ""
        vValue3 = ""
        vValue4 = ""
        sScale = ""
      Next

      $cZWaveNetwork.Add(cZWaveNode, cZWaveNode["node_id"])
    Next

  Endif

  bInit = True

  ' start update timer
  If $iPollTime And If tRaZberry Then tRaZberry.Start

Catch ' some errors
  Main.WriteDebugLog(LogLabel & "ERROR: '" & Error.Text & "' at '" & Error.Where & "'")

End

'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
'
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Private Sub UpdateIntervalCCValue(iInstanceId As Integer, iMap As Integer, cData As JSONCollection, sPath As String, vValue As Variant, Optional sUnits As String = "")

  Dim cInstance As JSONCollection
  Dim cEntry As JSONCollection
  Dim aMapList As Byte[]

  ' Now check if our instance exists, else create it too
  If Not cData.Exist(iInstanceId) Then
    cInstance = New JSONCollection
    cData.Add(cInstance, iInstanceId)
  Endif

  ' Check for index array, else create it
  If Not cData[iInstanceId].Exist("index") Then
    aMapList = New Byte[]
    cData[iInstanceId].Add(aMapList, "index")
  Endif

  ' Try to find an existing mapping, then we just have to update the data
  If cData[iInstanceId]["index"].Find(iMap) >= 0 Then
    cData[iInstanceId][iMap]["value"] = vValue
  Else
    ' Doesn't exist, create a mapping and sort it
    cData[iInstanceId]["index"].Add(iMap)
    cData[iInstanceId]["index"] = cData[iInstanceId]["index"].Sort()

    ' Create the value & units entry
    cEntry = New JSONCollection
    cEntry.Add(sPath, "path")
    cEntry.Add(vValue, "value")
    cEntry.Add(sUnits, "units")
    cData[iInstanceId].Add(cEntry, iMap)
  Endif

End

'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
' Add or Update the CommandClass_Basic - sensors normally
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
'Private Sub UpdateNodeCommandClass_Basic(iInstanceId As Integer, cData As JSONCollection, cZWaveNode As JSONCollection)

'  Dim iMap As Integer
'  Dim sUpdateKey As String

'  iMap = 2

'End

'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
' Add or Update the CommandClass_Switch_Binary
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Private Sub UpdateNodeCommandClass_SwitchBinary(iInstanceId As Integer, cData As JSONCollection, cZWaveNode As JSONCollection)

  Dim iMap As Integer
  Dim sUpdateKey As String
  Dim cInstance As JSONCollection
  Dim sValue As String

  iMap = 2

  ' Check if the instances information already exist 
  If Not cZWaveNode.Exist("instances") Then
    cInstance = New JSONCollection
    cZWaveNode.Add(cInstance, "instances")
  Endif

  Select cData["type"]
    Case "bool"
      sValue = IIf(cData["value"], "On", "Off")
    Case "int"
      sValue = IIf(cData["value"] > 99, "On", "Off")
    Default
      sValue = "Off"
  End Select

  ' Build up possible update key. E.g. devices.5.instances.1.commandClasses.50.data.2
  sUpdateKey = "devices." & cZWaveNode["node_id"] & ".instances." & iInstanceId & ".commandClasses." & COMMAND_CLASS_SWITCH_BINARY & ".data.level"
  UpdateIntervalCCValue(iInstanceId, iMap, cZWaveNode["instances"], sUpdateKey, sValue)

End

'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
' Add or Update the CommandClass_Switch_MultiLevel
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Private Sub UpdateNodeCommandClass_SwitchMultiLevel(iInstanceId As Integer, cData As JSONCollection, cZWaveNode As JSONCollection)

  Dim iMap As Integer
  Dim sUpdateKey As String
  Dim cInstance As JSONCollection
  Dim sValue As String

  iMap = 2

  ' Check if the instances information already exist 
  If Not cZWaveNode.Exist("instances") Then
    cInstance = New JSONCollection
    cZWaveNode.Add(cInstance, "instances")
  Endif

  Select cData["type"]
    Case "bool"
      sValue = IIf(cData["value"], "On", "Off")
    Case "int"
      If cData["value"] = 0 Then
        sValue = "Off"
      Else If cData["value"] > 99 Then
        sValue = "On"
      Else
        sValue = "Dim " & cData["value"]
      Endif
    Default
      sValue = "Off"
  End Select

  ' Build up possible update key. E.g. devices.5.instances.1.commandClasses.50.data.2
  sUpdateKey = "devices." & cZWaveNode["node_id"] & ".instances." & iInstanceId & ".commandClasses." & COMMAND_CLASS_SWITCH_MULTILEVEL & ".data.level"
  UpdateIntervalCCValue(iInstanceId, iMap, cZWaveNode["instances"], sUpdateKey, sValue)

End

'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
' Add or Update the CommandClass_Sensor_Binary entry
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Private Sub UpdateNodeCommandClass_SensorBinary(iInstanceId As Integer, iType As Integer, cData As JSONCollection, cZWaveNode As JSONCollection)

  Dim sSensorType As String
  Dim sScale As String
  Dim sUpdateKey As String
  Dim iMap As Integer
  Dim cInstance As JSONCollection
  Dim sValue As String

  ' Each Sensor Binary Collection should have:
  ' - sensorTypeString/value = string representation of sensor Type 
  ' - level/value = The actual binary true/false

  Try sSensorType = cData["sensorTypeString"]["value"]
  If Error Or If Not sSensorType Then
    Main.WriteDebugLog(LogLabel & "ERROR: Z-Wave NodeId '" & cZwaveNode["node_id"] & "' seem to have an invalid COMMAND_CLASS_SENSOR_BINARY sensorType for Type '" & iType & "'" & IIf(Error.Text, " '" & Error.Text & "'", ""))
    Return
  Endif

  ' Now try to map the type to a known value
  Select sSensorType
    Case "General purpose"
      iMap = 31
    Case "Smoke"
      iMap = 32
    Case "CO"
      iMap = 33
    Case "CO2"
      iMap = 34
    Case "Heat"
      iMap = 35
    Case "Water"
      iMap = 36
    Case "Freeze"
      iMap = 37
    Case "Tamper"
      iMap = 38
    Case "Aux"
      iMap = 39
    Case "Door/Window"
      iMap = 40
    Case "Tilt"
      iMap = 41
    Case "Motion"
      iMap = 42
    Case "Glass Break"
      iMap = 43
    Default ' For Z-Way v1.31
      iMap = 31
  End Select

  ' Only continue if we found a known type
  If iMap Then

    ' Check if val/value exist, else we can directly stop
    If Not cData.Exist("level") Or If Not cData["level"].Exist("value") Then
      Main.WriteDebugLog(LogLabel & "ERROR: Z-Wave NodeId '" & cZwaveNode["node_id"] & "' seem to not have a valid value for COMMAND_CLASS_SENSOR_BINARY, 'level' or 'value' is missing")
      Return
    Endif

    ' Check if the instances information already exist 
    If Not cZWaveNode.Exist("instances") Then
      cInstance = New JSONCollection
      cZWaveNode.Add(cInstance, "instances")
    Endif

    If cData["level"]["value"] = 255 Then
      sValue = "On"
    Else
      sValue = "Off"
    Endif

    ' Build up possible update key. e.g. devices.5.instances.1.commandClasses.48.data.2
    sUpdateKey = "devices." & cZWaveNode["node_id"] & ".instances." & iInstanceId & ".commandClasses." & COMMAND_CLASS_SENSOR_BINARY & ".data." & iType
    UpdateIntervalCCValue(iInstanceId, iMap, cZWaveNode["instances"], sUpdateKey, sValue)
  Endif

End

'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
' Add or Update the CommandClass_Meter entry 
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Private Sub UpdateNodeCommandClass_Meter(iInstanceId As Integer, iScale As Integer, cData As JSONCollection, cZWaveNode As JSONCollection)

  Dim sSensorType As String
  Dim sScale As String
  Dim sUpdateKey As String
  Dim iMap As Integer
  Dim cInstance As JSONCollection

  ' Each Meter Collection should have:
  ' - delta/value = difference between last and actual meter value
  ' - previous/value = previous meter value (gotten with last GET request
  ' - rateType/value = meter rate type 
  ' - scale/value = meter scale id
  ' - scaleString/value = string representation of meter scale
  ' - sensorType/value = sensor type id 
  ' - sensorTypeString/value = string representation of sensor Type 
  ' - val/value = The actual meter value

  Try sSensorType = cData["sensorTypeString"]["value"]
  If Error Or If Not sSensorType Then
    Main.WriteDebugLog(LogLabel & "ERROR: Z-Wave NodeId '" & cZwaveNode["node_id"] & "' seem to have an invalid COMMAND_CLASS_METER sensorType for Scale '" & iScale & "'" & IIf(Error.Text, " '" & Error.Text & "'", ""))
    Return
  Endif

  Try sScale = cData["scaleString"]["value"]
  If Error Or If Not sScale Then
    Main.WriteDebugLog(LogLabel & "ERROR: Z-Wave NodeId '" & cZwaveNode["node_id"] & "' seem to have an invalid COMMAND_CLASS_METER scale for Scale '" & iScale & "'" & IIf(Error.Text, " '" & Error.Text & "'", ""))
    Return
  Endif

  ' Now try to map the type to a known value
  Select sSensorType
    Case "Electric", "Electric "
      Select sScale
        Case "W"
          iMap = 11
        Case "kWh"
          iMap = 12
        Case "kVAh"
          iMap = 14
        Case "V"
          iMap = 15
        Case "A"
          iMap = 16
        Case "Pulse Count"
          iMap = 17
        Case "Power Factor"
          iMap = 18
      End Select
    Case "Gas"
      Select sScale
        Case "Qubic meter"
          iMap = 19
        Case "Qubic feet"
          iMap = 20
        Case "Pulse Count"
          iMap = 21
      End Select
    Case "Water"
      Select sScale
        Case "Cubic meter"
          iMap = 22
        Case "Cubic feet"
          iMap = 23
        Case "US Gallon"
          iMap = 24
        Case "Pulse Count"
          iMap = 25
      End Select
  End Select

  ' Only continue if we found a known type
  If iMap Then

    ' Check if val/value exist, else we can directly stop
    If Not cData.Exist("val") Or If Not cData["val"].Exist("value") Then
      Main.WriteDebugLog(LogLabel & "ERROR: Z-Wave NodeId '" & cZwaveNode["node_id"] & "' seem to not have a valid value for COMMAND_CLASS_METER, 'val' or 'value' is missing")
      Return
    Endif

    ' Check if the instances information already exist 
    If Not cZWaveNode.Exist("instances") Then
      cInstance = New JSONCollection
      cZWaveNode.Add(cInstance, "instances")
    Endif

    ' Build up possible update key. e.g. devices.5.instances.1.commandClasses.50.data.2
    sUpdateKey = "devices." & cZWaveNode["node_id"] & ".instances." & iInstanceId & ".commandClasses." & COMMAND_CLASS_METER & ".data." & iScale
    UpdateIntervalCCValue(iInstanceId, iMap, cZWaveNode["instances"], sUpdateKey, cData["val"]["value"], sScale)
  Endif

End

'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
' Send Command
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Public Sub SendCommand(sAddress As String, sCmd As String)

  Dim iLevel, iCommandClassId As Integer
  Dim fSetPoint As Float
  Dim aAddress As String[]
  sCmd = UCase(sCmd)

  ' if instance is 0, add it to address
  If Not InStr(sAddress, ":") Then sAddress &= ":0"
  aAddress = Scan(sAddress, "*:*")

  Try iCommandClassId = cCommandClassId[sAddress]
  If Error Then
    If $bDebug Then Main.WriteDebugLog(LogLabel & "CommandClassId not found for device with address '" & sAddress & "', so I can't control it!")
    Return
  Else
    If $bDebug Then Main.WriteDebugLog(LogLabel & "CommandClassId for device with address '" & sAddress & "' is '" & iCommandClassId & "'.")

    If sCmd = "ON" Then
      iLevel = 255
    Else If sCmd = "OFF" Then
      iLevel = 0
    Else If InStr(sCmd, "DIM ") Then
      iLevel = Val(Replace(sCmd, "DIM ", ""))
      If iLevel = 100 Then iLevel = 99
    Else If InStr(sCmd, "SP ") Then
      fSetPoint = Val(Replace(sCmd, "SP ", ""))
    Else
      Main.WriteDebugLog(LogLabel & "Unknown command '" & sCmd & "' given!")
      Return
    Endif

    Select iCommandClassId
      Case 67
        QueueCommand(GetURL("/ZWaveAPI/Run/devices[" & aAddress[0] & "].instances[" & aAddress[1] & "].commandClasses[" & iCommandClassId & "].Set(1," & fSetPoint & ")"))
      Case Else
        QueueCommand(GetURL("/ZWaveAPI/Run/devices[" & aAddress[0] & "].instances[" & aAddress[1] & "].commandClasses[" & iCommandClassId & "].Set(" & iLevel & ")"))
    End Select
  Endif

End

'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
'
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Public Sub GetUpdates()

  Dim sUrl As String = GetURL("/ZWaveAPI/Data/" & $iUpdateTime)

  If $bDebug Then Main.WriteDebugLog(LogLabel & "Get update by fetching '" & sUrl & "'")
  QueueCommand(sUrl)

End

'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
' add command to queue
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Private Sub QueueCommand(sPacket As String)

  ' add command to queue
  cQueue.Add(sPacket, Rnd)

  ' if not busy process it
  If bHttpBusy = False Then DoQueue()

End

'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
' process items in queue
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Private Sub DoQueue()

  Dim sPacket As String

  For Each sPacket In cQueue
    WriteCommand(sPacket, cQueue.Key)
    Break ' only do first one
  Next

End

'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
'
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Private Sub WriteCommand(sWBuffer As String, sKey As String)

  hRaZberryCmd = New HttpClient As "hRaZberryCmd"
  hRaZberryCmd.URL = sWBuffer
  hRaZberryCmd.Async = True
  hRaZberryCmd.TimeOut = 3
  hRaZberryCmd.Tag = sKey
  hRaZberryCmd.Get
  bHttpBusy = True
  If $bDebug Then Main.WriteDebugLog(LogLabel & "Send HTTPGet request '" & sWBuffer & "'")

  IsRunning = True
  ErrorText = ""

Catch ' some errors
  Main.WriteLog(LogLabel & "ERROR: '" & Error.Text & "' at '" & Error.Where & "'")

  IsRunning = False
  ErrorText = Error.Text
  ErrorWhere = Error.Where

End

'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
' collect razberry data
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Public Sub hRaZberryCmd_Read()

  If Lof(Last) Then sBuffer &= Read #Last, Lof(Last)

End

'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
' razberry data fetched
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Public Sub hRaZberryCmd_Finished()

  Select hRaZberryCmd.Code
    Case 200
      ' too noisy
      If $bDebug Then Main.WriteDebugLog(LogLabel & "Received data '" & sBuffer & "'")
      ParseUpdateData(sBuffer)
    Case Else
      Main.WriteDebugLog(LogLabel & "Unknown error occured while trying to get RaZberry update data! HTTP=" & Last.Code & ", Buffer=" & sBuffer)
  End Select

  sBuffer = Null
  Try hRaZberryCmd.Close
  HttpBusy(hRaZberryCmd.Tag)

End

Public Sub hRaZberryCmd_Error()

  Dim sMsg As String

  If Not $bDebug Then Return

  sMsg = Log.Text_TCP_Error(Last.Status, $sTCPHost)
  Main.WriteLog(LogLabel & "ERROR: " & sMsg)

  IsRunning = False
  ErrorText = sMsg

  Log.Plugin_TCP_Error(LogLabel, $sTCPHost, Last.Status)
  HttpBusy(hRaZberryCmd.Tag)

End

'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
' http busy reset
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Public Sub HttpBusy(sKey As String)

  bHttpBusy = False
  ' remove sent command from queue
  cQueue.Remove(sKey)

  If cQueue.Count Then ' if there are more commands left in queue, send next one
    If $bDebug Then Main.WriteDebugLog(LogLabel & "Sending command from Queue (count = " & cQueue.Count & ")")
    DoQueue()
  Endif

End

'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
' Process Device Status update(s)
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Private Sub ParseUpdateData(sData As String)

  Dim cUpdate As JSONCollection

  If sData = "null" Then
    If $bDebug Then Main.WriteDebugLog(LogLabel & "Got a device control response.")
    Return
  Else
    cUpdate = JSON.Decode(sData, True)
  Endif

  If cUpdate Then
    $iUpdateTime = cUpdate["updateTime"]
    If $bDebug Then
      Main.WriteDebugLog(LogLabel & "Update Timestamp: " & Util.TimeSinceEpoch($iUpdateTime) & " (" & $iUpdateTime & ")")
    Endif
    If cUpdate.Count > 1 Then
      ParseUpdateDevices(cUpdate)
    Else
      If $bDebug Then Main.WriteDebugLog(LogLabel & "No updates reported.")
    Endif
  Else
    If $bDebug Then Main.WriteDebugLog(LogLabel & "Error received invalid JSON update data!")
  Endif

Catch ' some errors
  Main.WriteDebugLog(LogLabel & "ERROR: '" & Error.Text & "' at '" & Error.Where & "'")

End

'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
'
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Private Sub ParseUpdateDevices(cUpdates As JSONCollection)

  Dim cUpdate As New JSONCollection
  Dim aUpdate As String[]
  Dim vValue, vValue2, vValue3, vValue4, vValueTemp As Variant
  Dim sScale, sSensorType As String
  Dim iNode, iInstance, iBattery, iScale, iDeviceId As Integer

  If $bDebug Then Main.WriteDebugLog(LogLabel & "Found " & cUpdates.Count & " updates.")
  ' go through each update
  For Each cUpdate In cUpdates

    ' skip controller node
    aUpdate = Split(cUpdates.Key, ".")
    If aUpdate.Count > 1 Then
      If aUpdate[1] = $cZWaveNetwork["controller"]["controllerid"] Then 
        If $bDebug Then Main.WriteDebugLog(LogLabel & "Skipping controller node updates")
        Continue
      Endif

      ' search for interesting data
      ' battery value
      If InStr(cUpdates.Key, "commandClasses.128.data.last") Then
        aUpdate = Split(cUpdates.Key, ".")
        If aUpdate.Count = 8 Then
          iNode = aUpdate[1]
          iInstance = aUpdate[3]
          iBattery = cUpdate["value"]
          If $bDebug Then
            Main.WriteDebugLog(LogLabel & "Node: #" & iNode)
            Main.WriteDebugLog(LogLabel & "Instance: #" & iInstance)
            Main.WriteDebugLog(LogLabel & "Battery Value Update: " & iBattery)
          Endif
          ' update battery status
          iDeviceId = Devices.Find(Instance, iNode & IIf((iInstance > 1), ":" & iInstance, ""), InterfaceId)
          If iDeviceId Then
            Devices.Battery(iDeviceId, iBattery)
          Endif
        Else
          If $bDebug Then Main.WriteDebugLog(LogLabel & "Unknown update string: " & cUpdates.Key)
        Endif
      ' SP814 Motion sensor Everspring or old TKBHOME
      ' "devices.8.instances.0.commandClasses.48.data.1"
      Else If InStr(cUpdates.Key, "commandClasses.48.data.1") Then
        If aUpdate.Count = 8 Then
          vValue = IIf((cUpdate["level"]["value"] = True), "On", "Off")
          iNode = aUpdate[1]
          iInstance = aUpdate[3]
          iDeviceId = Devices.Find(Instance, iNode & IIf((iInstance > 1), ":" & iInstance, ""), InterfaceId)
          If iDeviceId Then
            Devices.ValueUpdate(iDeviceId, 1, vValue)
          Endif
        Else
          If $bDebug Then Main.WriteDebugLog(LogLabel & "Unknown update string: " & cUpdates.Key)
        Endif
      ' Everspring Flood Sensor ST812
      ' "devices.7.instances.0.commandClasses.156.data.5.sensorState"
      Else If InStr(cUpdates.Key, "commandClasses.156.data.5.sensorState") Then
        If aUpdate.Count = 9 Then
          vValue = IIf((cUpdate["value"] = 255), "On", "Off")
          iNode = aUpdate[1]
          iInstance = aUpdate[3]
          iDeviceId = Devices.Find(Instance, iNode & IIf((iInstance > 1), ":" & iInstance, ""), InterfaceId)
          If iDeviceId Then
            Devices.ValueUpdate(iDeviceId, 1, vValue)
          Endif
        Else
          If $bDebug Then Main.WriteDebugLog(LogLabel & "Unknown update string: " & cUpdates.Key)
        Endif
      ' sensor multilevel, but binary switch eg pir, d/w sensor
      ' "devices.8.instances.0.commandClasses.48.data.level"
      Else If InStr(cUpdates.Key, "commandClasses.48.data.level") Then
        aUpdate = Split(cUpdates.Key, ".")
        If aUpdate.Count = 8 Then
          iNode = aUpdate[1]
          iInstance = aUpdate[3]

          If $bDebug Then
            Main.WriteDebugLog(LogLabel & "Node: #" & iNode)
            Main.WriteDebugLog(LogLabel & "Instance: #" & iInstance)
            Main.WriteDebugLog(LogLabel & "Sensor Multilevel Binary Value1 Update: " & vValue)
          Endif
          vValue = IIf((cUpdate["value"] = True), "Open", "Closed")
          ' update device value(s)
          iDeviceId = Devices.Find(Instance, iNode & IIf((iInstance > 1), ":" & iInstance, ""), InterfaceId)
          If iDeviceId Then
            Devices.ValueUpdate(iDeviceId, 1, vValue)
          Endif
        Else
          If $bDebug Then Main.WriteDebugLog(LogLabel & "Unknown update string: " & cUpdates.Key)
        Endif
      ' binary switch device
      Else If InStr(cUpdates.Key, "commandClasses.37.data.level") Then
        aUpdate = Split(cUpdates.Key, ".")
        If aUpdate.Count = 8 Then
          iNode = aUpdate[1]
          iInstance = aUpdate[3]
          vValue = IIf((cUpdate["value"] = 255) Or (cUpdate["value"] = True), "On", "Off")
          If $bDebug Then
            Main.WriteDebugLog(LogLabel & "Node: #" & iNode)
            Main.WriteDebugLog(LogLabel & "Instance: #" & iInstance)
            Main.WriteDebugLog(LogLabel & "Switch Value1 Update: " & vValue)
          Endif
          ' update device value(s)
          iDeviceId = Devices.Find(Instance, iNode & IIf((iInstance > 1), ":" & iInstance, ""), InterfaceId)
          If iDeviceId Then
            Devices.ValueUpdate(iDeviceId, 1, vValue)
          Endif
        Else
          If $bDebug Then Main.WriteDebugLog(LogLabel & "Unknown update string: " & cUpdates.Key)
        Endif
      ' dimmer device
      Else If InStr(cUpdates.Key, "commandClasses.38.data.level") Then
        aUpdate = Split(cUpdates.Key, ".")
        If aUpdate.Count = 8 Then
          iNode = aUpdate[1]
          iInstance = aUpdate[3]
          vValue = "Dim " & cUpdate["value"]
          If vValue = "Dim 99" Then vValue = "On"
          If vValue = "Dim 0" Then vValue = "Off"
          If $bDebug Then
            Main.WriteDebugLog(LogLabel & "Node: #" & iNode)
            Main.WriteDebugLog(LogLabel & "Instance: #" & iInstance)
            Main.WriteDebugLog(LogLabel & "Dimmer Value1 Update: " & vValue)
          Endif
          ' update device value(s)
          iDeviceId = Devices.Find(Instance, iNode & IIf((iInstance > 1), ":" & iInstance, ""), InterfaceId)
          If iDeviceId Then
            Devices.ValueUpdate(iDeviceId, 1, vValue)
          Endif
        Else
          If $bDebug Then Main.WriteDebugLog(LogLabel & "Unknown update string: " & cUpdates.Key)
        Endif
      ' multilevel sensor
      Else If InStr(cUpdates.Key, "commandClasses.49.data.level") Then
        aUpdate = Split(cUpdates.Key, ".")
        If aUpdate.Count = 8 Then
          iNode = aUpdate[1]
          iInstance = aUpdate[3]
          vValue = cUpdate["val"]["value"]
          If $bDebug Then
            Main.WriteDebugLog(LogLabel & "Node: #" & iNode)
            Main.WriteDebugLog(LogLabel & "Instance: #" & iInstance)
            Main.WriteDebugLog(LogLabel & "Multilevel Sensor Value1 Update: " & vValue)
          Endif
          ' update device value(s)
          iDeviceId = Devices.Find(Instance, iNode & IIf((iInstance > 1), ":" & iInstance, ""), InterfaceId)
          If iDeviceId Then
            Devices.ValueUpdate(iDeviceId, 1, vValue)
          Endif
        Else
          If $bDebug Then Main.WriteDebugLog(LogLabel & "Unknown update string: " & cUpdates.Key)
        Endif
      ' thermostat
      Else If InStr(cUpdates.Key, "commandClasses.67.data.")
        aUpdate = Split(cUpdates.Key, ".")
        If aUpdate.Count = 8 Then
           iNode = aUpdate[1]
           iInstance = aUpdate[3]
           If cUpdate["setVal"]["value"] Then vValue2 = cUpdate["setVal"]["value"]
           If $bDebug Then
            Main.WriteDebugLog(LogLabel & "Node: #" & iNode)
            Main.WriteDebugLog(LogLabel & "Instance: #" & iInstance)
            Main.WriteDebugLog(LogLabel & "Thermostat Value2 (setVal) Update: " & vValue2)
          Endif
          ' update device value(s)
          iDeviceId = Devices.Find(Instance, iNode & IIf((iInstance), ":" & iInstance, ""), InterfaceId)
          If iDeviceId Then
            'Devices.ValueUpdate(iDeviceId, 1, vValue)
            Devices.ValueUpdate(iDeviceId, 2, vValue2)
          Endif
        Else
          If $bDebug Then Main.WriteDebugLog(LogLabel & "Unknown update string: " & cUpdates.Key)
        Endif
      ' "devices.3.instances.0.commandClasses.49.data.4"
       Else If InStr(cUpdates.Key, "commandClasses.49.data.") Then
        aUpdate = Split(cUpdates.Key, ".")
        If aUpdate.Count = 8 Then
          iNode = aUpdate[1]
          iInstance = aUpdate[3]
          iScale = aUpdate[7]
          sScale = cUpdate["scaleString"]["value"]
          sSensorType = Trim(cUpdate["sensorTypeString"]["value"])
          vValueTemp = cUpdate["val"]["value"]
          If iScale = 4 Then
            ' W value4
            vValue4 = vValueTemp
          Endif
          If $bDebug Then
            Main.WriteDebugLog(LogLabel & "Node: #" & iNode)
            Main.WriteDebugLog(LogLabel & "Instance: #" & iInstance)
            Main.WriteDebugLog(LogLabel & "Scale: " & iScale)
            Main.WriteDebugLog(LogLabel & "Type: " & sSensorType)
            If iScale = 4 Then Main.WriteDebugLog(LogLabel & "Power Sensor value4 Update: " & vValue4 & sScale)
          Endif
          iDeviceId = Devices.Find(Instance, iNode & IIf((iInstance > 1), ":" & iInstance, ""), InterfaceId)
          If iDeviceId Then
            Devices.ValueUpdate(iDeviceId, 1, vValue)
            Devices.ValueUpdate(iDeviceId, 2, vValue2)
            Devices.ValueUpdate(iDeviceId, 3, vValue3)
            Devices.ValueUpdate(iDeviceId, 4, vValue4)
          Endif
        Else
          If $bDebug Then Main.WriteDebugLog(LogLabel & "Unknown update string: " & cUpdates.Key)
        Endif
      ' meter device
      ' "devices.5.instances.1.commandClasses.50.data.2"
      Else If InStr(cUpdates.Key, "commandClasses.50.data.") Then
        aUpdate = Split(cUpdates.Key, ".")
        If aUpdate.Count = 8 Then
          iNode = aUpdate[1]
          iInstance = aUpdate[3]
          iScale = aUpdate[7]
          sScale = cUpdate["scaleString"]["value"]
          sSensorType = Trim(cUpdate["sensorTypeString"]["value"])
          vValueTemp = cUpdate["val"]["value"]
          If iScale = 0 Then
            ' KwH value3
            vValue3 = vValueTemp
          Else If iScale = 2 Then
            ' W value2
            vValue2 = vValueTemp
          Endif
          If $bDebug Then
            Main.WriteDebugLog(LogLabel & "Node: #" & iNode)
            Main.WriteDebugLog(LogLabel & "Instance: #" & iInstance)
            Main.WriteDebugLog(LogLabel & "Scale: " & iScale)
            Main.WriteDebugLog(LogLabel & "Type: " & sSensorType)
            If iScale = 2 Then Main.WriteDebugLog(LogLabel & "Sensor Multilevel Binary Value2 Update: " & vValue2 & sScale)
            If iScale = 0 Then Main.WriteDebugLog(LogLabel & "Sensor Multilevel Binary Value3 Update: " & vValue3 & sScale)
          Endif
          ' update device value(s)
          iDeviceId = Devices.Find(Instance, iNode & IIf((iInstance > 1), ":" & iInstance, ""), InterfaceId)
          If iDeviceId Then
            Devices.ValueUpdate(iDeviceId, 1, vValue)
            Devices.ValueUpdate(iDeviceId, 2, vValue2)
            Devices.ValueUpdate(iDeviceId, 3, vValue3)
          Endif
        Else
          If $bDebug Then Main.WriteDebugLog(LogLabel & "Unknown update string: " & cUpdates.Key)
        Endif
      Endif
      ' TODO: add commandClass 98

      ' clear stuff
      vValue = ""
      vValue2 = ""
      vValue3 = ""
      vValue4 = ""
      vValueTemp = ""
    Endif
  Next

Catch ' some errors
  If Error.code <> 6 Then ' suppress reading updatetime as collection
    Main.WriteDebugLog(LogLabel & "ERROR: '" & Error.Text & "' at '" & Error.Where & "' " & Error.Code)
  Else
    Error.Clear
  Endif

End

'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
' disconnect from the host
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Public Function Disconnect() As Boolean

  ' try to stop timer
  Try tRaZberry.Stop
  ' try to close all connections
  Try hRaZberryInit.Close
  Try hRaZberryCmd.Close

  Main.WriteLog(LogLabel & PluginFriendlyName & " closed.")

  ' all ok
  Return True

Finally
  IsRunning = False
  ErrorText = ""
  ErrorWhere = ""

Catch
  Main.WriteLog(LogLabel & "ERROR: " & Error.Text)
  Return False

End

'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
' Display Z-Wave BasicType name
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Private Sub GetBasicTypeName(iBasic As Integer) As String

  Select iBasic
    Case BASIC_TYPE_CONTROLLER
      Return "Controller"
    Case BASIC_TYPE_STATIC_CONTROLLER
      Return "Static Controller"
    Case BASIC_TYPE_SLAVE
      Return "Slave"
    Case BASIC_TYPE_ROUTING_SLAVE
      Return "Routing Slave"
    Default
      Return "Unknown (" & iBasic & ")"
  End Select

End

'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
' Display Z-Wave GenericType name
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Private Sub GetGenericTypeName(iGeneric As Integer) As String

  Return GetSpecificTypeName(iGeneric, 0)

End

'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
' Display Z-Wave SpecificType name
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Private Sub GetSpecificTypeName(iGenericType As Integer, iSpecificType As Integer) As String

  Select iGenericType 
    Case GENERIC_TYPE_GENERIC_CONTROLLER
      Select iSpecificType
        Case &H01
          Return "Portable Remote Controller"
        Case &H02
          Return "Portable Scene Controller"
        Case &H03
          Return "Portable Installer Tool"
      End Select
      Return "Generic Controller"
    Case GENERIC_TYPE_STATIC_CONTROLLER
      Select iSpecificType
        Case &H01
          Return "Static PC Controller"
        Case &H02
          Return "Static Scene Controller"
        Case &H03
          Return "Static Installer Tool"
      End Select
      Return "Static Controller"
    Case GENERIC_TYPE_AV_CONTROL_POINT
      Select iSpecificType
        Case &H04
          Return "Satellite Receiver"
        Case &H11
          Return "Satellite Receiver V2"
        Case &H12
          Return "Doorbell"
      End Select
      Return "AV Control Point"
    Case GENERIC_TYPE_DISPLAY
      Select iSpecificType
        Case &H01
          Return "Simple Display"
      End Select
      Return "Display"
    Case GENERIC_TYPE_THERMOSTAT
      Select iSpecificType
        Case &H01
          Return "Heating Thermostat"
        Case &H02
          Return "General Thermostat"
        Case &H03
          Return "Setback Schedule Thermostat"
        Case &H04
          Return "Setpoint Thermostat"
        Case &H05
          Return "Setback Thermostat"
        Case &H06
          Return "General Thermostat V2"
      End Select
      Return "Thermostat"
    Case GENERIC_TYPE_WINDOW_COVERING
      Select iSpecificType
        Case &H01
          Return "Simple Window Covering"
      End Select
      Return "Window Covering"
    Case GENERIC_TYPE_REPEATER_SLAVE
      Select iSpecificType
        Case &H01
          Return "Basic Repeater Slave"
      End Select
      Return "Repeating Slave"
    Case GENERIC_TYPE_SWITCH_BINARY
      Select iSpecificType
        Case &H01
          Return "Binary Power Switch"
        Case &H03
          Return "Binary Scene Switch"
      End Select
      Return "Binary Switch"
    Case GENERIC_TYPE_SWITCH_MULTILEVEL
      Select iSpecificType
        Case &H01
          Return "Multilevel Power Switch"
        Case &H03
          Return "Multiposition Motor"
        Case &H04
          Return "Multilevel Scene Switch"
        Case &H05
          Return "Motor Control Class A"
        Case &H06
          Return "Motor Control Class B"
        Case &H07
          Return "Motor Control Class C"
      End Select
      Return "Multilevel Switch"
    Case GENERIC_TYPE_SWITCH_REMOTE
      Select iSpecificType
        Case &H01
          Return "Binary Remote Switch"
        Case &H02
          Return "Multilevel Remote Switch"
        Case &H03
          Return "Binary Toggle Remote Switch"
        Case &H04
          Return "Multilevel Toggle Remote Switch"
      End Select
      Return "Remote Switch"
    Case GENERIC_TYPE_SWITCH_TOGGLE
      Select iSpecificType
        Case &H01
          Return "Binary Toggle Switch"
        Case &H02
          Return "Multilevel Toggle Switch"
      End Select
      Return "Toggle Switch"
    Case GENERIC_TYPE_ZIP_GATEWAY
      Select iSpecificType
        Case &H01
          Return "Z/IP Tunneling Gateway"
        Case &H02
          Return "Z/IP Advanced Gateway"
      End Select
      Return "Zip Gateway"
    Case GENERIC_TYPE_ZIP_NODE
      Select iSpecificType
        Case &H01
          Return "Z/IP Tunneling Node"
        Case &H02
          Return "Z/IP Advanced Node"
      End Select
      Return "Zip Node"
    Case GENERIC_TYPE_VENTILATION
      Select iSpecificType
        Case &H01
          Return "Residential Heat Recovery Ventilation"
      End Select
      Return "Ventilation"
    Case GENERIC_TYPE_SENSOR_BINARY
      Select iSpecificType
        Case &H01
          Return "Routing Binary Sensor"
      End Select
      Return "Binary Sensor"
    Case GENERIC_TYPE_SENSOR_MULTILEVEL
      Select iSpecificType
        Case &H01
          Return "Routing Multilevel Sensor"
      End Select
      Return "Multilevel Sensor"
    Case GENERIC_TYPE_METER_PULSE
      Return "Pulse Meter"
    Case GENERIC_TYPE_METER
      Select iSpecificType
        Case &H01
          Return "Simple Meter"
      End Select
      Return "Meter"
    Case GENERIC_TYPE_ENTRY_CONTROL
      Select iSpecificType
        Case &H01
          Return "Door Lock"
        Case &H02
          Return "Advanced Door Lock"
        Case &H03
          Return "Secure Keypad Door Lock"
      End Select
      Return "Entry Control"
    Case GENERIC_TYPE_SEMI_INTEROPERABLE
      Select iSpecificType
        Case &H01
          Return "Energy Production"
      End Select
      Return "Semi Interoperable"
    Case GENERIC_TYPE_SENSOR_ALARM
      Select iSpecificType
        Case &H01
          Return "Basic Routing Alarm Sensor"
        Case &H02
          Return "Routing Alarm Sensor"
        Case &H03
          Return "Basic Zensor Alarm Sensor"
        Case &H04
          Return "Zensor Alarm Sensor"
        Case &H05
          Return "Advanced Zensor Alarm Sensor"
        Case &H06
          Return "Basic Routing Smoke Sensor"
        Case &H07
          Return "Routing Smoke Sensor"
        Case &H08
          Return "Basic Zensor Smoke Sensor"
        Case &H09
          Return "Zensor Smoke Sensor"
        Case &H0A
          Return "Advanced Zensor Smoke Sensor"
      End Select
      Return "Alarm Sensor"
    Case GENERIC_TYPE_NON_INTEROPERABLE
      Return "Non Interoperable"
    Default
      Return "Unknown (" & iGenericType & ")"
  End Select

End

