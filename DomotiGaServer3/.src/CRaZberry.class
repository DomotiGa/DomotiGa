' Gambas class file

' Description:
' CRaZberry.class
' Provide support for RaZberry Z-Wave interface.
'
' Supported CommandClasses:
' - Switch Binary (37)
' - Switch Multilevel (38)
' - Sensor Binary (48)
' - Sensor Multilevel (49)
' - Meter (50)
' - SetPoint (67)
' - Door Lock (98)
' - Battery (128)
' - Sensor Alarm (156)

' Development Status:
' Working

' DomotiGa - an open source home automation program.
' Copyright (C) Ron Klinkien, The Netherlands.

' Read file called COPYING for license details.

'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
' Module/Class specific variables
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Public PluginName As String = "RaZberry"
Public PluginFriendlyName As String = "RaZberry Z-Wave"
Public PluginVersion As String = "1.10"
Public PluginAuthor As String = "Ron Klinkien"
Public PluginProtocols As String[]
Public PluginMaxInstances As Integer = 1

Public KeyName As String
Public LogLabel As String = "[RaZberry] "
Public InterfaceId As Integer
Public Instance As Integer
Public IsRunning As Boolean
Public ErrorText As String
Public ErrorWhere As String

'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
' Private Variables
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Private $bEnabled As Boolean
Private $sTCPHost As String
Private $iTCPPort As Integer
Private $sUsername As String
Private $sPassword As String
Private $iPollTime As Integer
Private $bLegacy As Boolean
Private $bDebug As Boolean

' RaZberry controller and network information
Private $cZWaveNetwork As New JSONCollection

Public hRaZberryInit As HttpClient
Public hRaZberryCmd As HttpClient
Public bInit As Boolean
Public $iUpdateTime As Integer
Public $iNewUpdateTime As Integer
Public sBuffer As String
Public tRaZberry As Timer

' queue and command buffer stuff
Private cQueue As New Collection   ' command buffer
Private bHttpBusy As Boolean       ' already fetching?

'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
' Z-Wave Constants
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Private Const BASIC_TYPE_CONTROLLER As Byte = &H01
Private Const BASIC_TYPE_STATIC_CONTROLLER As Byte = &H02
Private Const BASIC_TYPE_SLAVE As Byte = &H03
Private Const BASIC_TYPE_ROUTING_SLAVE As Byte = &H04

Private Const GENERIC_TYPE_GENERIC_CONTROLLER As Byte = &H01
Private Const GENERIC_TYPE_STATIC_CONTROLLER As Byte = &H02
Private Const GENERIC_TYPE_AV_CONTROL_POINT As Byte = &H03
Private Const GENERIC_TYPE_DISPLAY As Byte = &H04
Private Const GENERIC_TYPE_THERMOSTAT As Byte = &H08
Private Const GENERIC_TYPE_WINDOW_COVERING As Byte = &H09
Private Const GENERIC_TYPE_REPEATER_SLAVE As Byte = &H0F
Private Const GENERIC_TYPE_SWITCH_BINARY As Byte = &H10
Private Const GENERIC_TYPE_SWITCH_MULTILEVEL As Byte = &H11
Private Const GENERIC_TYPE_SWITCH_REMOTE As Byte = &H12
Private Const GENERIC_TYPE_SWITCH_TOGGLE As Byte = &H13
Private Const GENERIC_TYPE_ZIP_GATEWAY As Byte = &H14
Private Const GENERIC_TYPE_ZIP_NODE As Byte = &H15
Private Const GENERIC_TYPE_VENTILATION As Byte = &H16
Private Const GENERIC_TYPE_SENSOR_BINARY As Byte = &H20
Private Const GENERIC_TYPE_SENSOR_MULTILEVEL As Byte = &H21
Private Const GENERIC_TYPE_METER_PULSE As Byte = &H30
Private Const GENERIC_TYPE_METER As Byte = &H31
Private Const GENERIC_TYPE_ENTRY_CONTROL As Byte = &H40
Private Const GENERIC_TYPE_SEMI_INTEROPERABLE As Byte = &H50
Private Const GENERIC_TYPE_SENSOR_ALARM As Byte = &HA1
Private Const GENERIC_TYPE_NON_INTEROPERABLE As Byte = &HFF

Private Const COMMAND_CLASS_NO_OPERATION As Byte = &H00 ' 0
Private Const COMMAND_CLASS_BASIC As Byte = &H20 ' 32
Private Const COMMAND_CLASS_CONTROLLER_REPLICATION As Byte = &H21 ' 33
Private Const COMMAND_CLASS_APPLICATION_STATUS As Byte = &H22 ' 34
Private Const COMMAND_CLASS_ZIP_SERVICES As Byte = &H23 ' 35
Private Const COMMAND_CLASS_ZIP_SERVER As Byte = &H24 ' 36
Private Const COMMAND_CLASS_SWITCH_BINARY As Byte = &H25 ' 37
Private Const COMMAND_CLASS_SWITCH_MULTILEVEL As Byte = &H26 ' 38
Private Const COMMAND_CLASS_SWITCH_ALL As Byte = &H27 ' 39
Private Const COMMAND_CLASS_SWITCH_TOGGLE_BINARY As Byte = &H28 ' 40
Private Const COMMAND_CLASS_SWITCH_TOGGLE_MULTILEVEL As Byte = &H29 ' 41
Private Const COMMAND_CLASS_CHIMNEY_FAN As Byte = &H2A ' 42
Private Const COMMAND_CLASS_SCENE_ACTIVATION As Byte = &H2B ' 43
Private Const COMMAND_CLASS_SCENE_ACTUATOR_CONF As Byte = &H2C ' 44
Private Const COMMAND_CLASS_SCENE_CONTROLLER_CONF As Byte = &H2D ' 45
Private Const COMMAND_CLASS_ZIP_CLIENT As Byte = &H2E ' 46
Private Const COMMAND_CLASS_ZIP_ADV_SERVICES As Byte = &H2F ' 47
Private Const COMMAND_CLASS_SENSOR_BINARY As Byte = &H30 ' 48
Private Const COMMAND_CLASS_SENSOR_MULTILEVEL As Byte = &H31 ' 49
Private Const COMMAND_CLASS_METER As Byte = &H32 ' 50
Private Const COMMAND_CLASS_ZIP_ADV_SERVER As Byte = &H33 ' 51
Private Const COMMAND_CLASS_ZIP_ADV_CLIENT As Byte = &H34 ' 52
Private Const COMMAND_CLASS_METER_PULSE As Byte = &H35 ' 53
Private Const COMMAND_CLASS_THERMOSTAT_HEATING As Byte = &H38 ' 56
Private Const COMMAND_CLASS_THERMOSTAT_MODE As Byte = &H40 ' 64
Private Const COMMAND_CLASS_THERMOSTAT_OPERATING_STATE As Byte = &H42 ' 66
Private Const COMMAND_CLASS_THERMOSTAT_SETPOINT As Byte = &H43 ' 67
Private Const COMMAND_CLASS_THERMOSTAT_FAN_MODE As Byte = &H44 ' 68
Private Const COMMAND_CLASS_THERMOSTAT_FAN_STATE As Byte = &H45 ' 69
Private Const COMMAND_CLASS_CLIMATE_CONTROL_SCHEDULE As Byte = &H46 ' 70
Private Const COMMAND_CLASS_THERMOSTAT_SETBACK As Byte = &H47 ' 71
Private Const COMMAND_CLASS_DOOR_LOCK_LOGGING As Byte = &H4C ' 76
Private Const COMMAND_CLASS_SCHEDULE_ENTRY_LOCK As Byte = &H4E ' 78
Private Const COMMAND_CLASS_BASIC_WINDOW_COVERING As Byte = &H50 ' 80
Private Const COMMAND_CLASS_MTP_WINDOW_COVERING As Byte = &H51 ' 81
Private Const COMMAND_CLASS_CRC_16_ENCAP As Byte = &H56 ' 86
Private Const COMMAND_CLASS_ASSOCIATION_GROUP_INFORMATION As Byte = &H59 ' 89
Private Const COMMAND_CLASS_DEVICE_RESET_LOCALLY As Byte = &H5A ' 90
Private Const COMMAND_CLASS_CENTRAL_SCENE As Byte = &H5B ' 91
Private Const COMMAND_CLASS_ZWAVE_PLUS As Byte = &H5E ' 94
Private Const COMMAND_CLASS_MULTI_INSTANCE As Byte = &H60 ' 96
Private Const COMMAND_CLASS_DOOR_LOCK As Byte = &H62 ' 98
Private Const COMMAND_CLASS_USER_CODE As Byte = &H63 ' 99
Private Const COMMAND_CLASS_CONFIGURATION As Byte = &H70 ' 112
Private Const COMMAND_CLASS_ALARM As Byte = &H71 ' 113
Private Const COMMAND_CLASS_MANUFACTURER_SPECIFIC As Byte = &H72 ' 114
Private Const COMMAND_CLASS_POWERLEVEL As Byte = &H73 ' 115
Private Const COMMAND_CLASS_PROTECTION As Byte = &H75 ' 117
Private Const COMMAND_CLASS_LOCK As Byte = &H76 ' 118
Private Const COMMAND_CLASS_NODE_NAMING As Byte = &H77 ' 119
Private Const COMMAND_CLASS_FIRMWARE_UPDATE_MD As Byte = &H7A ' 122
Private Const COMMAND_CLASS_GROUPING_NAME As Byte = &H7B ' 123
Private Const COMMAND_CLASS_REMOTE_ASSOCIATION_ACTIVATE As Byte = &H7C ' 124
Private Const COMMAND_CLASS_REMOTE_ASSOCIATION As Byte = &H7D ' 125
Private Const COMMAND_CLASS_BATTERY As Byte = &H80 ' 128
Private Const COMMAND_CLASS_CLOCK As Byte = &H81 ' 129
Private Const COMMAND_CLASS_HAIL As Byte = &H82 ' 130
Private Const COMMAND_CLASS_WAKE_UP As Byte = &H84 ' 132
Private Const COMMAND_CLASS_ASSOCIATION As Byte = &H85 ' 133
Private Const COMMAND_CLASS_VERSION As Byte = &H86 ' 134
Private Const COMMAND_CLASS_INDICATOR As Byte = &H87 ' 135
Private Const COMMAND_CLASS_PROPRIETARY As Byte = &H88 ' 136
Private Const COMMAND_CLASS_LANGUAGE As Byte = &H89 ' 137
Private Const COMMAND_CLASS_TIME As Byte = &H8A ' 138
Private Const COMMAND_CLASS_TIME_PARAMETERS As Byte = &H8B ' 139
Private Const COMMAND_CLASS_GEOGRAPHIC_LOCATION As Byte = &H8C ' 140
Private Const COMMAND_CLASS_COMPOSITE As Byte = &H8D ' 141
Private Const COMMAND_CLASS_MULTI_INSTANCE_ASSOCIATION As Byte = &H8E ' 142
Private Const COMMAND_CLASS_MULTI_CMD As Byte = &H8F ' 143
Private Const COMMAND_CLASS_ENERGY_PRODUCTION As Byte = &H90 ' 144
Private Const COMMAND_CLASS_MANUFACTURER_PROPRIETARY As Byte = &H91 ' 145
Private Const COMMAND_CLASS_SCREEN_MD As Byte = &H92 ' 146
Private Const COMMAND_CLASS_SCREEN_ATTRIBUTES As Byte = &H93 ' 147
Private Const COMMAND_CLASS_SIMPLE_AV_CONTROL As Byte = &H94 ' 148
Private Const COMMAND_CLASS_AV_CONTENT_DIRECTORY_MD As Byte = &H95 ' 149
Private Const COMMAND_CLASS_AV_RENDERER_STATUS As Byte = &H96 ' 150
Private Const COMMAND_CLASS_AV_CONTENT_SEARCH_MD As Byte = &H97 ' 151
Private Const COMMAND_CLASS_SECURITY As Byte = &H98 ' 152
Private Const COMMAND_CLASS_AV_TAGGING_MD As Byte = &H99 ' 153
Private Const COMMAND_CLASS_IP_CONFIGURATION As Byte = &H9A ' 154
Private Const COMMAND_CLASS_ASSOCIATION_COMMAND_CONFIGURATION As Byte = &H9B ' 155
Private Const COMMAND_CLASS_SENSOR_ALARM As Byte = &H9C ' 156
Private Const COMMAND_CLASS_SILENCE_ALARM As Byte = &H9D ' 157
Private Const COMMAND_CLASS_SENSOR_CONFIGURATION As Byte = &H9E ' 158
Private Const COMMAND_CLASS_MARK As Byte = &HEF ' 239
Private Const COMMAND_CLASS_NON_INTEROPERABLE As Byte = &HF0 ' 240

'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
' Mandatory subroutine for each Module/Class to initialize:
' - The cPlugin[x].Settings are copied into local variables
' - Port/Connection will be started (any errors caught)
' - Any other code per Class
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Public Sub StartPlugin(cPl As CPluginEntry)

  KeyName = cPl.KeyName
  Instance = cPl.Instance
  If Instance <> 1 Then LogLabel = Replace(LogLabel, "] ", "#" & Instance & "] ")

  ' Copy configuration items locally
  $bEnabled = cPl.Settings["enabled"]
  $sTCPHost = cPl.Settings["tcphost"]
  $iTCPPort = cPl.Settings["tcpport"]
  $sUsername = cPl.Settings["username"]
  $sPassword = cPl.Settings["password"]
  $iPollTime = cPl.Settings["polltime"]
  $bDebug = cPl.Settings["debug"]

  If cPl.Settings.Exist("legacy") Then
    $bLegacy = cPl.Settings["legacy"]
  Else
    $bLegacy = True
  Endif

  InterfaceId = Devices.FindInterface("RaZberry Z-Wave Interface")
  If InterfaceId = 0 Then
    ErrorText = "Required InterfaceId can't be retrieved from the database!"
    Main.WriteLog(LogLabel & "ERROR: " & ErrorText)
    IsRunning = False
    Return
  Endif

  ' Connect/Initialize connection 
  Run()

End

'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
' Mandatory sub for each Module/Class to stop
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Public Sub StopPlugin()

  Try Disconnect()

End

'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
' init
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Private Sub Run()

  bInit = True
  Initialize()

  ' define poll timer
  tRaZberry = New Timer As "tRaZberry"
  tRaZberry.Delay = $iPollTime * 1000 ' multiply for seconds
  tRaZberry.Stop

  Main.WriteLog(LogLabel & PluginFriendlyName & " initializing.")

  ' all ok
  IsRunning = True

Catch
  Main.WriteLog(LogLabel & "ERROR: " & PluginFriendlyName & " FAILED to initialize")
  Main.WriteLog(LogLabel & "ERROR: " & Error.Text)
  IsRunning = False
  ErrorText = Error.Text
  ErrorWhere = Error.Where

  IsRunning = False

End

Public Sub tRaZberry_Timer()

  GetUpdates()

End

'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
'
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Private Sub GetURL(sCmd As String) As String

  If $sUsername And If $sPassword Then
    Return "http://" & $sUsername & ":" & $sPassword & "@" & $sTCPHost & ":" & $iTCPPort & sCmd
  Else
    Return "http://" & $sTCPHost & ":" & $iTCPPort & sCmd
  Endif

End

'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
'
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Private Sub Initialize() As Boolean

  Dim sURL As String = GetURL("/ZWaveAPI/Data/" & $iUpdateTime)
  Dim sFile As String = Main.sBaseDir &/ "razberry.log"

  ' for development/debugging only
  If Exist(sFile) And If $bDebug Then
    If $bDebug Then Main.WriteDebugLog(LogLabel & "Initializing data read from file '" & sFile & "'")
    sBuffer = File.Load(sFile)
    ParseRaZberryData(sBuffer)
    sBuffer = Null
    Return
  Endif

  If $bDebug Then Main.WriteDebugLog(LogLabel & "Initializing data by fetching '" & sURL & "'")

  hRaZberryInit = New HttpClient As "hRaZberryInit"
  hRaZberryInit.URL = sURL
  hRaZberryInit.Async = True
  hRaZberryInit.TimeOut = 3
  hRaZberryInit.Post("application/json", "")

Catch ' some errors
  Main.WriteLog(LogLabel & "ERROR: '" & Error.Text & "' at '" & Error.Where & "'")

End

'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
' save init json to log file
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Public Sub WriteJSON(sData As String)

  Dim sFile As String = Main.sBaseDir &/ "logs" &/ "razberry.log"
  Dim hFile As File

  If $bDebug Then Main.WriteDebugLog(LogLabel & "Writing Initializing data to file '" & sFile & "'")
  hFile = Open sFile For Create
  Write #hFile, sData
  Close #hFile

Catch ' some errors
  Main.WriteLog(LogLabel & "ERROR: '" & Error.Text & "' at '" & Error.Where & "'")

End

'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
' collect razberry data
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Public Sub hRaZberryInit_Read()

  If Lof(Last) Then sBuffer &= Read #Last, Lof(Last)

End

'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
' razberry data fetched
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Public Sub hRaZberryInit_Finished()

  Select hRaZberryInit.Code
    Case 200
      ' too noisy
      ' If $bDebug Then Main.WriteDebugLog(LogLabel & "Received '" & sBuffer & "'")
      ParseRaZberryData(sBuffer)
      If $bDebug Then WriteJSON(sBuffer)
    Case Else
      Main.WriteDebugLog(LogLabel & "Unknown error occured while trying to get razberry init data! HTTP=" & Last.Code & ", Buffer=" & sBuffer)
  End Select

  sBuffer = Null
  Try hRaZberryInit.Close

End

'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
' Handle error
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Public Sub hRaZberryInit_Error()

  Log.Plugin_CURL_Error(LogLabel, $sTCPHost, Last.Status)
  sBuffer = Null

End

'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
' Parse Controller Z-Way data
' It is called for Initialization and Updates
' If controller is changed, we get all the controller information again
' If node(s) are added/updated/removed, we get all the node information again
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Private Sub ParseRaZberryData(sData As String)

  Dim cData As JSONCollection
  Dim aUpdate As New String[]
  Dim iNodeId As Integer

  Try cData = JSON.Decode(sData, True) 
  If Error Then
    Main.WriteLog(LogLabel & "ERROR: During decoding JSON data!")
    Return
  Endif

  ' Check if we got 
  If Not cData Then
    Main.WriteLog(LogLabel & "ERROR: Received invalid JSON data!")
    Return
  Endif

  If Not cData.Exist("updateTime") Then
    Main.WriteLog(LogLabel & "ERROR: Didn't receive mandatory 'updateTime' in JSON data!")
    Return
  Endif

  $iNewUpdateTime = cData["updateTime"]

  For Each cData

    If cData.Key = "updateTime" Then
    Else If cData.Key = "controller" Then
      ' If we received new/update controller information, process it
      ParseControllerInfo(cData["controller"])
    Else If cData.Key = "devices" Then 
      ' If we received new/update node(s) information, process it
      ParseDeviceInfo(cData["devices"])
    Else If InStr(cData.Key, ".") Then
      ' This looks to be an update request, split it in an useable array
      aUpdate = Split(cData.Key, ".")

      ' Possible formats:
      ' controller.data.controllerState
      ' devices.6.data.genericType
      ' devices.5.instances.1.commandClasses.37.data.level
      ' devices.8.instances.0.commandClasses.48.data.1
      ' devices.5.instances.1.commandClasses.50.data.2
      ' devices.7.instances.0.commandClasses.156.data.5.sensorState

      Select aUpdate[0]
        Case "controller"
          ' We ignore controller updates
        Case "devices"

          If aUpdate.Count >= 4 Then
            ' Retrieve NodeId
            Try iNodeId = aUpdate[1]
            If Error Then
              Main.WriteLog(LogLabel & "ERROR: Skipping device, unable to detect Z-Wave NodeId '" & aUpdate[1] & "'")
              Continue
            Endif

            ' Only allow valid Z-Wave NodeIds
            If iNodeId < 1 Or If iNodeId > 232 Then
              Main.WriteLog(LogLabel & "ERROR: Skipping device, invalid Z-Wave NodeId '" & iNodeId & "'")
              Continue
            Endif

            ' Lets check if the node is known by us, else there is a discover problem
            If Not $cZWaveNetwork.Exist(iNodeId) Then
              Main.WriteLog(LogLabel & "ERROR: Skipping device, Z-Wave NodeId '" & iNodeId & "' unknown in our list")
              Continue
            Endif

            ' Device Node Info Update, can happen for sleeping device after inclusion
            If aUpdate[2] = "data" Then
              UpdateNodeInfo(aUpdate[3], cData[cData.Key], $cZWaveNetwork[iNodeId])
            Else
            Endif

          Endif

        Default
          ' Unknown update
      End Select

    Else
      ' Unknown update field
      If $bDebug Then Main.WriteDebugLog(LogLabel & "ERROR: Unknown Update key '" & cData.Key & "' received")
    Endif
  Next

  ' Finally update to our latest timestamp
  ' we don 't want to do it earlier, because if an error happens, we loose track of changes
  $iUpdateTime = $iNewUpdateTime

Catch ' some errors
  Main.WriteDebugLog(LogLabel & "ERROR: '" & Error.Text & "' at '" & Error.Where & "'")

End

'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
' Update Z-Wave Controller Information. It can be supplied during initial startup or during updates
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Private Sub UpdateControllerInfo(sKey As String, cData As JSONCollection, cZWaveNode As JSONCollection)

  Dim sTag As String

  Select sKey
    Case "homeId"
      sTag = "homeid"
    Case "nodeId"
      sTag = "controllerid"
    Case "SDK"
      sTag = "sdkversion"
    Case "APIVersion"
      sTag = "apiversion"
    Case "softwareRevisionVersion"
      sTag = "zwayversion"
    Case "softwareRevisionDate"
      sTag = "zwaybuilddate"
    Case "softwareRevisionId"
      sTag = "zwayrevisionid"
    Case "vendor"
      sTag = "manufacturername"
    Case "ZWaveChip"
      sTag = "zwavechip"
    Case "isPrimary"
      sTag = "primary"
    Case "isRealPrimary"
      sTag = "realprimary"
    Case "libType"
      sTag = "librarytype"
  End Select

  ' Only store a mapped name, all others we aren't interested in
  If sTag Then

    ' Check if the "value" exists, else there is something wrong with the data
    If cData.Exist("value") Then

      ' Now add the mapped value into the Z-Wave nodeinfo
      cZWaveNode.Add(cData["value"], sTag)
    Else
      ' This is never a valid error scenario
      Main.WriteDebugLog(LogLabel & "ERROR: Data doesn't contain a 'value' field. Z-Wave Controller, Data='" & JSON.Encode(cData) & "'")
    Endif
  Endif

End

'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
' Parse Controller Information
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Private Sub ParseControllerInfo(cData As JSONCollection)

  Dim cController As New JSONCollection

  cController.Add(0, "homeid")
  cController.Add(0, "controllerid")
  cController.Add("", "sdkversion")
  cController.Add("", "apiversion")
  cController.Add("", "zwayversion")
  cController.Add("", "zwaybuilddate")
  cController.Add("", "zwayrevisionid")
  cController.Add("", "manufacturername")
  cController.Add("", "zwavechip")
  cController.Add(False, "primary")
  cController.Add(False, "realprimary")
  cController.Add("", "librarytype")

  ' Go through all data entries and parse them
  For Each cData["data"]
    If TypeOf(cData["data"][cData["data"].Key]) = gb.Object And If Object.Type(cData["data"][cData["data"].Key]) = "JSONCollection" Then
      UpdateControllerInfo(cData["data"].Key, cData["data"][cData["data"].Key], cController)
    Endif
  Next

  ' Add the controller information to the internal Z-Wave Network
  $cZWaveNetwork.Add(cController, "controller")

  If $bDebug Then
    Main.WriteDebugLog(LogLabel & "---")
    Main.WriteDebugLog(LogLabel & "Controller Info")
    Main.WriteDebugLog(LogLabel & "---")
    Main.WriteDebugLog(LogLabel & "Home Id: 0x" & Hex(cController["homeid"], 8))
    Main.WriteDebugLog(LogLabel & "Node Id: " & cController["controllerid"])
    Main.WriteDebugLog(LogLabel & "Primary Role: " & Util.DisplayBool(cController["primary"]))
    Main.WriteDebugLog(LogLabel & "Primary Capability: " & Util.DisplayBool(cController["realprimary"]))
    Main.WriteDebugLog(LogLabel & "ManufacturerName: " & cController["manufacturername"])
    Main.WriteDebugLog(LogLabel & "Z-Wave Chip: " & cController["zwavechip"])
    Main.WriteDebugLog(LogLabel & "Library Type: " & cController["librarytype"])
    Main.WriteDebugLog(LogLabel & "SDK Version: " & cController["sdkversion"])
    Main.WriteDebugLog(LogLabel & "API Version: " & cController["apiversion"])
    Main.WriteDebugLog(LogLabel & "---")
    Main.WriteDebugLog(LogLabel & "Z-Way Version")
    Main.WriteDebugLog(LogLabel & "Version: " & cController["zwayversion"] & " (" & cController["zwayrevisionid"] & ")")
    Main.WriteDebugLog(LogLabel & "Date: " & cController["zwaybuilddate"])
    Main.WriteDebugLog(LogLabel & "---")
    Main.WriteDebugLog(LogLabel & "Update Timestamp: " & Util.TimeSinceEpoch($iNewUpdateTime) & " (" & $iNewUpdateTime & ")")
  Endif

End

'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
' Update Z-Wave Node Information. It can be supplied during initial startup or during updates
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Private Sub UpdateNodeInfo(sKey As String, cData As JSONCollection, cZWaveNode As JSONCollection)

  Dim sTag As String

  If Not cZWaveNode Then
    If $bDebug Then Main.WriteDebugLog(LogLabel & "ERROR: Received a Node Info Update for key='" & sKey & "', but node doesn't exist")
    Return
  Endif

  ' Map Z-Way names to internal
  Select sKey
    Case "vendorString"
      sTag = "manufacturername"
    Case "manufacturerId"
      sTag = "manufacturerid"
    Case "isRouting"
      sTag = "routing"
    Case "isListening"
      sTag = "listening"
    Case "sensor250"
      sTag = "sensor250"
    Case "sensor1000"
      sTag = "sensor1000"
    Case "beaming"
      sTag = "beaming"
    Case "nodeInfoFrame"
      sTag = "nodeinfoframe"
    Case "neighbours"
      sTag = "neighbors"
    Case "basicType"
      sTag = "basicid"
    Case "genericType"
      sTag = "genericid"
    Case "specificType"
      sTag = "specificid"
    Case "deviceTypeString"
      sTag = "devicetype"
    Case "ZWLib"
      sTag = "libraryversion"
    Case "SDK"
      sTag = "sdkversion"
    Case "isFailed"
      sTag = "state"
    Case "applicationMajor", "applicationMinor", "ZWProtocolMajor", "ZWProtocolMinor"
      sTag = sKey
  End Select

  ' Only store a mapped name, all others we aren't interested in
  If sTag Then

    ' Node Info is updated with a RaZberry update, lets report it
    If $iUpdateTime > 0 Then
      If $bDebug Then Main.WriteDebugLog(LogLabel & "Received Node Info Update for Z-Wave NodeId '" & cZWaveNode["node_id"] & "'" & ", Key '" & sTag & "', Value '" & cData["value"] & "'")
    Endif

    ' Check if the "value" exists, else there is something wrong with the data
    If cData.Exist("value") Then

      ' Now add the mapped value into the Z-Wave nodeinfo
      cZWaveNode.Add(cData["value"], sTag)

      ' Add other special (none Z-Way) values based on the input
      Select sTag
        Case "sensor250", "sensor1000"
          If cData["value"] Then cZWaveNode.Add(True, "frequentlistening")
        Case "basicid"
          cZWaveNode.Add(GetBasicTypeName(cData["value"]), "basic")
        Case "genericid"
          cZWaveNode.Add(GetGenericTypeName(cData["value"]), "generic")
        Case "specificid"
          cZWaveNode.Add(GetSpecificTypeName(cZWaveNode["genericid"], cData["value"]), "specific")
        Case "state"
          cZWaveNode.Add(IIf(cData["value"], "Dead", "Alive"), "state")
        Case "applicationMajor"
          If InStr(cZWaveNode["applicationversion"], ".") Then
            cZWaveNode["applicationversion"] = Mid(cZWaveNode["applicationversion"], InStr(cZWaveNode["applicationversion"], ".") + 1)
          Endif
          cZWaveNode.Add(cZWaveNode[sTag] & "." & cZWaveNode["applicationversion"], "applicationversion")
          cZWaveNode.Remove(sTag)
        Case "applicationMinor"
          If InStr(cZWaveNode["applicationversion"], ".") Then
            cZWaveNode["applicationversion"] = Left(cZWaveNode["applicationversion"], InStr(cZWaveNode["applicationversion"], ".") - 1)
          Endif
          cZWaveNode.Add(cZWaveNode["applicationversion"] & "." & cZWaveNode[sTag], "applicationversion")
          cZWaveNode.Remove(sTag)
        Case "ZWProtocolMajor"
          If InStr(cZWaveNode["protocolversion"], ".") Then
            cZWaveNode["protocolversion"] = Mid(cZWaveNode["protocolversion"], InStr(cZWaveNode["protocolversion"], ".") + 1)
          Endif
          cZWaveNode.Add(cZWaveNode[sTag] & "." & cZWaveNode["protocolversion"], "protocolversion")
          cZWaveNode.Remove(sTag)
        Case "ZWProtocolMinor"
          If InStr(cZWaveNode["protocolversion"], ".") Then
            cZWaveNode["protocolversion"] = Left(cZWaveNode["protocolversion"], InStr(cZWaveNode["protocolversion"], ".") - 1)
          Endif
          cZWaveNode.Add(cZWaveNode["protocolversion"] & "." & cZWaveNode[sTag], "protocolversion")
          cZWaveNode.Remove(sTag)
      End Select
    Else
      ' This is never a valid error scenario
      Main.WriteDebugLog(LogLabel & "ERROR: Data doesn't contain a 'value' field. Z-Wave NodeId=" & CZWaveNode["node_id"] & ", Data='" & JSON.Encode(cData) & "'")
    Endif
  Endif

End

'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
' Parse Device Information
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Private Sub ParseDeviceInfo(cData As JSONCollection)

  Dim cZWaveNode As JSONCollection
  Dim cNode As New JSONCollection
  Dim cInstance As New JSONCollection
  Dim oTemp As Object
  Dim iNodeId As Integer
  Dim iInstanceId As Integer
  Dim aBytes As Byte[]
  Dim iType As Integer
  Dim sValue As String
  Dim sUnits As String
  Dim sLabel As String
  Dim iDeviceId As Integer
  Dim sDeviceTypeAutoCreate As String

  ' Remove all nodes from the Z-Wave Network, they will be re-added automatically
  ' The API doesn't tell us which devices are removed, just which nodes there are (left)
  For Each $cZWaveNetwork
    ' Only skip the controller, we need to keep it
    If $cZWaveNetwork.Key <> "controller" Then
      $cZWaveNetwork.Remove($cZWaveNetwork.Key)
    Endif
  Next

  ' Don't continue if the controller record is missing, something went horrorible wrong
  If Not $cZWaveNetwork.Exist("controller") Then
    Main.WriteLog(LogLabel & "ERROR: Device List supplied, but no controller information available. Looks like a bug?")
    Return
  Endif

  ' devices found
  If cData.Count Then
    If $bDebug Then
      Main.WriteDebugLog(LogLabel & "---")
      Main.WriteDebugLog(LogLabel & "Interface Reported " & cData.Count & " device(s).")
    Endif

    ' go through each node
    For Each cNode In cData

      cZWaveNode = New JSONCollection

      ' The Z-Wave NodeId is in the key
      Try iNodeId = CInt(cData.Key)
      If Error Then
        Main.WriteDebugLog(LogLabel & "ERROR: Skipping device, unable to detect Z-Wave NodeId '" & cData.Key & "'")
        Continue
      Endif

      ' Only allow valid Z-Wave NodeIds
      If iNodeId < 1 Or If iNodeId > 232 Then
        Main.WriteDebugLog(LogLabel & "ERROR: Skipping device, invalid Z-Wave NodeId '" & iNodeId & "'")
        Continue
      Endif

      ' Add Z-Wave NodeId and default values into a new record
      cZWaveNode.Add(iNodeId, "node_id")
      cZWaveNode.Add(0, "basicid")
      cZWaveNode.Add("", "basic")
      cZWaveNode.Add(0, "genericid")
      cZWaveNode.Add("", "generic")
      cZWaveNode.Add(0, "specificid")
      cZWaveNode.Add("", "specific")
      cZwaveNode.Add("", "manufacturername")
      cZWaveNode.Add(0, "manufacturerid")
      cZWaveNode.Add(False, "routing")
      cZWaveNode.Add(False, "listening")
      cZWaveNode.Add(False, "frequentlistening")
      cZWaveNode.Add(False, "beaming")
      aBytes = New Byte[]
      cZWaveNode.Add(aBytes, "nodeinfoframe")
      cZWaveNode.Add(False, "wakeup")
      cZWaveNode.Add(False, "battery")
      cZWaveNode.Add(False, "security")
      cZWaveNode.Add(False, "multiinstance")
      aBytes = New Byte[]
      cZWaveNode.Add(aBytes, "neigbors")
      cZWaveNode.Add("", "devicetype")
      cZWaveNode.Add("", "libraryversion")
      cZWaveNode.Add("", "sdkversion")
      cZWaveNode.Add("", "applicationversion")
      cZWaveNode.Add("", "protocolversion")
      cZWaveNode.Add("", "state")

      ' Now process each node record
      For Each cNode["data"]
        If TypeOf(cNode["data"][cNode["data"].Key]) = gb.Object And If Object.Type(cNode["data"][cNode["data"].Key]) = "JSONCollection" Then
          UpdateNodeInfo(cNode["data"].Key, cNode["data"][cNode["data"].Key], cZWaveNode)
        Endif 
      Next

      ' We should always have instance(s)
      If Not cNode.Exist("instances") Then
        Return
      Endif

      ' Check for instances, battery, wakeup and security
      Try cZWaveNode.Add(CBool(IIf(cNode["instances"]["0"]["commandClasses"]["132"], True, False)), "wakeup")
      Try cZWaveNode.Add(CBool(IIf(cNode["instances"]["0"]["commandClasses"]["128"], True, False)), "battery")
      Try cZWaveNode.Add(CBool(IIf(cNode["instances"]["0"]["commandClasses"]["152"], True, False)), "security")
      Try cZWaveNode.Add(IIf(cNode["instances"].Count > 1, True, False), "multiinstance")
      If Error Then cZWaveNode.Add(False, "multiinstance")

      ' LastSeen

      ' If device is the controller, just add it to the ZWaveNode and go to the next device
      If iNodeId = $cZWaveNetwork["controller"]["controllerid"] Then
        Try cZWaveNode.Add($cZWaveNetwork["controller"]["sdkversion"], "sdkversion")
        If Error Then cZWaveNode.Add("", "sdkversion")

        $cZWaveNetwork.Add(cZWaveNode, cZWaveNode["node_id"])

        If $bDebug Then Main.WriteDebugLog(LogLabel & "Detected controller as node #" & iNodeId & ", skipping...") 
        Continue
      Endif

      ' Determine auto-create devicetype
      Select cZWaveNode["genericid"]
        Case &H01, &H02
          sDeviceTypeAutoCreate = "Z-Wave Controller"
        Case &H08
          sDeviceTypeAutoCreate = "Z-Wave Thermostat"
        Case &H10
          sDeviceTypeAutoCreate = "Z-Wave Switch"
        Case &H11
          Select cZWaveNode["specificid"]
            Case &H05, &H06, &H07
              sDeviceTypeAutoCreate = "Z-Wave Motor Control"
            Default
              sDeviceTypeAutoCreate = "Z-Wave Dimmer"
          End Select
        Case &H12
          sDeviceTypeAutoCreate = "Z-Wave Remote Switch"
        Case &H20, &H21, &H30, &H31, &HA1
          sDeviceTypeAutoCreate = "Z-Wave Sensor"
        Case &H40
          Select cZWaveNode["specificid"]
            Case &H01, &H02, &H03
              sDeviceTypeAutoCreate = "Z-Wave Door Lock"
            Default
              sDeviceTypeAutoCreate = "Z-Wave Entry Control"
          End Select
        Default
          sDeviceTypeAutoCreate = "Z-Wave Generic"
      End Select

      ' If the devicetype is empty, overrule it
      If Not cZWaveNode["devicetype"] Then
        cZWaveNode.Add(sDeviceTypeAutoCreate, "devicetype")
      Endif

      If $bDebug Then
        Main.WriteDebugLog(LogLabel & "---")
        Main.WriteDebugLog(LogLabel & "Node #" & iNodeId)
        Main.WriteDebugLog(LogLabel & "ManufacturerName: " & cZWaveNode["manufacturername"])
        Main.WriteDebugLog(LogLabel & "ManufacturerId: " & cZWaveNode["manufacturerid"])
        Main.WriteDebugLog(LogLabel & "DeviceType: " & cZWaveNode["devicetype"])
        Main.WriteDebugLog(LogLabel & "BasicType: " & cZWaveNode["basic"])
        Main.WriteDebugLog(LogLabel & "GenericType: " & cZWaveNode["generic"])
        Main.WriteDebugLog(LogLabel & "SpecificType: " & cZWaveNode["specific"])
        Main.WriteDebugLog(LogLabel & "Listening: " & Util.DisplayBool(cZWaveNode["listening"]))
        Main.WriteDebugLog(LogLabel & "Frequent Listening (FLiRS): " & Util.DisplayBool(cZWaveNode["frequentlistening"]))
        Main.WriteDebugLog(LogLabel & "SDK Version: " & cZWaveNode["sdkversion"])
        Main.WriteDebugLog(LogLabel & "Application Version: " & cZWaveNode["applicationversion"])
        Main.WriteDebugLog(LogLabel & "Protocol Version: " & cZWaveNode["protocolversion"])
        Main.WriteDebugLog(LogLabel & "WakeUp: " & Util.DisplayBool(cZWaveNode["wakeup"]))
        Main.WriteDebugLog(LogLabel & "Battery: " & Util.DisplayBool(cZWaveNode["battery"]))
        Main.WriteDebugLog(LogLabel & "Multiple Instances: " & Util.DisplayBool(cZWaveNode["multiinstance"]))
      Endif

      ' Add instances collection
      oTemp = New JSONCollection
      cZWaveNode.Add(oTemp, "instances")

      ' go through each instance
      For Each cInstance In cNode["instances"]

        ' devices.2.instances.0.data
        Try iInstanceId = CInt(cNode["instances"].Key)
        If Error Then
          Main.WriteDebugLog(LogLabel & "ERROR: Skipping device, invalid instance '" & cNode["instances"].Key & "' for node " & cZWaveNode["node_id"])
          Continue
        Endif

        ' CommandClasses need to exist
        If Not cInstance.Exist("commandClasses") Then
          Main.WriteDebugLog(LogLabel & "ERROR: Skipping device, invalid commandClasses for node " & cZWaveNode["node_id"])
          Continue
        Endif

        If (iInstanceId = 0 And cInstance["commandClasses"].Exist(COMMAND_CLASS_BATTERY)) Or If iInstanceId >= 1 Or If Not cZWaveNode["multiinstance"] Then
          ' Only create if the instance doesn't exist
          If Not cZWaveNode["instances"].Exist(iInstanceId) Then
            oTemp = New JSONCollection
            cZWaveNode["instances"].Add(oTemp, iInstanceId)

            oTemp = New Byte[]
            cZWaveNode["instances"][iInstanceId].Add(oTemp, "index")

            oTemp = New Byte[]
            cZWaveNode["instances"][iInstanceId].Add(oTemp, "commandclasses")
          Endif
        Endif

        ' Handle the Command_Class_Battery (128), this only exist in instance #0
        If iInstanceId = 0 And If cInstance["commandClasses"].Exist(COMMAND_CLASS_BATTERY) Then
          UpdateNodeCommandClass_Battery(iInstanceId, cInstance["commandClasses"][COMMAND_CLASS_BATTERY]["data"]["last"], cZWaveNode)
          cZWaveNode["instances"][iInstanceId]["commandclasses"].Add(255)
        Endif

        ' Skip instance 0 if it has more, since it should be mapped to other instances
        If iInstanceId = 0 And If cZWaveNode["multiinstance"] Then Continue
 
        For Each cInstance["commandClasses"]
          cZWaveNode["instances"][iInstanceId]["commandclasses"].Add(cInstance["commandClasses"].Key)
        Next

        If $bDebug Then Main.WriteDebugLog(LogLabel & "Instance #" & iInstanceId)

        ' Command_Class_Basic
        ' Use basic = 32 In nodeinfoframe To determine If we need To put an empty value In value1? in instance=0/1

        ' We should try Multilevel (dimmer) before a Switch
        ' Command_Class_Switch_Multilevel (38)
        If cInstance["commandClasses"].Exist(COMMAND_CLASS_SWITCH_MULTILEVEL) Then
          UpdateNodeCommandClass_SwitchMultiLevel(iInstanceId, cInstance["commandClasses"][COMMAND_CLASS_SWITCH_MULTILEVEL]["data"]["level"], cZWaveNode)

        ' Command_Class_Switch_Binary (37)
        Else If cInstance["commandClasses"].Exist(COMMAND_CLASS_SWITCH_BINARY) Then
          UpdateNodeCommandClass_SwitchBinary(iInstanceId, cInstance["commandClasses"][COMMAND_CLASS_SWITCH_BINARY]["data"]["level"], cZWaveNode)
        Endif

        ' Command_Class_Sensor_Binary (48)
        If cInstance["commandClasses"].Exist(COMMAND_CLASS_SENSOR_BINARY) Then
          For Each cInstance["commandClasses"][COMMAND_CLASS_SENSOR_BINARY]["data"]
            If IsNumber(cInstance["commandClasses"][COMMAND_CLASS_SENSOR_BINARY]["data"].Key) Then
              iType = CInt(cInstance["commandClasses"][COMMAND_CLASS_SENSOR_BINARY]["data"].Key)
              UpdateNodeCommandClass_SensorBinary(iInstanceId, iType, cInstance["commandClasses"][COMMAND_CLASS_SENSOR_BINARY]["data"][iType], cZWaveNode)
            Endif
          Next
        Endif

        ' Command_Class_Sensor_Multilevel (49)
        If cInstance["commandClasses"].Exist(COMMAND_CLASS_SENSOR_MULTILEVEL) Then
          For Each cInstance["commandClasses"][COMMAND_CLASS_SENSOR_MULTILEVEL]["data"]
            If IsNumber(cInstance["commandClasses"][COMMAND_CLASS_SENSOR_MULTILEVEL]["data"].Key) Then
              iType = CInt(cInstance["commandClasses"][COMMAND_CLASS_SENSOR_MULTILEVEL]["data"].Key)
              UpdateNodeCommandClass_SensorMultilevel(iInstanceId, iType, cInstance["commandClasses"][COMMAND_CLASS_SENSOR_MULTILEVEL]["data"][iType], cZWaveNode)
            Endif
          Next
        Endif

        ' Command_Class_Meter (50)
        If cInstance["commandClasses"].Exist(COMMAND_CLASS_METER) Then
          For Each cInstance["commandClasses"][COMMAND_CLASS_METER]["data"]
            If IsNumber(cInstance["commandClasses"][COMMAND_CLASS_METER]["data"].Key) Then
              iType = CInt(cInstance["commandClasses"][COMMAND_CLASS_METER]["data"].Key)
              UpdateNodeCommandClass_Meter(iInstanceId, iType, cInstance["commandClasses"][COMMAND_CLASS_METER]["data"][iType], cZWaveNode)
            Endif
          Next
        Endif

        ' Command_Class_SetPoint (67)
        If cInstance["commandClasses"].Exist(COMMAND_CLASS_THERMOSTAT_SETPOINT) Then
          For Each cInstance["commandClasses"][COMMAND_CLASS_THERMOSTAT_SETPOINT]["data"]
            If IsNumber(cInstance["commandClasses"][COMMAND_CLASS_THERMOSTAT_SETPOINT]["data"].Key) Then
              iType = CInt(cInstance["commandClasses"][COMMAND_CLASS_THERMOSTAT_SETPOINT]["data"].Key)
              UpdateNodeCommandClass_ThermostatSetPoint(iInstanceId, iType, cInstance["commandClasses"][COMMAND_CLASS_THERMOSTAT_SETPOINT]["data"][iType], cZWaveNode)
            Endif
          Next
        Endif

        ' Command_Class_Door_Lock (98)
        If cInstance["commandClasses"].Exist(COMMAND_CLASS_DOOR_LOCK) Then
          UpdateNodeCommandClass_DoorLock(iInstanceId, cInstance["commandClasses"][COMMAND_CLASS_DOOR_LOCK]["data"]["mode"], cZWaveNode)
        Endif

        ' Command_Class_Sensor_Alarm (156)

        '  Find the iDeviceId
        iDeviceId = Devices.Find(Instance, iNodeId & IIf((iInstanceId > 1), ":" & iInstanceId, ""), InterfaceId, sDeviceTypeAutoCreate, cZWaveNode["manufacturername"] & " " & cZWaveNode["devicetype"])
        If iDeviceId = 0 Then Continue

        ' We need to be backwards compatible
        If Not $bLegacy Then

          ' OpenZWave compatible

        Else

          ' Legacy mode
          For Each cZwaveNode["instances"][iInstanceId]

            If Not IsNumber(cZwaveNode["instances"][iInstanceId].Key) Then Continue

            sValue = cZwaveNode["instances"][iInstanceId][cZwaveNode["instances"][iInstanceId].Key]["value"]
            If $bDebug Then
              sUnits = cZwaveNode["instances"][iInstanceId][cZwaveNode["instances"][iInstanceId].Key]["units"]
              sLabel = cZwaveNode["instances"][iInstanceId][cZwaveNode["instances"][iInstanceId].Key]["label"]
            Endif

            Select cZwaveNode["instances"][iInstanceId].Key

              ' Command_Class_Switch_Multilevel (38) or Command_Class_Switch_Binary (37)
              ' Command_Class_Door_Lock (96)
              Case "2", "3"
                If $bDebug Then Main.WriteDebugLog(LogLabel & "value1: " & sValue)
                Devices.ValueUpdate(iDeviceId, 1, sValue)

              ' Command_Class_Sensor_Binary (48)
              Case "31"
                If $bDebug Then Main.WriteDebugLog(LogLabel & "value1: " & sValue)
                If cZWaveNode["manufacturername"] & " " & cZWaveNode["devicetype"] = "Aeon Labs Routing Binary Sensor" Then
                  sValue = IIf(sValue = "On", "Open", "Close")
                Endif
                Devices.ValueUpdate(iDeviceId, 1, sValue)

              ' Command_Class_Sensor_Multilevel (49)
              Case "51", "52", "53", "54"
                If $bDebug Then Main.WriteDebugLog(LogLabel & "value4: " & sValue & IIf(sUnits, sUnits & " ", "") & IIf(sLabel, " (" & sLabel & ")", ""))
                Devices.ValueUpdate(iDeviceId, 4, sValue)

              ' Command_Class_Meter (50)
              Case "11", "12"
                If $bDebug Then Main.WriteDebugLog(LogLabel & IIf(cZwaveNode["instances"][iInstanceId].Key = "11", "value2: ", "value3: ") & sValue & IIf(sUnits, sUnits & " ", "") & IIf(sLabel, " (" & sLabel & ")", ""))

                If cZwaveNode["instances"][iInstanceId].Key = "11" Then
                  Devices.ValueUpdate(iDeviceId, 2, sValue)
                Else
                  Devices.ValueUpdate(iDeviceId, 3, sValue)
                Endif

              ' Command_Class_Thermostat_SetPoint (67)
              Case "131"
                If $bDebug Then Main.WriteDebugLog(LogLabel & "value2: " & sValue & IIf(sUnits, sUnits & " ", "") & IIf(sLabel, " (" & sLabel & ")", ""))
                Devices.ValueUpdate(iDeviceId, 2, sValue)

            End Select

          Next

          ' Command_Class_Battery (128) - always goes in the first available instance
          If iInstanceId = 0 Or If iInstanceId = 1 Then
            If cZWaveNode["instances"].Exist("0") And If cZWaveNode["instances"]["0"].Exist("255") Then
              sValue = cZwaveNode["instances"][0]["255"]["value"]
              If $bDebug Then
                sUnits = cZwaveNode["instances"]["0"]["255"]["units"]
              Endif

              If $bDebug Then Main.WriteDebugLog(LogLabel & "battery: " & sValue & IIf(sUnits, sUnits, ""))
              Devices.Battery(iDeviceId, sValue)
            Endif
          Endif
        Endif

        ' security
'        If cInstance["commandClasses"]["99"] Then
'          For Each vValues In cInstance["commandClasses"]["99"]["data"]
'            If IsNumber(cInstance["commandClasses"]["99"]["data"].Key) Then
'              vValueTemp = cInstance["commandClasses"]["99"]["data"].Key
'              If $bDebug Then Main.WriteDebugLog(LogLabel & "User Id: " & vValueTemp)
'              vValueTemp = cInstance["commandClasses"]["99"]["data"][cInstance["commandClasses"]["99"]["data"].Key]["status"]["value"]
'              If $bDebug Then Main.WriteDebugLog(LogLabel & "User Code: " & vValueTemp)
'              ' update device
'            Endif
'          Next
'        Endif

      Next

      $cZWaveNetwork.Add(cZWaveNode, cZWaveNode["node_id"])
    Next

  Endif

  bInit = True

  ' start update timer
  If $iPollTime And If tRaZberry Then tRaZberry.Start

Catch ' some errors
  Main.WriteDebugLog(LogLabel & "ERROR: '" & Error.Text & "' at '" & Error.Where & "'")

End

'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
'
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Private Sub UpdateIntervalCCValue(iInstanceId As Integer, iMap As Integer, cData As JSONCollection, sPath As String, vValue As Variant, Optional sUnits As String = "", Optional sLabel As String = "")

  Dim cEntry As JSONCollection

  ' Try to find an existing mapping, then we just have to update the data
  If cData[iInstanceId]["index"].Find(iMap) >= 0 Then
    cData[iInstanceId][iMap]["value"] = vValue
  Else
    ' Doesn't exist, create a mapping and sort it
    cData[iInstanceId]["index"].Add(iMap)
    cData[iInstanceId]["index"] = cData[iInstanceId]["index"].Sort()

    ' Create the value & units entry
    cEntry = New JSONCollection
    cEntry.Add(sPath, "path")
    cEntry.Add(vValue, "value")
    cEntry.Add(sUnits, "units")
    cEntry.Add(sLabel, "label")
    cData[iInstanceId].Add(cEntry, iMap)
  Endif

End

'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
' Add or Update the CommandClass_Basic - sensors normally
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
'Private Sub UpdateNodeCommandClass_Basic(iInstanceId As Integer, cData As JSONCollection, cZWaveNode As JSONCollection)

'  Dim iMap As Integer
'  Dim sUpdateKey As String

'  iMap = 2

'End

'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
' Add or Update the CommandClass_Switch_Binary
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Private Sub UpdateNodeCommandClass_SwitchBinary(iInstanceId As Integer, cData As JSONCollection, cZWaveNode As JSONCollection)

  Dim iMap As Integer
  Dim sUpdateKey As String
  Dim sValue As String

  iMap = 2

  Select cData["type"]
    Case "bool"
      sValue = IIf(cData["value"], "On", "Off")
    Case "int"
      sValue = IIf(cData["value"] > 99, "On", "Off")
    Default
      sValue = "Off"
  End Select

  ' Build up possible update key. E.g. devices.5.instances.1.commandClasses.50.data.2
  sUpdateKey = "devices." & cZWaveNode["node_id"] & ".instances." & iInstanceId & ".commandClasses." & COMMAND_CLASS_SWITCH_BINARY & ".data.level"
  UpdateIntervalCCValue(iInstanceId, iMap, cZWaveNode["instances"], sUpdateKey, sValue)

End

'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
' Add or Update the CommandClass_Switch_MultiLevel
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Private Sub UpdateNodeCommandClass_SwitchMultiLevel(iInstanceId As Integer, cData As JSONCollection, cZWaveNode As JSONCollection)

  Dim iMap As Integer
  Dim sUpdateKey As String
  Dim sValue As String

  iMap = 2

  Select cData["type"]
    Case "bool"
      sValue = IIf(cData["value"], "On", "Off")
    Case "int"
      If cData["value"] = 0 Then
        sValue = "Off"
      Else If cData["value"] >= 99 Then
        sValue = "On"
      Else
        sValue = "Dim " & cData["value"]
      Endif
    Default
      sValue = "Off"
  End Select

  ' Build up possible update key. E.g. devices.5.instances.1.commandClasses.50.data.2
  sUpdateKey = "devices." & cZWaveNode["node_id"] & ".instances." & iInstanceId & ".commandClasses." & COMMAND_CLASS_SWITCH_MULTILEVEL & ".data.level"
  UpdateIntervalCCValue(iInstanceId, iMap, cZWaveNode["instances"], sUpdateKey, sValue)

End

'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
' Add or Update the CommandClass_Sensor_Binary entry
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Private Sub UpdateNodeCommandClass_SensorBinary(iInstanceId As Integer, iType As Integer, cData As JSONCollection, cZWaveNode As JSONCollection)

  Dim sUpdateKey As String
  Dim iMap As Integer
  Dim sValue As String

  ' Each Sensor Binary Collection should have:
  ' - sensorTypeString/value = string representation of sensor Type
  ' - level/value = The actual binary true/false

  If Not cData.Exist("sensorTypeString") Or If Not cData.Exist("level") Then
    Main.WriteDebugLog(LogLabel & "ERROR: Z-Wave NodeId '" & cZwaveNode["node_id"] & "' seem to have an invalid COMMAND_CLASS_SENSOR_BINARY for '" & iType & "'")
    Return
  Endif

  ' Now try to map the type to a known value
  Select iType
    Case 1 ' General purpose
      iMap = 31
    Case 2 ' Smoke
      iMap = 32
    Case 3 ' CO
      iMap = 33
    Case 4 ' CO2
      iMap = 34
    Case 5 ' Heat
      iMap = 35
    Case 6 ' Water
      iMap = 36
    Case 7 ' Freeze
      iMap = 37
    Case 8 ' Tamper
      iMap = 38
    Case 9 ' Aux
      iMap = 39
    Case 10 ' Door/Window
      iMap = 40
    Case 11 ' Tilt
      iMap = 41
    Case 12 ' Motion
      iMap = 42
    Case 13 ' Glass Break
      iMap = 43
    Default ' For Z-Way v1.31
      iMap = 31
  End Select

  ' Only continue if we found a known type
  If iMap Then
    If cData["level"]["value"] = 255 Then
      sValue = "On"
    Else
      sValue = "Off"
    Endif

    ' Build up possible update key. e.g. devices.5.instances.1.commandClasses.48.data.2
    sUpdateKey = "devices." & cZWaveNode["node_id"] & ".instances." & iInstanceId & ".commandClasses." & COMMAND_CLASS_SENSOR_BINARY & ".data." & iType
    UpdateIntervalCCValue(iInstanceId, iMap, cZWaveNode["instances"], sUpdateKey, sValue, cData["sensorTypeString"]["value"])
  Endif

End

'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
' Add or Update the CommandClass_Sensor_Multilevel entry
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Private Sub UpdateNodeCommandClass_SensorMultilevel(iInstanceId As Integer, iType As Integer, cData As JSONCollection, cZWaveNode As JSONCollection)

  Dim sUpdateKey As String
  Dim iMap As Integer

  ' Each Sensor Multilevel Collection should have:
  ' - sensorTypeString/value = string representation of sensor Type
  ' - scaleString/value = string representation of meter scale
  ' - val/value = The actual value

  If Not cData.Exist("sensorTypeString") Or If Not cData.Exist("scaleString") Or If Not cData.Exist("val") Then
    Main.WriteDebugLog(LogLabel & "ERROR: Z-Wave NodeId '" & cZwaveNode["node_id"] & "' seem to have an invalid COMMAND_CLASS_SENSOR_MULTILEVEL for '" & iType & "'")
    Return
  Endif

  ' Now try to map the type to a known value
  Select iType
    Case 2 ' Generic
      iMap = 51
    Case 1 ' Temperature
      iMap = 52
    Case 3 ' Luminiscence
      iMap = 53
    Case 4 ' Power
      iMap = 54
    Case 5 ' Humidity
      iMap = 55
    Case 6 ' Velocity
      iMap = 56
    Case 7 ' Direction
      iMap = 57
    Case 8 ' Athmospheric Pressure
      iMap = 58
    Case 9 ' Barometric Pressure
      iMap = 59
    Case 10 ' Solar Radiation
      iMap = 60
    Case 11 ' Dew Point
      iMap = 61
    Case 12 ' Rain Rate
      iMap = 62
    Case 13 ' Tide Level
      iMap = 63
    Case 14 ' Weigth, Weight
      iMap = 64
    Case 15 ' Voltage
      iMap = 65
    Case 16 ' Current
      iMap = 66
    Case 17 ' CO2 Level
      iMap = 67
    Case 18 ' Air Flow
      iMap = 68
    Case 19 ' Tank Capacity
      iMap = 69
    Case 20 ' Distance
      iMap = 70
    Case 21 ' Angle Position
      iMap = 71
    Case 22 ' Rotation
      iMap = 72
    Case 23 ' Water temperature
      iMap = 73
    Case 24 ' Soil temperature
      iMap = 74
    Case 25 ' Seismic intensity
      iMap = 75
    Case 26 ' Seismic magnitude
      iMap = 76
    Case 27 ' Ultraviolet
      iMap = 77
    Case 28 ' Electrical resistivity
      iMap = 78
    Case 29 ' Electrical conductivity
      iMap = 79
    Case 30 ' Loudness
      iMap = 80
    Case 31 ' Moisture
      iMap = 81
    Case 32 ' Frequency
      iMap = 82
    Case 33 'Time
      iMap = 83
    Case 34 ' Target Temperature
      iMap = 84
  End Select

  ' Only continue if we found a known type
  If iMap Then
    ' Build up possible update key. e.g. devices.5.instances.1.commandClasses.49.data.4
    sUpdateKey = "devices." & cZWaveNode["node_id"] & ".instances." & iInstanceId & ".commandClasses." & COMMAND_CLASS_SENSOR_MULTILEVEL & ".data." & iType
    UpdateIntervalCCValue(iInstanceId, iMap, cZWaveNode["instances"], sUpdateKey, cData["val"]["value"], cData["scaleString"]["value"], cData["sensorTypeString"]["value"])
  Endif

End

'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
' Add or Update the CommandClass_Meter entry 
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Private Sub UpdateNodeCommandClass_Meter(iInstanceId As Integer, iType As Integer, cData As JSONCollection, cZWaveNode As JSONCollection)

  Dim sUpdateKey As String
  Dim iMap As Integer

  ' Each Meter Collection should have:
  ' - delta/value = difference between last and actual meter value
  ' - previous/value = previous meter value (gotten with last GET request
  ' - rateType/value = meter rate type 
  ' - scale/value = meter scale id
  ' - scaleString/value = string representation of meter scale
  ' - sensorType/value = sensor type id 
  ' - sensorTypeString/value = string representation of sensor Type
  ' - val/value = The actual meter value

  If Not cData.Exist("sensorTypeString") Or If Not cData.Exist("scaleString") Or If Not cData.Exist("val") Then
    Main.WriteDebugLog(LogLabel & "ERROR: Z-Wave NodeId '" & cZwaveNode["node_id"] & "' seem to have an invalid COMMAND_CLASS_METER for '" & iType & "'")
    Return
  Endif

  ' Now try to map the type to a known value
  Select cData["sensorTypeString"]["value"]
    Case "Electric", "Electric "
      Select cData["scaleString"]["value"]
        Case "W"
          iMap = 11
        Case "kWh"
          iMap = 12
        Case "kVAh"
          iMap = 14
        Case "V"
          iMap = 15
        Case "A"
          iMap = 16
        Case "Pulse Count"
          iMap = 17
        Case "Power Factor"
          iMap = 18
      End Select
    Case "Gas"
      Select cData["scaleString"]["value"]
        Case "Qubic meter"
          iMap = 19
        Case "Qubic feet"
          iMap = 20
        Case "Pulse Count"
          iMap = 21
      End Select
    Case "Water"
      Select cData["scaleString"]["value"]
        Case "Cubic meter"
          iMap = 22
        Case "Cubic feet"
          iMap = 23
        Case "US Gallon"
          iMap = 24
        Case "Pulse Count"
          iMap = 25
      End Select
  End Select

  ' Only continue if we found a known type
  If iMap Then
    ' Build up possible update key. e.g. devices.5.instances.1.commandClasses.50.data.2
    sUpdateKey = "devices." & cZWaveNode["node_id"] & ".instances." & iInstanceId & ".commandClasses." & COMMAND_CLASS_METER & ".data." & iType
    UpdateIntervalCCValue(iInstanceId, iMap, cZWaveNode["instances"], sUpdateKey, cData["val"]["value"], cData["scaleString"]["value"], cData["sensorTypeString"]["value"])
  Endif

End

'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
' Add or Update the CommandClass_Meter entry 
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Private Sub UpdateNodeCommandClass_ThermostatSetPoint(iInstanceId As Integer, iType As Integer, cData As JSONCollection, cZWaveNode As JSONCollection)

  Dim sUpdateKey As String
  Dim iMap As Integer

  ' Each Meter Collection should have:
  ' - scaleString/value = string representation of scale Type
  ' - setVal/value = The actual meter value

  If Not cData.Exist("scaleString") Or If Not cData.Exist("setVal") Then
    Main.WriteDebugLog(LogLabel & "ERROR: Z-Wave NodeId '" & cZwaveNode["node_id"] & "' seem to have an invalid COMMAND_CLASS_THERMOSTAT_SETPOINT for '" & iType & "'")
    Return
  Endif

  ' Now try to map the type to a known value
  Select iType
    Case 1 ' Heating
      iMap = 131
    Case 2 ' Cooling
      iMap = 132
    Case 3 ' Unused
      iMap = 133
    Case 4 ' Unused
      iMap = 134
    Case 5 ' Unused
      iMap = 135
    Case 6 ' Unused
      iMap = 136
    Case 7 ' Furnace
      iMap = 137
    Case 8 ' Dry Air
      iMap = 138
    Case 9 ' Moist Air
      iMap = 139
    Case 10 ' Auto Change Over
      iMap = 140
    Case 11 ' Energy Save Heating
      iMap = 141
    Case 12 ' Energy Save Cooling
      iMap = 142
    Case 13 ' Away Heating
      iMap = 143
    Case 14 ' Away Cooling
      iMap = 144
    Case 15 ' Full Power
      iMap = 145
  End Select

  ' Only continue if we found a known type
  If iMap Then
    ' Build up possible update key. e.g. devices.5.instances.1.commandClasses.67.data.2
    sUpdateKey = "devices." & cZWaveNode["node_id"] & ".instances." & iInstanceId & ".commandClasses." & COMMAND_CLASS_THERMOSTAT_SETPOINT & ".data." & iType
    UpdateIntervalCCValue(iInstanceId, iMap, cZWaveNode["instances"], sUpdateKey, cData["val"]["value"], "", cData["scaleString"]["value"])
  Endif

End

'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
' Add or Update the CommandClass_Battery
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Private Sub UpdateNodeCommandClass_Battery(iInstanceId As Integer, cData As JSONCollection, cZWaveNode As JSONCollection)

  Dim iMap As Integer
  Dim sUpdateKey As String

  iMap = 255

  ' Build up possible update key. E.g. devices.5.instances.0.commandClasses.128.data.last
  sUpdateKey = "devices." & cZWaveNode["node_id"] & ".instances." & iInstanceId & ".commandClasses." & COMMAND_CLASS_BATTERY & ".data.last"
  UpdateIntervalCCValue(iInstanceId, iMap, cZWaveNode["instances"], sUpdateKey, cData["value"], "%")

End

'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
' Add or Update the CommandClass_Door_Lock
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Private Sub UpdateNodeCommandClass_DoorLock(iInstanceId As Integer, cData As JSONCollection, cZWaveNode As JSONCollection)

  Dim iMap As Integer
  Dim sUpdateKey As String
  Dim sValue As String

  iMap = 3

  If cData["value"] Then
    sValue = "On"
  Else
    sValue = "Off"
  Endif

  ' Build up possible update key. E.g. devices.5.instances.0.commandClasses.96.data.mode
  sUpdateKey = "devices." & cZWaveNode["node_id"] & ".instances." & iInstanceId & ".commandClasses." & COMMAND_CLASS_DOOR_LOCK & ".data.mode"
  UpdateIntervalCCValue(iInstanceId, iMap, cZWaveNode["instances"], sUpdateKey, sValue)

End

'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
' Send Command
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Public Sub SendCommand(sAddress As String, sCmd As String)

  Dim iLevel As Integer
  Dim fSetPoint As Float
  Dim aAddress As String[]

  Dim iNodeId As Integer
  Dim iInstanceId As Integer
  Dim cZWaveNode As JSONCollection
  Dim iCommandClassId As Integer

  sCmd = UCase(sCmd)

  ' If no instance is supplied, add ":0"
  If Not InStr(sAddress, ":") Then sAddress &= ":0"
  aAddress = Scan(sAddress, "*:*")

  Try iNodeId = CInt(aAddress[0])
  Try iInstanceId = CInt(aAddress[1])

  If iNodeId <= 0 Or If iNodeId > 232 Then
    Main.WriteLog(LogLabel & "ERROR: Invalid Z-Wave NodeId '" & sAddress & "'")
    Return
  Endif

  If Not $cZWaveNetwork.Exist(iNodeId) Then
    Main.WriteLog(LogLabel & "ERROR: Z-Wave NodeId '" & sAddress & "', it doesn't exist in your Z-Wave network")
    Return
  Endif

  cZWaveNode = $cZWaveNetwork[iNodeId]

  ' Check if we have a true multi-instance device, else we need to use instance 1
  If cZWaveNode["multiinstance"] Then
    If iInstanceId = 0 Then iInstanceId = 1
  Endif

  If Not cZWaveNode["instances"].Exist(iInstanceId) Then
    Main.WriteLog(LogLabel & "ERROR: Z-Wave NodeId '" & sAddress & "', has an invalid Instance '" & iInstanceId & "'")
    Return
  Endif

  If cZWaveNode["instances"][iInstanceId]["commandclasses"].Exist(COMMAND_CLASS_SWITCH_MULTILEVEL) Then
    iCommandClassId = COMMAND_CLASS_SWITCH_MULTILEVEL
  Else If cZWaveNode["instances"][iInstanceId]["commandclasses"].Exist(COMMAND_CLASS_SWITCH_BINARY) Then
    iCommandClassId = COMMAND_CLASS_SWITCH_BINARY
  Else If cZWaveNode["instances"][iInstanceId]["commandclasses"].Exist(COMMAND_CLASS_DOOR_LOCK) Then
    iCommandClassId = COMMAND_CLASS_DOOR_LOCK
  Else If cZWaveNode["instances"][iInstanceId]["commandclasses"].Exist(COMMAND_CLASS_THERMOSTAT_SETPOINT) Then
    iCommandClassId = COMMAND_CLASS_THERMOSTAT_SETPOINT
  Endif

  If Not iCommandClassId Then
    Main.WriteDebugLog(LogLabel & "ERROR: CommandClassId not found for device with address '" & sAddress & "', so I can't control it!")
    Return
  Endif

  If sCmd = "ON" Then
    iLevel = 255
  Else If sCmd = "OFF" Then
    iLevel = 0
  Else If InStr(sCmd, "DIM ") Then
    iLevel = Val(Replace(sCmd, "DIM ", ""))
    If iLevel = 100 Then iLevel = 99
  Else If InStr(sCmd, "SP ") Then
    fSetPoint = Val(Replace(sCmd, "SP ", ""))
  Else
    Main.WriteDebugLog(LogLabel & "ERROR: Unknown command '" & sCmd & "' given!")
    Return
  Endif

  Select iCommandClassId
    Case COMMAND_CLASS_THERMOSTAT_SETPOINT
      QueueCommand(GetURL("/ZWaveAPI/Run/devices[" & iNodeId & "].instances[" & iInstanceId & "].commandClasses[" & iCommandClassId & "].Set(1," & fSetPoint & ")"))
    Case Else
      QueueCommand(GetURL("/ZWaveAPI/Run/devices[" & iNodeId & "].instances[" & iInstanceId & "].commandClasses[" & iCommandClassId & "].Set(" & iLevel & ")"))
  End Select

End

'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
'
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Public Sub GetUpdates()

  Dim sUrl As String = GetURL("/ZWaveAPI/Data/" & $iUpdateTime)

  If $bDebug Then Main.WriteDebugLog(LogLabel & "Get update by fetching '" & sUrl & "'")
  QueueCommand(sUrl)

End

'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
' add command to queue
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Private Sub QueueCommand(sPacket As String)

  ' add command to queue
  cQueue.Add(sPacket, Rnd)

  ' if not busy process it
  If bHttpBusy = False Then DoQueue()

End

'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
' process items in queue
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Private Sub DoQueue()

  Dim sPacket As String

  For Each sPacket In cQueue
    WriteCommand(sPacket, cQueue.Key)
    Break ' only do first one
  Next

End

'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
'
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Private Sub WriteCommand(sWBuffer As String, sKey As String)

  hRaZberryCmd = New HttpClient As "hRaZberryCmd"
  hRaZberryCmd.URL = sWBuffer
  hRaZberryCmd.Async = True
  hRaZberryCmd.TimeOut = 3
  hRaZberryCmd.Tag = sKey
  hRaZberryCmd.Post("application/json", "")
  bHttpBusy = True
  If $bDebug Then Main.WriteDebugLog(LogLabel & "Send HTTPGet request '" & sWBuffer & "'")

  IsRunning = True
  ErrorText = ""

Catch ' some errors
  Main.WriteLog(LogLabel & "ERROR: '" & Error.Text & "' at '" & Error.Where & "'")

  IsRunning = False
  ErrorText = Error.Text
  ErrorWhere = Error.Where

End

'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
' collect razberry data
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Public Sub hRaZberryCmd_Read()

  If Lof(Last) Then sBuffer &= Read #Last, Lof(Last)

End

'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
' razberry data fetched
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Public Sub hRaZberryCmd_Finished()

  Select hRaZberryCmd.Code
    Case 200
      ' too noisy
      If $bDebug Then Main.WriteDebugLog(LogLabel & "Received data '" & sBuffer & "'")
      ParseUpdateData(sBuffer)
    Case Else
      Main.WriteDebugLog(LogLabel & "Unknown error occured while trying to get RaZberry update data! HTTP=" & Last.Code & ", Buffer=" & sBuffer)
  End Select

  sBuffer = Null
  Try hRaZberryCmd.Close
  HttpBusy(hRaZberryCmd.Tag)

End

'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
' 
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Public Sub hRaZberryCmd_Error()

  Dim sMsg As String

  If Not $bDebug Then Return

  sMsg = Log.Text_TCP_Error(Last.Status, $sTCPHost)
  Main.WriteLog(LogLabel & "ERROR: " & sMsg)

  IsRunning = False
  ErrorText = sMsg

  Log.Plugin_TCP_Error(LogLabel, $sTCPHost, Last.Status)
  HttpBusy(hRaZberryCmd.Tag)

End

'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
' http busy reset
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Public Sub HttpBusy(sKey As String)

  bHttpBusy = False
  ' remove sent command from queue
  cQueue.Remove(sKey)

  If cQueue.Count Then ' if there are more commands left in queue, send next one
    If $bDebug Then Main.WriteDebugLog(LogLabel & "Sending command from Queue (count = " & cQueue.Count & ")")
    DoQueue()
  Endif

End

'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
' Process Device Status update(s)
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Private Sub ParseUpdateData(sData As String)

  Dim cUpdate As JSONCollection

  If sData = "null" Then
    If $bDebug Then Main.WriteDebugLog(LogLabel & "Got a device control response.")
    Return
  Else
    cUpdate = JSON.Decode(sData, True)
  Endif

  If cUpdate Then
    $iUpdateTime = cUpdate["updateTime"]
    If $bDebug Then
      Main.WriteDebugLog(LogLabel & "Update Timestamp: " & Util.TimeSinceEpoch($iUpdateTime) & " (" & $iUpdateTime & ")")
    Endif
    If cUpdate.Count > 1 Then
      ParseUpdateDevices(cUpdate)
    Else
      If $bDebug Then Main.WriteDebugLog(LogLabel & "No updates reported.")
    Endif
  Else
    If $bDebug Then Main.WriteDebugLog(LogLabel & "Error received invalid JSON update data!")
  Endif

Catch ' some errors
  Main.WriteDebugLog(LogLabel & "ERROR: '" & Error.Text & "' at '" & Error.Where & "'")

End

'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
'
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Private Sub ParseUpdateDevices(cUpdates As JSONCollection)

  Dim cUpdate As New JSONCollection
  Dim aUpdate As String[]
  Dim vValue, vValue2, vValue3, vValue4, vValueTemp As Variant
  Dim sScale, sSensorType As String
  Dim iNode, iInstance, iBattery, iScale, iDeviceId As Integer

  If $bDebug Then Main.WriteDebugLog(LogLabel & "Found " & cUpdates.Count & " updates.")
  ' go through each update
  For Each cUpdate In cUpdates

    ' skip controller node
    aUpdate = Split(cUpdates.Key, ".")
    If aUpdate.Count > 1 Then
      If aUpdate[1] = $cZWaveNetwork["controller"]["controllerid"] Then 
        If $bDebug Then Main.WriteDebugLog(LogLabel & "Skipping controller node updates")
        Continue
      Endif

      ' search for interesting data
      ' battery value
      If InStr(cUpdates.Key, "commandClasses.128.data.last") Then
        aUpdate = Split(cUpdates.Key, ".")
        If aUpdate.Count = 8 Then
          iNode = aUpdate[1]
          iInstance = aUpdate[3]
          iBattery = cUpdate["value"]
          If $bDebug Then
            Main.WriteDebugLog(LogLabel & "Node: #" & iNode)
            Main.WriteDebugLog(LogLabel & "Instance: #" & iInstance)
            Main.WriteDebugLog(LogLabel & "Battery Value Update: " & iBattery)
          Endif
          ' update battery status
          iDeviceId = Devices.Find(Instance, iNode & IIf((iInstance > 1), ":" & iInstance, ""), InterfaceId)
          If iDeviceId Then
            Devices.Battery(iDeviceId, iBattery)
          Endif
        Else
          If $bDebug Then Main.WriteDebugLog(LogLabel & "Unknown update string: " & cUpdates.Key)
        Endif
      ' SP814 Motion sensor Everspring or old TKBHOME
      ' "devices.8.instances.0.commandClasses.48.data.1"
      Else If InStr(cUpdates.Key, "commandClasses.48.data.1") Then
        If aUpdate.Count = 8 Then
          vValue = IIf((cUpdate["level"]["value"] = True), "On", "Off")
          iNode = aUpdate[1]
          iInstance = aUpdate[3]
          iDeviceId = Devices.Find(Instance, iNode & IIf((iInstance > 1), ":" & iInstance, ""), InterfaceId)
          If iDeviceId Then
            Devices.ValueUpdate(iDeviceId, 1, vValue)
          Endif
        Else
          If $bDebug Then Main.WriteDebugLog(LogLabel & "Unknown update string: " & cUpdates.Key)
        Endif
      ' Everspring Flood Sensor ST812
      ' "devices.7.instances.0.commandClasses.156.data.5.sensorState"
      Else If InStr(cUpdates.Key, "commandClasses.156.data.5.sensorState") Then
        If aUpdate.Count = 9 Then
          vValue = IIf((cUpdate["value"] = 255), "On", "Off")
          iNode = aUpdate[1]
          iInstance = aUpdate[3]
          iDeviceId = Devices.Find(Instance, iNode & IIf((iInstance > 1), ":" & iInstance, ""), InterfaceId)
          If iDeviceId Then
            Devices.ValueUpdate(iDeviceId, 1, vValue)
          Endif
        Else
          If $bDebug Then Main.WriteDebugLog(LogLabel & "Unknown update string: " & cUpdates.Key)
        Endif
      ' sensor multilevel, but binary switch eg pir, d/w sensor
      ' "devices.8.instances.0.commandClasses.48.data.level"
      Else If InStr(cUpdates.Key, "commandClasses.48.data.level") Then
        aUpdate = Split(cUpdates.Key, ".")
        If aUpdate.Count = 8 Then
          iNode = aUpdate[1]
          iInstance = aUpdate[3]

          If $bDebug Then
            Main.WriteDebugLog(LogLabel & "Node: #" & iNode)
            Main.WriteDebugLog(LogLabel & "Instance: #" & iInstance)
            Main.WriteDebugLog(LogLabel & "Sensor Multilevel Binary Value1 Update: " & vValue)
          Endif
          vValue = IIf((cUpdate["value"] = True), "Open", "Closed")
          ' update device value(s)
          iDeviceId = Devices.Find(Instance, iNode & IIf((iInstance > 1), ":" & iInstance, ""), InterfaceId)
          If iDeviceId Then
            Devices.ValueUpdate(iDeviceId, 1, vValue)
          Endif
        Else
          If $bDebug Then Main.WriteDebugLog(LogLabel & "Unknown update string: " & cUpdates.Key)
        Endif
      ' binary switch device
      Else If InStr(cUpdates.Key, "commandClasses.37.data.level") Then
        aUpdate = Split(cUpdates.Key, ".")
        If aUpdate.Count = 8 Then
          iNode = aUpdate[1]
          iInstance = aUpdate[3]
          vValue = IIf((cUpdate["value"] = 255) Or (cUpdate["value"] = True), "On", "Off")
          If $bDebug Then
            Main.WriteDebugLog(LogLabel & "Node: #" & iNode)
            Main.WriteDebugLog(LogLabel & "Instance: #" & iInstance)
            Main.WriteDebugLog(LogLabel & "Switch Value1 Update: " & vValue)
          Endif
          ' update device value(s)
          iDeviceId = Devices.Find(Instance, iNode & IIf((iInstance > 1), ":" & iInstance, ""), InterfaceId)
          If iDeviceId Then
            Devices.ValueUpdate(iDeviceId, 1, vValue)
          Endif
        Else
          If $bDebug Then Main.WriteDebugLog(LogLabel & "Unknown update string: " & cUpdates.Key)
        Endif
      ' dimmer device
      Else If InStr(cUpdates.Key, "commandClasses.38.data.level") Then
        aUpdate = Split(cUpdates.Key, ".")
        If aUpdate.Count = 8 Then
          iNode = aUpdate[1]
          iInstance = aUpdate[3]
          vValue = "Dim " & cUpdate["value"]
          If vValue = "Dim 99" Then vValue = "On"
          If vValue = "Dim 0" Then vValue = "Off"
          If $bDebug Then
            Main.WriteDebugLog(LogLabel & "Node: #" & iNode)
            Main.WriteDebugLog(LogLabel & "Instance: #" & iInstance)
            Main.WriteDebugLog(LogLabel & "Dimmer Value1 Update: " & vValue)
          Endif
          ' update device value(s)
          iDeviceId = Devices.Find(Instance, iNode & IIf((iInstance > 1), ":" & iInstance, ""), InterfaceId)
          If iDeviceId Then
            Devices.ValueUpdate(iDeviceId, 1, vValue)
          Endif
        Else
          If $bDebug Then Main.WriteDebugLog(LogLabel & "Unknown update string: " & cUpdates.Key)
        Endif
      ' multilevel sensor
      Else If InStr(cUpdates.Key, "commandClasses.49.data.level") Then
        aUpdate = Split(cUpdates.Key, ".")
        If aUpdate.Count = 8 Then
          iNode = aUpdate[1]
          iInstance = aUpdate[3]
          vValue = cUpdate["val"]["value"]
          If $bDebug Then
            Main.WriteDebugLog(LogLabel & "Node: #" & iNode)
            Main.WriteDebugLog(LogLabel & "Instance: #" & iInstance)
            Main.WriteDebugLog(LogLabel & "Multilevel Sensor Value1 Update: " & vValue)
          Endif
          ' update device value(s)
          iDeviceId = Devices.Find(Instance, iNode & IIf((iInstance > 1), ":" & iInstance, ""), InterfaceId)
          If iDeviceId Then
            Devices.ValueUpdate(iDeviceId, 1, vValue)
          Endif
        Else
          If $bDebug Then Main.WriteDebugLog(LogLabel & "Unknown update string: " & cUpdates.Key)
        Endif
      ' thermostat
      Else If InStr(cUpdates.Key, "commandClasses.67.data.")
        aUpdate = Split(cUpdates.Key, ".")
        If aUpdate.Count = 8 Then
           iNode = aUpdate[1]
           iInstance = aUpdate[3]
           If cUpdate["setVal"]["value"] Then vValue2 = cUpdate["setVal"]["value"]
           If $bDebug Then
            Main.WriteDebugLog(LogLabel & "Node: #" & iNode)
            Main.WriteDebugLog(LogLabel & "Instance: #" & iInstance)
            Main.WriteDebugLog(LogLabel & "Thermostat Value2 (setVal) Update: " & vValue2)
          Endif
          ' update device value(s)
          iDeviceId = Devices.Find(Instance, iNode & IIf((iInstance), ":" & iInstance, ""), InterfaceId)
          If iDeviceId Then
            'Devices.ValueUpdate(iDeviceId, 1, vValue)
            Devices.ValueUpdate(iDeviceId, 2, vValue2)
          Endif
        Else
          If $bDebug Then Main.WriteDebugLog(LogLabel & "Unknown update string: " & cUpdates.Key)
        Endif
      ' "devices.3.instances.0.commandClasses.49.data.4"
       Else If InStr(cUpdates.Key, "commandClasses.49.data.") Then
        aUpdate = Split(cUpdates.Key, ".")
        If aUpdate.Count = 8 Then
          iNode = aUpdate[1]
          iInstance = aUpdate[3]
          iScale = aUpdate[7]
          sScale = cUpdate["scaleString"]["value"]
          sSensorType = Trim(cUpdate["sensorTypeString"]["value"])
          vValueTemp = cUpdate["val"]["value"]
          If iScale = 4 Then
            ' W value4
            vValue4 = vValueTemp
          Endif
          If $bDebug Then
            Main.WriteDebugLog(LogLabel & "Node: #" & iNode)
            Main.WriteDebugLog(LogLabel & "Instance: #" & iInstance)
            Main.WriteDebugLog(LogLabel & "Scale: " & iScale)
            Main.WriteDebugLog(LogLabel & "Type: " & sSensorType)
            If iScale = 4 Then Main.WriteDebugLog(LogLabel & "Power Sensor value4 Update: " & vValue4 & sScale)
          Endif
          iDeviceId = Devices.Find(Instance, iNode & IIf((iInstance > 1), ":" & iInstance, ""), InterfaceId)
          If iDeviceId Then
            Devices.ValueUpdate(iDeviceId, 1, vValue)
            Devices.ValueUpdate(iDeviceId, 2, vValue2)
            Devices.ValueUpdate(iDeviceId, 3, vValue3)
            Devices.ValueUpdate(iDeviceId, 4, vValue4)
          Endif
        Else
          If $bDebug Then Main.WriteDebugLog(LogLabel & "Unknown update string: " & cUpdates.Key)
        Endif
      ' meter device
      ' "devices.5.instances.1.commandClasses.50.data.2"
      Else If InStr(cUpdates.Key, "commandClasses.50.data.") Then
        aUpdate = Split(cUpdates.Key, ".")
        If aUpdate.Count = 8 Then
          iNode = aUpdate[1]
          iInstance = aUpdate[3]
          iScale = aUpdate[7]
          sScale = cUpdate["scaleString"]["value"]
          sSensorType = Trim(cUpdate["sensorTypeString"]["value"])
          vValueTemp = cUpdate["val"]["value"]
          If iScale = 0 Then
            ' KwH value3
            vValue3 = vValueTemp
          Else If iScale = 2 Then
            ' W value2
            vValue2 = vValueTemp
          Endif
          If $bDebug Then
            Main.WriteDebugLog(LogLabel & "Node: #" & iNode)
            Main.WriteDebugLog(LogLabel & "Instance: #" & iInstance)
            Main.WriteDebugLog(LogLabel & "Scale: " & iScale)
            Main.WriteDebugLog(LogLabel & "Type: " & sSensorType)
            If iScale = 2 Then Main.WriteDebugLog(LogLabel & "Sensor Multilevel Binary Value2 Update: " & vValue2 & sScale)
            If iScale = 0 Then Main.WriteDebugLog(LogLabel & "Sensor Multilevel Binary Value3 Update: " & vValue3 & sScale)
          Endif
          ' update device value(s)
          iDeviceId = Devices.Find(Instance, iNode & IIf((iInstance > 1), ":" & iInstance, ""), InterfaceId)
          If iDeviceId Then
            Devices.ValueUpdate(iDeviceId, 1, vValue)
            Devices.ValueUpdate(iDeviceId, 2, vValue2)
            Devices.ValueUpdate(iDeviceId, 3, vValue3)
          Endif
        Else
          If $bDebug Then Main.WriteDebugLog(LogLabel & "Unknown update string: " & cUpdates.Key)
        Endif
      Endif
      ' TODO: add commandClass 98

      ' clear stuff
      vValue = ""
      vValue2 = ""
      vValue3 = ""
      vValue4 = ""
      vValueTemp = ""
    Endif
  Next

Catch ' some errors
  If Error.code <> 6 Then ' suppress reading updatetime as collection
    Main.WriteDebugLog(LogLabel & "ERROR: '" & Error.Text & "' at '" & Error.Where & "' " & Error.Code)
  Else
    Error.Clear
  Endif

End

'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
' disconnect from the host
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Private Sub Disconnect()

  ' try to stop timer
  Try tRaZberry.Stop
  ' try to close all connections
  Try hRaZberryInit.Close
  Try hRaZberryCmd.Close

  Main.WriteLog(LogLabel & PluginFriendlyName & " closed.")

Finally
  IsRunning = False
  ErrorText = ""
  ErrorWhere = ""

Catch
  Main.WriteLog(LogLabel & "ERROR: " & Error.Text)

End

'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
' Display Z-Wave BasicType name
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Private Sub GetBasicTypeName(iBasic As Integer) As String

  Select iBasic
    Case BASIC_TYPE_CONTROLLER
      Return "Controller"
    Case BASIC_TYPE_STATIC_CONTROLLER
      Return "Static Controller"
    Case BASIC_TYPE_SLAVE
      Return "Slave"
    Case BASIC_TYPE_ROUTING_SLAVE
      Return "Routing Slave"
    Default
      Return "Unknown (" & iBasic & ")"
  End Select

End

'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
' Display Z-Wave GenericType name
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Private Sub GetGenericTypeName(iGeneric As Integer) As String

  Return GetSpecificTypeName(iGeneric, 0)

End

'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
' Display Z-Wave SpecificType name
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Private Sub GetSpecificTypeName(iGenericType As Integer, iSpecificType As Integer) As String

  Select iGenericType 
    Case GENERIC_TYPE_GENERIC_CONTROLLER
      Select iSpecificType
        Case &H01
          Return "Portable Remote Controller"
        Case &H02
          Return "Portable Scene Controller"
        Case &H03
          Return "Portable Installer Tool"
      End Select
      Return "Generic Controller"
    Case GENERIC_TYPE_STATIC_CONTROLLER
      Select iSpecificType
        Case &H01
          Return "Static PC Controller"
        Case &H02
          Return "Static Scene Controller"
        Case &H03
          Return "Static Installer Tool"
      End Select
      Return "Static Controller"
    Case GENERIC_TYPE_AV_CONTROL_POINT
      Select iSpecificType
        Case &H04
          Return "Satellite Receiver"
        Case &H11
          Return "Satellite Receiver V2"
        Case &H12
          Return "Doorbell"
      End Select
      Return "AV Control Point"
    Case GENERIC_TYPE_DISPLAY
      Select iSpecificType
        Case &H01
          Return "Simple Display"
      End Select
      Return "Display"
    Case GENERIC_TYPE_THERMOSTAT
      Select iSpecificType
        Case &H01
          Return "Heating Thermostat"
        Case &H02
          Return "General Thermostat"
        Case &H03
          Return "Setback Schedule Thermostat"
        Case &H04
          Return "Setpoint Thermostat"
        Case &H05
          Return "Setback Thermostat"
        Case &H06
          Return "General Thermostat V2"
      End Select
      Return "Thermostat"
    Case GENERIC_TYPE_WINDOW_COVERING
      Select iSpecificType
        Case &H01
          Return "Simple Window Covering"
      End Select
      Return "Window Covering"
    Case GENERIC_TYPE_REPEATER_SLAVE
      Select iSpecificType
        Case &H01
          Return "Basic Repeater Slave"
      End Select
      Return "Repeating Slave"
    Case GENERIC_TYPE_SWITCH_BINARY
      Select iSpecificType
        Case &H01
          Return "Binary Power Switch"
        Case &H03
          Return "Binary Scene Switch"
      End Select
      Return "Binary Switch"
    Case GENERIC_TYPE_SWITCH_MULTILEVEL
      Select iSpecificType
        Case &H01
          Return "Multilevel Power Switch"
        Case &H03
          Return "Multiposition Motor"
        Case &H04
          Return "Multilevel Scene Switch"
        Case &H05
          Return "Motor Control Class A"
        Case &H06
          Return "Motor Control Class B"
        Case &H07
          Return "Motor Control Class C"
      End Select
      Return "Multilevel Switch"
    Case GENERIC_TYPE_SWITCH_REMOTE
      Select iSpecificType
        Case &H01
          Return "Binary Remote Switch"
        Case &H02
          Return "Multilevel Remote Switch"
        Case &H03
          Return "Binary Toggle Remote Switch"
        Case &H04
          Return "Multilevel Toggle Remote Switch"
      End Select
      Return "Remote Switch"
    Case GENERIC_TYPE_SWITCH_TOGGLE
      Select iSpecificType
        Case &H01
          Return "Binary Toggle Switch"
        Case &H02
          Return "Multilevel Toggle Switch"
      End Select
      Return "Toggle Switch"
    Case GENERIC_TYPE_ZIP_GATEWAY
      Select iSpecificType
        Case &H01
          Return "Z/IP Tunneling Gateway"
        Case &H02
          Return "Z/IP Advanced Gateway"
      End Select
      Return "Zip Gateway"
    Case GENERIC_TYPE_ZIP_NODE
      Select iSpecificType
        Case &H01
          Return "Z/IP Tunneling Node"
        Case &H02
          Return "Z/IP Advanced Node"
      End Select
      Return "Zip Node"
    Case GENERIC_TYPE_VENTILATION
      Select iSpecificType
        Case &H01
          Return "Residential Heat Recovery Ventilation"
      End Select
      Return "Ventilation"
    Case GENERIC_TYPE_SENSOR_BINARY
      Select iSpecificType
        Case &H01
          Return "Routing Binary Sensor"
      End Select
      Return "Binary Sensor"
    Case GENERIC_TYPE_SENSOR_MULTILEVEL
      Select iSpecificType
        Case &H01
          Return "Routing Multilevel Sensor"
      End Select
      Return "Multilevel Sensor"
    Case GENERIC_TYPE_METER_PULSE
      Return "Pulse Meter"
    Case GENERIC_TYPE_METER
      Select iSpecificType
        Case &H01
          Return "Simple Meter"
      End Select
      Return "Meter"
    Case GENERIC_TYPE_ENTRY_CONTROL
      Select iSpecificType
        Case &H01
          Return "Door Lock"
        Case &H02
          Return "Advanced Door Lock"
        Case &H03
          Return "Secure Keypad Door Lock"
      End Select
      Return "Entry Control"
    Case GENERIC_TYPE_SEMI_INTEROPERABLE
      Select iSpecificType
        Case &H01
          Return "Energy Production"
      End Select
      Return "Semi Interoperable"
    Case GENERIC_TYPE_SENSOR_ALARM
      Select iSpecificType
        Case &H01
          Return "Basic Routing Alarm Sensor"
        Case &H02
          Return "Routing Alarm Sensor"
        Case &H03
          Return "Basic Zensor Alarm Sensor"
        Case &H04
          Return "Zensor Alarm Sensor"
        Case &H05
          Return "Advanced Zensor Alarm Sensor"
        Case &H06
          Return "Basic Routing Smoke Sensor"
        Case &H07
          Return "Routing Smoke Sensor"
        Case &H08
          Return "Basic Zensor Smoke Sensor"
        Case &H09
          Return "Zensor Smoke Sensor"
        Case &H0A
          Return "Advanced Zensor Smoke Sensor"
      End Select
      Return "Alarm Sensor"
    Case GENERIC_TYPE_NON_INTEROPERABLE
      Return "Non Interoperable"
    Default
      Return "Unknown (" & iGenericType & ")"
  End Select

End
