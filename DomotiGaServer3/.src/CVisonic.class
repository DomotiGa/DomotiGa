' Gambas class file

' Description:
' CVisonic.class
' Support for Visonic PowerMax/PowerMaster Alarm
'
' Development Status:
' Initial testing build

' TODO:
' Build Visonic Commander

' Links:
' http://www.domoticaforum.eu/viewtopic.php?f=68&t=6517

' Credits:
' Initial setup by Wouter Wolkers and Alexander Kuiper.
' Thanks to everyone who helped decode the data.

' DomotiGa - an open source home automation program.
' Copyright (C) Ron Klinkien, The Netherlands.

' Read file called COPYING for license details.

'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
' Module/Class specific variables 
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Public PluginName As String = "Visonic"
Public PluginFriendlyName As String = "Visonic Security"
Public PluginVersion As String = "0.91"
Public PluginAuthor As String = "Wouter Wolkers, Alexander Kuiper"
Public PluginProtocols As String[]
Public PluginMaxInstances As Integer = 1

Public KeyName As String
Public LogLabel As String = "[Visonic] "
Public Instance As Integer
Public InterfaceId As Integer = 0
Public IsRunning As Boolean
Public ErrorText As String
Public ErrorWhere As String

'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
' Queue structure
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Public Struct VisonicQueueEntry
  Msg As String
  Command As Byte[]
  Receive As Byte
  ReceiveCnt As Integer 
  ReceiveCntFixed As Integer ' Need to store it extra, because with a re-queue it can get lost
  ReceiveRetries As Integer
  Options As String
End Struct

'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
' Private variables
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Private $bEnabled As Boolean
Private $sSerPort As String
Private $bDebug As Boolean
Private $iMasterCode As Integer = &H0000 ' Not Known
Private $iDisarmArmCode As Integer = &H0000 ' Not Known
Private $iDownloadCode As Integer = &H5650 ' VP
Private $bSendInit As Boolean = False
Private $iTripReset As Integer = 30 ' Reset status after 30 seconds

Private $tPowerLinkKeepAlive As New Timer As "tPowerLinkKeepAlive"
Public hVisonic As New SerialPort

' Receive command buffer
Private $bReceiveHeaderFound As Boolean = False ' When 0D char is detected
Private $tReceiveLast0DChar As Date ' When last 0D char is received
Private $sReceiveBuffer As New Byte[] ' Complete buffer of received data, including pre, crc and postamble
Private $sReceiveData As New Byte[] ' buffer without pre, crc and postamble (complete command, with valid crc)
Private $dReceiveLastPacket As Date ' When last 'ReceiveData' packet is received

Private $cSendLastCommand As VisonicQueueEntry
Private $cSendQueue As New Object[]

Const $iPowerLinkTimeOut As Integer = 60000 ' 60 seconds
Const $iSendDelay As Integer = 500 ' 500 msec delay between last received message and the new message
Const $iSendTimeout As Integer = 1000 ' 1000 msec wait on a response
Const $iReceiveCompletePacketTimeout As Integer = 3000 ' 3000msec to wait on a complete packet

Private $bDownloadMode As Boolean
Private $bInitialized As Boolean
Private $iPanelType As Byte
Private $iModelType As Byte
Private $bPowerMaster As Boolean

Private $tQueueDelay As New Timer As "tQueueDelay"
Private $tQueueTimeout As New Timer As "tQueueTimeout"
Private $oTripTimers As New Object[]
Public $tTripTimer As CTimerGeneric

Private $cConfig As New Collection
Private $cMemoryMap As New Collection

'########################################################
' PowerMax/Master send messages
'########################################################

' ### ACK messages, depending on the type, we need to ACK differently ###
Private VMSG_ACK1 As Byte[] = [&H02] 'NONE
Private VMSG_ACK2 As Byte[] = [&H02, &H43] 'NONE

' ### Init, restore and enroll messages ###
Private VMSG_INIT As Byte[] = [&HAB, &H0A, &H00, &H01, &H00, &H00, &H00, &H00, &H00, &H00, &H00, &H43] 'NONE
Private VMSG_RESTORE As Byte[] = [&HAB, &H06, &H00, &H00, &H00, &H00, &H00, &H00, &H00, &H00, &H00, &H43] 'NONE
Private VMSG_ENROLL As Byte[] = [&HAB, &H0A, &H00, &H00, &H00, &H00, &H00, &H00, &H00, &H00, &H00, &H43] 'NONE - DownloadCode: 4 & 5

Private VMSG_ARMDISARM As Byte[] = [&HA1, &H00, &H00, &H00, &H00, &H00, &H00, &H00, &H00, &H00, &H00, &H43] 'NONE - MasterCode: 4 & 5
Private VMSG_STATUS As Byte[] = [&HA2, &H00, &H00, &H00, &H00, &H00, &H00, &H00, &H00, &H00, &H00, &H43] 'A5
Private VMSG_EVENTLOG As Byte[] = [&HA0, &H00, &H00, &H00, &H00, &H00, &H00, &H00, &H00, &H00, &H00, &H43] 'A0 - MasterCode: 4 & 5

' #### PowerMaster message ###
Private VMSG_PMASTER_STAT1 As Byte[] = [&HB0, &H01, &H04, &H06, &H02, &HFF, &H08, &H03, &H00, &H00, &H43] 'B0 STAT1
Private VMSG_PMASTER_STAT2 As Byte[] = [&HB0, &H01, &H07, &H06, &H02, &HFF, &H08, &H03, &H00, &H00, &H43] 'B0 STAT2

' ### Start/stop download information ###
Private VMSG_DL_START As Byte[] = [&H24, &H00, &H00, &H01, &H00, &H00, &H00, &H00, &H00, &H00, &H00] '&H3C - DownloadCode: 3 & 4
Private VMSG_DL_GET As Byte[] = [&H0A] '&H33
Private VMSG_DL_EXIT As Byte[] = [&H0F] 'NONE

' ### PowerMax download/config items (some apply to PowerMaster too) ###
' 1=Index, 2=Page, 3=Low Length, 4=High Length
Private VMSG_DL_PANELFW As Byte[] = [&H3E, &H00, &H04, &H20, &H00, &HB0, &H00, &H00, &H00, &H00, &H00] '&H3F
Private VMSG_DL_ZONESTR As Byte[] = [&H3E, &H00, &H19, &H00, &H02, &HB0, &H00, &H00, &H00, &H00, &H00] '&H3F
Private VMSG_DL_SERIAL As Byte[] = [&H3E, &H30, &H04, &H08, &H00, &HB0, &H00, &H00, &H00, &H00, &H00] '&H3F
Private VMSG_DL_EVENTLOG As Byte[] = [&H3E, &HDF, &H04, &H28, &H03, &HB0, &H00, &H00, &H00, &H00, &H00] '&H3F
Private VMSG_DL_TIME As Byte[] = [&H3E, &HF8, &H00, &H20, &H00, &HB0, &H00, &H00, &H00, &H00, &H00] '&H3F
Private vMSG_DL_COMMDEF As Byte[] = [&H3E, &H01, &H01, &H1E, &H00, &HB0, &H00, &H00, &H00, &H00, &H00] '&H3F
Private VMSG_DL_USERPINCODES As Byte[] = [&H3E, &HFA, &H01, &H10, &H00, &HB0, &H00, &H00, &H00, &H00, &H00] '&H3F
Private VMSG_DL_OTHERPINCODES As Byte[] = [&H3E, &H0A, &H02, &H0A, &H00, &HB0, &H00, &H00, &H00, &H00, &H00] '&H3F
Private VMSG_DL_PHONENRS As Byte[] = [&H3E, &H36, &H01, &H20, &H00, &HB0, &H00, &H00, &H00, &H00, &H00] '&H3F
Private VMSG_DL_PGMX10 As Byte[] = [&H3E, &H14, &H02, &HD5, &H00, &HB0, &H00, &H00, &H00, &H00, &H00] '&H3F
Private VMSG_DL_PARTITIONS As Byte[] = [&H3E, &H00, &H03, &HF0, &H00, &HB0, &H00, &H00, &H00, &H00, &H00] '&H3F
Private VMSG_DL_ZONES As Byte[] = [&H3E, &H00, &H09, &H78, &H00, &HB0, &H00, &H00, &H00, &H00, &H00] '&H3F
Private VMSG_DL_KEYFOBS As Byte[] = [&H3E, &H78, &H09, &H40, &H00, &HB0, &H00, &H00, &H00, &H00, &H00] '&H3F
Private VMSG_DL_2WKEYPADS As Byte[] = [&H3E, &H00, &H0A, &H08, &H00, &HB0, &H00, &H00, &H00, &H00, &H00] '&H3F
Private VMSG_DL_1WKEYPADS As Byte[] = [&H3E, &H20, &H0A, &H40, &H00, &HB0, &H00, &H00, &H00, &H00, &H00] '&H3F
Private VMSG_DL_SIRENS As Byte[] = [&H3E, &H60, &H0A, &H08, &H00, &HB0, &H00, &H00, &H00, &H00, &H00] '&H3F
Private VMSG_DL_X10NAMES As Byte[] = [&H3E, &H30, &H0B, &H10, &H00, &HB0, &H00, &H00, &H00, &H00, &H00] '&H3F
Private VMSG_DL_ZONENAMES As Byte[] = [&H3E, &H40, &H0B, &H1E, &H00, &HB0, &H00, &H00, &H00, &H00, &H00] '&H3F
Private VMSG_DL_ZONECUSTOM As Byte[] = [&H3E, &HA0, &H1A, &H50, &H00, &HB0, &H00, &H00, &H00, &H00, &H00] '&H3F

' ### PowerMaster download/config items ###
Private VMSG_DL_MASTER_SIRENKEYPADSZONE As Byte[] = [&H3E, &HE2, &HB6, &H10, &H04, &HB0, &H00, &H00, &H00, &H00, &H00] '&H3F
Private VMSG_DL_MASTER_USERPINCODES As Byte[] = [&H3E, &H98, &H0A, &H60, &H00, &HB0, &H00, &H00, &H00, &H00, &H00] '&H3F
Private VMSG_DL_MASTER_SIRENS As Byte[] = [&H3E, &HE2, &HB6, &H50, &H00, &HB0, &H00, &H00, &H00, &H00, &H00] '&H3F
Private VMSG_DL_MASTER_KEYPADS As Byte[] = [&H3E, &H32, &HB7, &H40, &H01, &HB0, &H00, &H00, &H00, &H00, &H00] '&H3F
Private VMSG_DL_MASTER_ZONENAMES As Byte[] = [&H3E, &H60, &H09, &H40, &H00, &HB0, &H00, &H00, &H00, &H00, &H00] '&H3F
Private VMSG_DL_MASTER_ZONES As Byte[] = [&H3E, &H72, &HB8, &H80, &H02, &HB0, &H00, &H00, &H00, &H00, &H00] '&H3F

Private VMSG_SET_DATETIME As Byte[] = [&H46, &HF8, &H00, &H00, &H00, &H00, &H00, &H00, &H00, &HFF, &HFF] '&H46

'########################################################
' PowerMax/Master definitions for partitions, events, keyfobs, etc
'########################################################

Private VCFG_PARTITIONS As Byte[] = [1, 1, 1, 1, 3, 3, 1, 3, 3]
Private VCFG_EVENTS As Integer[] = [250, 250, 250, 250, 250, 250, 250, 250, 1000]
Private VCFG_KEYFOBS As Byte[] = [8, 8, 8, 8, 8, 8, 8, 8, 32]
Private VCFG_1WKEYPADS As Byte[] = [8, 8, 8, 8, 8, 8, 8, 0, 0]
Private VCFG_2WKEYPADS As Byte[] = [2, 2, 2, 2, 2, 2, 2, 8, 32]
Private VCFG_SIRENS As Byte[] = [2, 2, 2, 2, 2, 2, 2, 4, 8]
Private VCFG_USERCODES As Byte[] = [8, 8, 8, 8, 8, 8, 8, 8, 48]
Private VCFG_PROXTAGS As Byte[] = [0, 0, 8, 0, 8, 8, 0, 8, 32]
Private VCFG_WIRELESS As Byte[] = [28, 28, 28, 28, 28, 28, 28, 29, 62]
Private VCFG_WIRED As Byte[] = [2, 2, 2, 2, 2, 2, 1, 1, 2]
Private VCFG_ZONECUSTOM As Byte[] = [0, 5, 5, 5, 5, 5, 5, 5, 5]

Private VINFO_ZONETYPE As String[] = ["Non-Alarm", "Emergency", "Flood", "Gas", "Delay 1", "Delay 2", "Interior-Follow", "Perimeter", "Perimeter-Follow", "24 Hours Silent", "24 Hours Audible", "Fire", "Interior", "Home Delay", "Temperature", "Outdoor", "16"]
Private VINFO_CHIME As String[] = ["Chime Off", "Melody Chime", "Zone Name Chime"]

'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
' Mandatory Sub for EACH Module/Interface to initialize:
' - The cPluginList[x].Settings are copied into local variables
' - Port/Connection will be started (any errors caught)
' - Any other code per interface 
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Public Sub StartPlugin(cPl As CPluginEntry)

  KeyName = cPl.KeyName
  Instance = cPl.Instance
  If Instance <> 1 Then LogLabel = Replace(LogLabel, "] ", "#" & Instance & "] ")

  ' Copy configuration items locally
  $bEnabled = cPl.Settings["enabled"]
  $sSerPort = cPl.Settings["serialport"]
  $bDebug = cPl.Settings["debug"]

  ' Retrieve our Interface Id, we don't have to retrieve it more then once
  InterfaceId = Devices.FindInterface("Visonic Interface")
  If InterfaceId = 0 Then
    Main.WriteLog(LogLabel & "ERROR: Required InterfaceId for 'Visonic Interfac' can't be retrieved from the database")

    IsRunning = False
    ErrorText = "Required InterfaceId for 'Visonic Interfac' can't be retrieved from the database"
    Return
  Endif

  $bDownloadMode = False
  $bInitialized = False
  $iPanelType = -1
  $iModelType = 0
  $bPowerMaster = False
  $cSendLastCommand = Null

  ' Connect/Initialize connection
  If Connect() Then
    Run()
  Endif

End

'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
' Mandatory sub for EACH Class to stop
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Public Sub StopPlugin()

  Try Disconnect()

End

'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
' Open serial port and start keepalive timer
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Public Function Connect() As Boolean

  ' try to close the port
  Try hVisonic.Close

  ' get a new one
  hVisonic = New Serialport As "Visonic"
  With hVisonic
    .PortName = $sSerPort
    .Speed = 9600
    .Parity = 0
    .DataBits = 8
    .StopBits = 1
    .FlowControl = 0
    .Open()
  End With
  
  ' Define 60 seconds timer and start it for PowerLink communication
  $tPowerLinkKeepAlive.Stop
  $tPowerLinkKeepAlive = New Timer As "tPowerLinkKeepAlive"
  $tPowerLinkKeepAlive.Delay = $iPowerLinkTimeOut
  $tPowerLinkKeepAlive.Start

  ' Write to main logfile we connected successfully
  Main.WriteLog(LogLabel & PluginFriendlyName & " serial interface connected to port " & $sSerPort)
  IsRunning = True

  ' All went ok
  Return True

Catch ' some errors
  Main.WriteLog(LogLabel & "ERROR: " & PluginFriendlyName & " serial interface FAILED to connect to port " & $sSerPort)
  Main.WriteLog(LogLabel & "ERROR: " & Error.Text)
  IsRunning = False
  ErrorText = Error.Text
  ErrorWhere = Error.Where

  Return False

End

'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
' Close port and stop timers
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Public Function Disconnect() As Boolean

  ' Stop timers
  $tPowerLinkKeepAlive.Stop
  $tQueueDelay.Stop
  $tQueueTimeout.Stop

  ' Try to close the connection
  Try hVisonic.Close
  Main.WriteLog(LogLabel & PluginFriendlyName & " Port closed.")

  ' all ok
  Return True

Finally
  IsRunning = False
  ErrorText = ""
  ErrorWhere = ""

Catch ' some errors
  Main.WriteLog(LogLabel & "ERROR: " & Error.Text)
  Return False

End

'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
' When SerialPort is connected, start the initialization
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Public Sub Run()

  ' Initialize last timestamp, also add delay to trigger it directly
  $dReceiveLastPacket = DateAdd(Now(), gb.Millisecond, $iSendDelay)

  ' Reset the receive buffer
  $sReceiveBuffer.Clear()
  $bReceiveHeaderFound = False

  ' Only force the init when requested
  If $bSendInit Then
    SendMsg_INIT()
  Endif

  ' Send the download command, this should initiate the communication
  SendMsg_DL_START()

End

'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
' Start timer for PowerLink connection, we will try to re-establish if it goes away
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Public Sub tPowerLinkKeepAlive_Timer()

  ' TBD: Don't do this forever, stop after a certain number of failures
  ' TBD: Needs to be tested more - it doesn't seem to work? Maybe we need to close/open the serial port?

  If $bDebug Then Main.WriteDebugLog(LogLabel & "PowerLink Timer Expired (" & CInt($iPowerLinkTimeOut / 1000) & " seconds)")

  SendMsg_RESTORE()

  ' Restart timer
  $tPowerLinkKeepAlive.Stop
  $tPowerLinkKeepAlive = New Timer As "tPowerLinkKeepAlive"
  $tPowerLinkKeepAlive.Delay = $iPowerLinkTimeOut
  $tPowerLinkKeepAlive.Start

End

'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
' Check the CRC of the received data
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Private Sub CheckCRC(bData As Byte[]) As Boolean

  Dim bChecksum As Byte

  ' Anything shorter then pre, some data, checksum and postamble isn't possible
  If bData.Count < 3 Then Return False

  ' Copy checksum
  bChecksum = bData.Copy(bData.Count - 2, 1)[0]

  ' Re-copy data, remove pre, checksum and postamble
  bData = bData.Copy(1, bData.Count - 3)

  ' Check if calculation and checksum match
  If CalculateCRC(bData) = bChecksum Then
    Return True
  Else
    Return False
  Endif

End

'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
' Calculate the CRC
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Private Sub CalculateCRC(bData As Byte[]) As Byte

  Dim bByte As Byte
  Dim sCount As Short
  Dim sChecksum As Short
      
  ' Count all byte values together
  sCount = 0
  For Each bByte In bData
    sCount += bByte
  Next

  ' Do a modulus on the total count
  sChecksum = sCount Mod 255

  ' Additional safety if we go over 255, shouldn't ever happen
  If sChecksum > 255 Then
    sChecksum = sChecksum Mod 255
  Endif

  ' Substract from 0xFF if the checksum isn't 0
  ' Checksum = 0xFF is never possible
  If sChecksum <> 0 Then
    sChecksum = &HFF - sChecksum
  Endif

  Return CByte(sChecksum)

End

'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
' Start timer for messages queued
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Private Sub StartTimer(iDelay As Integer)

  ' When we have an invalid delay, reset to maximum
  If iDelay < 0 Or If iDelay > $iSendDelay Then
    iDelay = $iSendDelay 
  Endif

  ' Only start timer if it isn't running yet
  'If Not $tQueueDelay.Enabled Then
    $tQueueDelay.Stop
    $tQueueDelay = New Timer As "tQueueDelay"
    $tQueueDelay.Delay = iDelay
    $tQueueDelay.Start
  'Endif

End

'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
' Timer expired, start processing the queue (can restart the timer)
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Public Sub tQueueDelay_Timer()

  $tQueueDelay.Stop

  ' Timer expired, kick off the processing of the queue
  ProcessQueue()

End

'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
' Process the queue, restart timer or send command. Also possible to resend the last message
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Private Sub ProcessQueue(Optional bResend As Boolean = False)

  Dim iMSec As Integer
  Dim aStr As New String[]
  Dim iCode As Integer

  ' Resend the request, but reset the receive counter to the original value
  If bResend Then
    If $cSendLastCommand Then
      $cSendLastCommand.ReceiveCnt = $cSendLastCommand.ReceiveCntFixed
      $cSendQueue.Add($cSendLastCommand, 0)
    Else
      Main.WriteDebugLog(LogLabel & "ERROR: Resend is requested, but the last request is NULL?")
    Endif
  Endif

  If $cSendQueue.Count = 0 Then Return

  ' Check the timer again - possible something is received
  iMSec = DateDiff($dReceiveLastPacket, Now(), gb.Millisecond)

  ' Check if the difference is at least 500+ msec
  If iMSec < $iSendDelay Then
    ' Start timer again for fast sending the command
    StartTimer($iSendDelay - iMSec)
    Return
  Endif

  ' Doublecheck if we got something in the queue
  If $cSendQueue.Count >= 1 Then

    ' Send first queued command and remove it
    $cSendLastCommand = $cSendQueue.Extract(0, 1)[0]

    ' Options are set, do our magic on the outgoing packet
    If $cSendLastCommand.Options Then

      aStr = Split($cSendLastCommand.Options, ":")
      If aStr.Count >= 1 Then

        Select aStr[0]
          Case "PIN"

            ' The Pin has to be 3 fields
            If aStr.Count = 3 Then
              iCode = 0

              Select aStr[1]
                Case "MasterCode"
                  iCode = $iMasterCode
                Case "DownloadCode"
                  iCode = $iDownloadCode
		Case "DisarmArmCode"
		  iCode = $iDisarmArmCode
                Default
                  Main.WriteDebugLog(LogLabel & "ERROR: Unknown Code defined (" & aStr[1] & ")")
              End Select

              If iCode <> 0 Then
                $cSendLastCommand.Command[CInt(aStr[2])] = Lsr(iCode, 8) And &HFF
                $cSendLastCommand.Command[CInt(aStr[2]) + 1] = iCode And &HFF
              Else
                Main.WriteDebugLog(LogLabel & "ERROR: The pincode is zero (" & ByteToHex($cSendLastCommand.Command.Copy()) & ")")
              Endif
            Else
              Main.WriteDebugLog(LogLabel & "ERROR: Invalid Option '" & $cSendLastCommand.Options & "', Expected: 3, Received: " & aStr.Count)
            Endif

          Default
            Main.WriteDebugLog(LogLabel & "ERROR: Unknown Option '" & $cSendLastCommand.Options & "'")
        End Select
      Else
        Main.WriteDebugLog(LogLabel & "ERROR: Invalid Option '" & $cSendLastCommand.Options & "'")
      Endif
    Endif

    ' Now send it to the PowerMax/Master
    SendCommand($cSendLastCommand.Command.Copy())

    If $bDebug Then Main.WriteDebugLog(LogLabel & $cSendLastCommand.Msg)
  Endif

End

'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
' Add a command to the send queue
' The queue is needed to prevent sending messages to quickly
' normally it requires 500msec between messages
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Private Sub QueueCommand(sData As Byte[], sMsg As String, bResponse As Byte, Optional sOptions As String = "")

  Dim iCnt As Integer
  Dim cEntry As New VisonicQueueEntry

  ' Copy the msg, command and response into our queue entry
  cEntry.Msg = sMsg
  cEntry.Command = sData.Copy()
  cEntry.Receive = bResponse
  cEntry.Options = sOptions

  ' Log some usefull information in debug mode
  If $bDebug Then
    Main.WriteDebugLog(LogLabel & "Queued Command (" & cEntry.Msg & ")")
  Endif

  ' Download commands, can have answers split across multiple message
  ' Determine the number of messages we should get
  If sData[0] = &H3E Then
    iCnt = CInt(sData[4]) * &H100 + sData[3]
    cEntry.ReceiveCnt = Floor(iCnt / &HB0) + 1
  Else
    cEntry.ReceiveCnt = 1
  Endif

  cEntry.ReceiveCntFixed = cEntry.ReceiveCnt

  ' Add it to the queue
  $cSendQueue.Add(cEntry)

  ' Kick off queue handling if required
  If $cSendQueue.Count >= 1 Then
    ProcessQueue()
  Endif

End

'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
' send a command to the alarm panel
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Private Sub SendCommand(sData As Byte[])

  Dim bData As Byte
  Dim sStr As String

  ' Lets update the timestamp
  $dReceiveLastPacket = Now()

  If hVisonic.Status = Net.Active Then

    ' First add preamble, crc and postamble
    bData = CalculateCRC(sData)
    sData.Add(&H0D, 0)
    sData.Add(bData)
    sData.Add(&H0A)

    If $bDebug Then 
      sStr = ""
      For Each bData In sData
        sStr &= IIf(sStr, " ", "") & Hex$(bData, 2)
      Next

      Main.WriteDebugLog(LogLabel & "> " & sStr)
    Endif

    ' Write the complete string - not byte-for-byte
    Try sData.Write(hVisonic, 0, sData.Length)
  Else
    Main.WriteDebugLog(LogLabel & "ERROR: Not connected anymore")
  Endif

Catch
  Main.WriteDebugLog(LogLabel & "ERROR: while trying to send: '" & ERROR.Text & "' at " & ERROR.Where)

End

'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
' got data back from Alarm panel and parse it when it's complete
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Public Sub Visonic_Read()

  Dim bData As Byte
  Dim sData As New Byte[]
  Dim iSize As Integer

  iSize = Lof(hVisonic)
  sData.Resize(iSize)
  Try sData.Read(hVisonic, 0, iSize)
  If Error Then
    Main.WriteDebugLog(LogLabel & "ERROR: Problem reading data from the serial port! (ReadSize=" & iSize & ") ->" & ERROR.Text)
  Else
    For Each bData In sData
      'If $bDebug Then Main.WriteDebugLog(LogLabel & "< " & Hex$(sData, 2) & " Length: " & aData.Length)
      ProcessReceivedChar(bData)
    Next
  Endif

End

'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
' Parse byte for byte, and detect pre and postamble characters
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Private Sub ProcessReceivedChar(bTemp As Byte)

  Dim iLength As Integer = 0
  Dim sStr As String
  Dim bData As Byte

  ' Check if the prevous character isn't long ago
  If $bReceiveHeaderFound Then
    If DateDiff($tReceiveLast0DChar, Now, gb.Millisecond) >= $iReceiveCompletePacketTimeout Then

      If $bDebug Then
        sStr = ""
        For Each bData In $sReceiveBuffer
          sStr &= IIf(sStr, " ", "") & Hex$(bData, 2)
        Next

        Main.WriteDebugLog(LogLabel & "< " & sStr & " (TIMEOUT ERROR, " & DateDiff($tReceiveLast0DChar, Now, gb.Millisecond) & " milliseconds)")

        ' reset for next data
        $sReceiveBuffer.Clear()
        $bReceiveHeaderFound = False
      Endif
    Endif
  Else
    $tReceiveLast0DChar = Now()
  Endif

  ' We detected a preamble, set the HeaderFound to True. It doesn't matter if we find more 0x0D in the data, because it is already set to True anyway
  If bTemp = &H0D Then $bReceiveHeaderFound = True

  ' Add the received Byte to the Array
  If $bReceiveHeaderFound Then $sReceiveBuffer.Add(bTemp)

  ' We detected a postamble and a preamble has been found
  If (bTemp = &H0A) And $bReceiveHeaderFound Then

    If $sReceiveBuffer.Length >= 4 Then
      Select $sReceiveBuffer[1]
        ' 25, 33 and 3C have a fixed length of 14 bytes (including pre and postamble)
        Case &H25, &H33, &H3C
          iLength = 14
        ' All A0-AF have a fixed length of 15 bytes (including pre and postamble)
        Case &HA0, &HA1, &HA2, &HA3, &HA4, &HA5, &HA6, &HA7, &HA8, &HA9, &HAA, &HAB, &HAC, &HAD, &HAE, &HAF
          iLength = 15
        ' B0 has a dynamic length, the length is on position 4, also add 8 for the full length
        Case &HB0
          If $sReceiveBuffer.Length >= 7 Then
            iLength = $sReceiveBuffer[4] + 8
          Endif
      End Select
    Endif

    ' Check the Crc, if it doesn't match - the 0x0A isn't the postamble!
    If CheckCRC($sReceiveBuffer.Copy()) Then
      ProcessReceivedPacket($sReceiveBuffer.Copy())
      ' reset for next data
      $sReceiveBuffer.Clear()
      $bReceiveHeaderFound = False
    Else
      If iLength > 0 Then
        ' If length match, we got a CRC error
        If $sReceiveBuffer.Length >= iLength Then

          If $bDebug Then
            sStr = ""
            For Each bData In $sReceiveBuffer
              sStr &= IIf(sStr, " ", "") & Hex$(bData, 2)
            Next

            Main.WriteDebugLog(LogLabel & "< " & sStr & " (CRC ERROR)" & IIf($sReceiveBuffer.Length > iLength, " (INVALID LENGTH)", ""))

            ' reset for next data
            $sReceiveBuffer.Clear()
            $bReceiveHeaderFound = False

            ' Just send an ACK anyway
            SendMsg_ACK(False)

          Endif
        Endif
      Endif
    Endif
  Endif

End

'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
' Process a complete valid PowerMax/Master packet
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Private Function ProcessReceivedPacket(sData As Byte[])

  Dim bData As Byte
  Dim bAck As Boolean = False
  Dim bResponse As Boolean = False
  Dim sStr As String

  ' Also set it timestamp to now
  $dReceiveLastPacket = Now()

  ' Dump the received raw data to the debug logfile
  If $bDebug Then
    sStr = ""
    For Each bData In sData
      sStr &= IIf(sStr, " ", "") & Hex$(bData, 2)
    Next

    Main.WriteDebugLog(LogLabel & "< " & sStr)
  Endif

  ' Remove preample, checksum and postamble and place it in a global variable
  $sReceiveData = sData.Copy(1, sData.Count - 3)

  ' Handle the response now
  Select Case $sReceiveData[0]
    Case &H02 ' ACK
      Handle_MsgType02()
    Case &H06 ' Timeout
      Handle_MsgType06()
    Case &H08 ' Access denied
      bAck = True
      Handle_MsgType08()
    Case &H0B ' Stop
      bAck = True
      bResponse = True
      If $bDebug Then Main.WriteDebugLog(LogLabel & "Stopped")
    Case &H25 ' Download retry
      bAck = True
      bResponse = True
      Handle_MsgType25()
    Case &H33 ' Settings send after a MSGV_START
      bAck = True
      bResponse = True
      Handle_MsgType33()
    Case &H3C ' Messsage when start the download
      bAck = True
      bResponse = True
      Handle_MsgType3C()
    Case &H3F ' Download information
      bAck = True
      bResponse = True
      Handle_MsgType3F()
    Case &HA0 ' Event log
      bAck = True
      bResponse = True
      Handle_MsgTypeA0()
    Case &HA5 ' General Event description
      bAck = True
      bResponse = True
      Handle_MsgTypeA5()
    Case &HA7 ' Panel Status Change
      bAck = True
      bResponse = True
      Handle_MsgTypeA7()
    Case &HAB ' PowerLink
      bAck = True
      bResponse = True
      Handle_MsgTypeAB()
    Case &HB0 ' PowerMaster
      bAck = True
      bResponse = True
      Handle_MsgTypeB0()
    Default ' Anything else ...
      bAck = True
      If $bDebug Then Main.WriteDebugLog(LogLabel & "Unknown message type: " & Hex$($sReceiveData[0], 2))
  End Select

  ' We received a complete packet, check if it is the expected packet
  If bResponse And If $cSendLastCommand Then

    ' The expected receive command has to be not zero
    If $cSendLastCommand.Receive <> &H00 Then

    ' Log expect and received responses for debug purposes
    If $bDebug Then Main.WriteDebugLog(LogLabel & "Received: " & Hex$($sReceiveData[0]) & ", Expected: " & Hex$($cSendLastCommand.Receive) & ", Count=" & $cSendLastCommand.ReceiveCnt & ", Retries=" & $cSendLastCommand.ReceiveRetries)

      ' &H33 can be any number of messages, but we get a &0B when it is finished
      If $cSendLastCommand.Receive = &H33 And If $sReceiveData[0] = &H0B Then
        $cSendLastCommand = Null
        ProcessQueue()
      Else
        If $cSendLastCommand.Receive = $sReceiveData[0] Then

          ' We don't know the number of &H33s, don't distract receive count
          If $sReceiveData[0] <> &H33 Then

            ' Yes, matching command
            $cSendLastCommand.ReceiveCnt -= 1

            ' Send next message if our expected count is zero
            If $cSendLastCommand.ReceiveCnt <= 0 Then
              $cSendLastCommand = Null
              ProcessQueue()
            Endif
          Endif
        Else
          ' No match, but no panic. Lets wait 1 more message before resending
          If $cSendLastCommand.ReceiveRetries = 0 Then
            $cSendLastCommand.ReceiveRetries += 1
          Else
            ' Kick off the queue with resend of the last message
            ProcessQueue(True)
          Endif
        Endif
      Endif
    Else
      ' We don't expect anything, so kick off queue handling
      $cSendLastCommand = Null
      ProcessQueue()
    Endif

  Endif

Finally
  If bAck Then SendMsg_ACK()

Catch ' some errors
  Main.WriteDebugLog(LogLabel & "ERROR: " & ERROR.Text & " at " & ERROR.Where)
  $sReceiveBuffer.Clear()
  $bReceiveHeaderFound = False

  '***************************
  'TODO - not complete anymore
  '***************************

End

'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
' The PowerMax/Master responded to the DL_START, now we can retrieve more information from the unit
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Private Sub PowerLinkEnrolled()

   If $bDebug Then Main.WriteDebugLog(LogLabel & "PowerLink is Enrolled, retrieving PowerMax/Master information")

   ' Request the panel FW
   SendMsg_DL_PANELFW()

   ' Request serial & type (not always sent by default)
   SendMsg_DL_SERIAL()

   ' Read the names of the zones
   SendMsg_DL_ZONESTR()

   ' Retrieve extra info if this is a PowerMaster
   If $bPowerMaster Then 
     SendMsg_DL_MASTER_SIRENKEYPADSZONE()
   Endif

   ' Request all other relevant information
   SendMsg_DL_GET()

   ' We are done, exit download mode
   SendMsg_DL_EXIT()

   ' auto-sync date/time
   SetDateTime()

' TBD if next command is really handy
   ' Lets request the eventlogs
   SendMsg_EVENTLOG()

End

'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
' Process Settings
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Private Sub ProcessSettings()

  Dim sData As New Byte[]
  Dim sDataMaster As New Byte[]
  Dim sZoneNames As New Byte[]
  Dim sDataX10 As New Byte[]
  Dim sPartition As New Byte[]
  Dim sVar As New Byte[]
  Dim iCnt As Integer
  Dim jCnt As Integer
  Dim iZoneCnt As Integer
  Dim iCustomCnt As Integer
  Dim iUserCnt As Integer
  Dim iPartitionCnt As Integer
  Dim iSirenCnt As Integer
  Dim iKeypad1Cnt As Integer
  Dim iKeypad2Cnt As Integer
  Dim bEnrolled As Boolean
  Dim bEnabled As Boolean
  Dim bLog As Boolean
  Dim bX10ZoneType As Byte

  ' Dump MemoryMap first to logfile
  If $bDebug Then 
    For Each $cMemoryMap
      Main.WriteDebugLog(LogLabel & "MemoryMap " & Hex$(CInt($cMemoryMap.Key), 2) & ": " & ByteToHex($cMemoryMap[$cMemoryMap.Key], True))
    Next
  Endif

  ' Re-initialize the configuration
  $cConfig = New Collection

  ' Only continue if we have a valid paneltype (>=0)
  If $iPanelType = -1 Then
    Main.WriteDebugLog(LogLabel & "ERROR: Can't process settings, the PanelType is unknown")
    Return
  Endif

  ' Only continue if we have a known paneltype (<=8)
  If $iPanelType > 8 Then
    Main.WriteDebugLog(LogLabel & "ERROR: Can't process settings, the PanelType= " & $iPanelType & " is a too new type")
    Return
  Endif

  ' ------------------------------------
  ' Read serialnumber and paneltype info
  ' ------------------------------------
  sData = ReadMemoryMap(VMSG_DL_SERIAL)
  If sData = Null Then
    Main.WriteDebugLog(LogLabel & "ERROR: Can't read the PowerMax/Master MemoryMap, communication with the unit went wrong?")
    Return
  Endif

  If sData[7] <> $iPanelType Then
    Main.WriteDebugLog(LogLabel & "ERROR: Initial received PanelType is different then read from MemoryMap. PanelType=" & $iPanelType & ", Read=" & sData[7])
    Return
  Endif

  If $bDebug Then Main.WriteDebugLog(LogLabel & "Reading panel information")

  $cConfig["panel"] = New Collection

  ' Convert serial into readable ascii and save
  $cConfig["panel"]["serial"] = ByteToHex(sData.Copy(0, 6)) 

  ' ---------------------------------- 
  ' Now it looks to be safe to determine panel options/dimensions
  ' ---------------------------------- 
  iZoneCnt = VCFG_WIRELESS[$iPanelType] + VCFG_WIRED[$iPanelType]
  iCustomCnt = VCFG_ZONECUSTOM[$iPanelType]
  iUserCnt = VCFG_USERCODES[$iPanelType]
  iPartitionCnt = VCFG_PARTITIONS[$iPanelType]
  iSirenCnt = VCFG_SIRENS[$iPanelType]
  iKeypad1Cnt = VCFG_1WKEYPADS[$iPanelType]
  iKeypad2Cnt = VCFG_2WKEYPADS[$iPanelType]

  ' ---------------------------------- 
  ' Read panel eprom and software info
  ' ---------------------------------- 
  sData = ReadMemoryMap(VMSG_DL_PANELFW)

  $cConfig["panel"]["eprom"] = ByteToString(sData.Copy(0, 16))
  $cConfig["panel"]["software"] = ByteToString(sData.Copy(16, 16))

  ' ------------------------------------------------------------
  ' Read panel date/time (doesn't get updated after initial read
  ' ------------------------------------------------------------
  sData = ReadMemoryMap(VMSG_DL_TIME)

  $cConfig["panel"]["datetime"] = Format$(sData[3], "00") & "/" & Format$(sData[4], "00") & "/" & CStr(CInt(sData[5]) + 2000) & " " & Format$(sData[2], "00") & ":" & Format$(sData[1], "00") & ":" & Format$(sData[0], "00")

  If $bDebug Then
    Main.WriteDebugLog(LogLabel & "Panel Info:")
    Main.WriteDebugLog(LogLabel & "  PanelType: " & DisplayPanelType())
    Main.WriteDebugLog(LogLabel & "  Model: " & DisplayPanelModel())
    Main.WriteDebugLog(LogLabel & "  Serial: " & $cConfig["panel"]["serial"])
    Main.WriteDebugLog(LogLabel & "  Eprom: " & $cConfig["panel"]["eprom"])
    Main.WriteDebugLog(LogLabel & "  Software: " & $cConfig["panel"]["software"])
    Main.WriteDebugLog(LogLabel & "  Date/Time: " & $cConfig["panel"]["datetime"])
  Endif

  ' ---------------------------------------------------
  ' Determine the zone names, including the custom ones
  ' ---------------------------------------------------
  $cConfig["zonename"] = New Collection
  sData = ReadMemoryMap(VMSG_DL_ZONESTR)

  For iCnt = 1 To (26 + iCustomCnt)
    sVar = sData.Copy((iCnt - 1) * &H10, &H10)
    If sVar[0] <> &HFF Then
      $cConfig["zonename"][iCnt] = ByteToString(sVar)
    Endif
  Next

  If $bDebug Then
    Main.WriteDebugLog(LogLabel & "Zone Names:")

    For Each $cConfig["zonename"]
      Main.WriteDebugLog(LogLabel & "  " & Format$($cConfig["zonename"].Key, "00") & ": " & $cConfig["zonename"][$cConfig["zonename"].Key])
    Next
  Endif

  ' -------------------------
  ' Retrieve telephonenumbers
  ' -------------------------
  $cConfig["phonenr"] = New Collection
  sData = ReadMemoryMap(VMSG_DL_PHONENRS)

  For iCnt = 1 To 4

    For jCnt = 0 To 7
      If sData[8 * (iCnt - 1) + jCnt] <> &HFF Then
        $cConfig["phonenr"][iCnt] &= Chr$(sData[8 * (iCnt - 1) + jCnt])
      Endif
    Next
  Next

  If $bDebug Then
    bLog = False
    Main.WriteDebugLog(LogLabel & "Phonenumbers:")

    For Each $cConfig["phonenr"]
      bLog = True
      Main.WriteDebugLog(LogLabel & "  " & $cConfig["phonenr"].Key & ": " & $cConfig["phonenr"][$cConfig["phonenr"].Key])
    Next

    If Not bLog Then Main.WriteDebugLog(LogLabel & "  None")
  Endif

  ' --------------
  ' Alarm settings
  ' --------------
  $cConfig["alarm"] = New Collection
  sData = ReadMemoryMap(VMSG_DL_COMMDEF)

  $cConfig["alarm"]["entrydelay1"] = sData[0]
  $cConfig["alarm"]["entrydelay2"] = sData[1]
  $cConfig["alarm"]["exitdelay"] = sData[2]
  $cConfig["alarm"]["belltime"] = sData[3]
  $cConfig["alarm"]["silentpanic"] = (sData[25] And &H10 = &H10)
  $cConfig["alarm"]["quickarm"] = (sData[26] And &H08 = &H08)
  $cConfig["alarm"]["bypassoff"] = (sData[27] And &HC0 = &H00)
  $cConfig["alarm"]["forceddisablecode"] = ByteToHex(sData.Copy(16, 2))
  $iDisarmArmCode = CInt(sData[16]) * 256 + sData[17]

  If $bDebug Then
    Main.WriteDebugLog(LogLabel & "Alarm:")
    Main.WriteDebugLog(LogLabel & "  Entry Delay 1: " & $cConfig["alarm"]["entrydelay1"] & " seconds")
    Main.WriteDebugLog(LogLabel & "  Entry Delay 2: " & $cConfig["alarm"]["entrydelay2"] & " seconds")
    Main.WriteDebugLog(LogLabel & "  Exit Delay: " & $cConfig["alarm"]["exitdelay"] & " seconds")
    Main.WriteDebugLog(LogLabel & "  Bell Time: " & $cConfig["alarm"]["belltime"] & " seconds")
    Main.WriteDebugLog(LogLabel & "  Silent Panic: " & IIf($cConfig["alarm"]["silentpanic"], "True", "False"))
    Main.WriteDebugLog(LogLabel & "  Quick Arm: " & IIf($cConfig["alarm"]["quickarm"], "True", "False"))
    Main.WriteDebugLog(LogLabel & "  Bypass Off: " & IIf($cConfig["alarm"]["belltime"], "True", "False"))
    Main.WriteDebugLog(LogLabel & "  Forced Disarm Code: " & $cConfig["alarm"]["forceddisablecode"])
  Endif

  ' -----------------
  ' Retrieve pincodes
  ' -----------------
  $cConfig["pincode"] = New Collection

  ' If it is a PowerMaster, the usercodes are somewhere else in memory
  If $bPowerMaster Then
    sData = ReadMemoryMap(VMSG_DL_MASTER_USERPINCODES)
  Else
    sData = ReadMemoryMap(VMSG_DL_USERPINCODES)
  Endif

  For iCnt = 1 To iUserCnt
    $cConfig["pincode"][iCnt] = ByteToHex(sData.Copy(2 * (iCnt - 1), 2))
  Next

  ' Retrieve the installer and powerlink pincodes - they are known/visible
  sData = ReadMemoryMap(VMSG_DL_OTHERPINCODES)
  $cConfig["pincode"]["installer"] = ByteToHex(sData.Copy(0, 2))
  $cConfig["pincode"]["masterinstaller"] = ByteToHex(sData.Copy(2, 2))
  $cConfig["pincode"]["powerlink"] = ByteToHex(sData.Copy(8, 2))

  ' Copy the first pin into the masterpin
  If $cConfig["pincode"].Exist("1") Then
    Try $iMasterCode = Val("&H" & $cConfig["pincode"]["1"])
    If Error Then
      $iMasterCode = &H0000
      Main.WriteDebugLog(LogLabel & "ERROR: Unable to retrieve the master pincode (" & $cConfig["pincode"]["1"] & ")")
    Endif
  Else
    ' No masterpin code ...
    $iMasterCode = &H0000
  Endif

  If $bDebug Then
    Main.WriteDebugLog(LogLabel & "Pincodes:")

    For iCnt = 1 To iUserCnt
      Main.WriteDebugLog(LogLabel & "  " & Format$(iCnt, "00") & ": " & $cConfig["pincode"][iCnt])
    Next

    Main.WriteDebugLog(LogLabel & "  Installer: " & $cConfig["pincode"]["installer"])
    Main.WriteDebugLog(LogLabel & "  Master Installer: " & $cConfig["pincode"]["masterinstaller"])
    Main.WriteDebugLog(LogLabel & "  PowerLink: " & $cConfig["pincode"]["powerlink"])
  Endif

  ' -----------------------------------
  ' Retrieve if partitioning is enabled
  ' -----------------------------------
  $cConfig["partition"] = New Collection
  sPartition = ReadMemoryMap(VMSG_DL_PARTITIONS)
  If sPartition[0] = 0 Then iPartitionCnt = 1

  $cConfig["partition"]["count"] = iPartitionCnt

  Main.WriteDebugLog(LogLabel & "Partitions: " & iPartitionCnt)

  ' ----------------------------------
  ' Retrieve detailed zone information
  ' ----------------------------------
  $cConfig["zoneinfo"] = New Collection

  sData = ReadMemoryMap(VMSG_DL_ZONES) ' setting

  If $bPowerMaster Then
    sZoneNames = ReadMemoryMap(VMSG_DL_MASTER_ZONENAMES)
    sDataMaster = ReadMemoryMap(VMSG_DL_MASTER_ZONES) ' settingMr
  Else
    sZoneNames = ReadMemoryMap(VMSG_DL_ZONENAMES)
  Endif

  If (ByteToHex(sData.Copy(0, iZoneCnt)) <> String$(iZoneCnt, "00")) And If (ByteToHex(sZonenames) <> String(sZoneNames.Count, "00")) Then

    For iCnt = 1 To iZoneCnt

      If $bPowerMaster Then
        bEnrolled = (ByteToHex(sDataMaster.Copy(iCnt * 10 - 6, 5)) <> String$(5, "00"))
      Else
        bEnrolled = (ByteToHex(sData.Copy(iCnt * 4 - 4, 3)) <> String$(3, "00"))
      Endif

      If bEnrolled Then

        ' Create a new collection for this node
        $cConfig["zoneinfo"][iCnt] = New Collection

        $cConfig["zoneinfo"][iCnt]["tripstatus"] = -1
        $cConfig["zoneinfo"][iCnt]["batterystatus"] = -1

        If $cConfig["zonename"].Exist(sZoneNames[iCnt - 1] + 1) Then
          $cConfig["zoneinfo"][iCnt]["zonename"] = $cConfig["zonename"][sZoneNames[iCnt - 1] + 1] 
        Else
          $cConfig["zoneinfo"][iCnt]["zonename"] = "Unknown"
        Endif

        If $bPowerMaster Then
          $cConfig["zoneinfo"][iCnt]["zonetype"] = sData[iCnt - 1]
          $cConfig["zoneinfo"][iCnt]["sensorid"] = sDataMaster[iCnt * 10 - 5]

          Select $cConfig["zoneinfo"][iCnt]["sensorid"]
            Case &H01
              $cConfig["zoneinfo"][iCnt]["sensortype"] = "Motion"
              $cConfig["zoneinfo"][iCnt]["sensorname"] = "Next PG2"
              $cConfig["zoneinfo"][iCnt]["autocreate"] = "Visonic PIR"
            Case &H04
              $cConfig["zoneinfo"][iCnt]["sensortype"] = "Camera"
              $cConfig["zoneinfo"][iCnt]["sensorname"] = "Next CAM PG2"
              $cConfig["zoneinfo"][iCnt]["autocreate"] = "Visonic Camera"
            Case &H15
              $cConfig["zoneinfo"][iCnt]["sensortype"] = "Smoke"
              $cConfig["zoneinfo"][iCnt]["sensorname"] = "SMD-427 PG2"
              $cConfig["zoneinfo"][iCnt]["autocreate"] = "Visonic Smoke Detector"
            Case &H16
              $cConfig["zoneinfo"][iCnt]["sensortype"] = "Smoke"
              $cConfig["zoneinfo"][iCnt]["sensorname"] = "SMD-426 PG2"
              $cConfig["zoneinfo"][iCnt]["autocreate"] = "Visonic Smoke Detector"
            Case &H2A
              $cConfig["zoneinfo"][iCnt]["sensortype"] = "Magnet"
              $cConfig["zoneinfo"][iCnt]["sensorname"] = "MC-302 PG2"
              $cConfig["zoneinfo"][iCnt]["autocreate"] = "Visonic Door/Window Contact"
            Default
              $cConfig["zoneinfo"][iCnt]["sensortype"] = "Unknown"
              $cConfig["zoneinfo"][iCnt]["autocreate"] = "Visonic Unknown"
          End Select

        Else
          $cConfig["zoneinfo"][iCnt]["zonetype"] = sData[iCnt * 4 - 1]
          $cConfig["zoneinfo"][iCnt]["sensorid"] = sData[iCnt * 4 - 2]

          Select ($cConfig["zoneinfo"][iCnt]["sensorid"] And &H0F)
            Case &H3, &H4, &HC
              $cConfig["zoneinfo"][iCnt]["sensortype"] = "Motion"
              $cConfig["zoneinfo"][iCnt]["autocreate"] = "Visonic PIR"
            Case &H5, &H6, &H7
              $cConfig["zoneinfo"][iCnt]["sensortype"] = "Magnet"
              $cConfig["zoneinfo"][iCnt]["autocreate"] = "Visonic Door/Window Contact"
            Case &HA
              $cConfig["zoneinfo"][iCnt]["sensortype"] = "Smoke"
              $cConfig["zoneinfo"][iCnt]["autocreate"] = "Visonic Smoke Detector"
            Case &HB
              $cConfig["zoneinfo"][iCnt]["sensortype"] = "Gas"
              $cConfig["zoneinfo"][iCnt]["autocreate"] = "Visonic Gas Detector"
            Case &HF
              $cConfig["zoneinfo"][iCnt]["sensortype"] = "Wired"
              $cConfig["zoneinfo"][iCnt]["autocreate"] = "Visonic Wired"
            Default
              $cConfig["zoneinfo"][iCnt]["sensortype"] = "Unknown"
              $cConfig["zoneinfo"][iCnt]["autocreate"] = "Visonic Unknown"
          End Select
        Endif

        $cConfig["zoneinfo"][iCnt]["zonechime"] = Lsr($cConfig["zoneinfo"][iCnt]["zonetype"], 4) And &H03
        Try $cConfig["zoneinfo"][iCnt]["zonechimename"] = VINFO_CHIME[$cConfig["zoneinfo"][iCnt]["zonechime"]]
        If Error Then Try $cConfig["zoneinfo"][iCnt]["zonechimename"] = "Unknown"

        $cConfig["zoneinfo"][iCnt]["zonetype"] = $cConfig["zoneinfo"][iCnt]["zonetype"] And &H0F
        Try $cConfig["zoneinfo"][iCnt]["zonetypename"] = VINFO_ZONETYPE[$cConfig["zoneinfo"][iCnt]["zonetype"]]
        If Error Then $cConfig["zoneinfo"][iCnt]["zonetypename"] = "Unknown"

        If $cConfig["partition"]["count"] > 1 Then

          For jCnt = 1 To $cConfig["partition"]["count"]
            If (sPartition[&H11 + iCnt - 1] And CInt(2 ^ (jCnt - 1))) > 0 Then
              If $cConfig["zoneinfo"][iCnt].Exist("partition") Then
                $cConfig["zoneinfo"][iCnt]["partition"] &= ", " & CStr(jCnt)
              Else
                $cConfig["zoneinfo"][iCnt]["partition"] = CStr(jCnt)
              Endif
            Endif
          Next

        Else
          $cConfig["zoneinfo"][iCnt]["partition"] = CStr(1)
        Endif 
      Endif

    Next

    ' All information gathered, now print it in debug
    If $bDebug Then Main.WriteDebugLog(LogLabel & "ZoneInfo:")

    For iCnt = 1 To iZoneCnt

      If $cConfig["zoneinfo"].Exist(iCnt) Then

        If $bDebug Then
          Main.WriteDebugLog(LogLabel & "  Zone " & Format$(iCnt, "00") & ": Enrolled")
          Main.WriteDebugLog(LogLabel & "    ZoneName: " & $cConfig["zoneinfo"][iCnt]["zonename"] & " (id=" & sZoneNames[iCnt] & ")")
          Main.WriteDebugLog(LogLabel & "    ZoneType: " & $cConfig["zoneinfo"][iCnt]["zonetypename"] & " (id=" & $cConfig["zoneinfo"][iCnt]["zonetype"] & ")")
          Main.WriteDebugLog(LogLabel & "    Sensor: " & $cConfig["zoneinfo"][iCnt]["sensortype"] & IIf($cConfig["zoneinfo"][iCnt]["sensorname"], " (" & $cConfig["zoneinfo"][iCnt]["sensorname"] & ")", "") & " (id=" & $cConfig["zoneinfo"][iCnt]["sensorid"] & ")")
        Endif

        ' Try to find it, it will autocreate the device if needed
        Devices.Find(Instance, "Z" & Format$(iCnt, "00"), InterfaceId, $cConfig["zoneinfo"][iCnt]["autocreate"])

      Else
        If $bDebug Then Main.WriteDebugLog(LogLabel & " Zone " & Format$(iCnt, "00") & ": Not Enrolled")
      Endif

    Next

  Endif

  ' ------------------------------------------------------
  ' Retrieve PGM & X10, X10 - Only applicable for PowerMax
  ' ------------------------------------------------------
  ' TODO: if the X10 is a Switch or Dimmer

  $cConfig["PGMX10"] = New Collection

  sData = ReadMemoryMap(VMSG_DL_PGMX10)
  sDataX10 = ReadMemoryMap(VMSG_DL_X10NAMES)

  For iCnt = 1 To 16 
    bX10ZoneType = &H0F
    bEnabled = False

    For jCnt = 0 To 9
     bEnabled = bEnabled Or (ByteToHex(sData.Copy(5 + iCnt + jCnt * &H10)) <> "00")
    Next

    If iCnt > 1 Then bX10ZoneType = sDataX10[iCnt - 1]

    If bEnabled Or bX10ZoneType <> &H0F Then

      ' Create a new collection for this node
      $cConfig["PGMX10"][iCnt] = New Collection

      $cConfig["PGMX10"][iCnt]["enabled"] = bEnabled

      If iCnt > 1 Then
        Try $cConfig["PGMX10"][iCnt]["zonename"] = $cConfig["zonename"][sZoneNames[iCnt - 1] + 1]
        If Error Then
          $cConfig["PGMX10"][iCnt]["zonename"] = "Unknown"
        Endif
      Else
        $cConfig["PGMX10"][iCnt]["zonename"] = "PGM"
      Endif

    Endif

  Next

  ' All information gathered, now print it in debug
'  If $bDebug Then

'    Main.WriteDebugLog(LogLabel & "PGM-X10:")

'    For iCnt = 1 To 16

'      If $cConfig["PGMX10"].Exist(iCnt) Then
'        Main.WriteDebugLog(LogLabel & "  N " & Format$(iCnt, "00") & ": " & IIf($cConfig["PGMX10"][iCnt]["enabled"], "Enabled", "Disabled") & " (" & IIf(iCnt = 1, "PGM", "X10") & ")")
'        Main.WriteDebugLog(LogLabel & "    ZoneName: " & $cConfig["PGMX10"][iCnt]["zonename"] & " (id=" & sZoneNames[iCnt] & ")")
'      Endif

'    Next
'  Endif

  ' ------------------------------------------------------
  ' Retrieve keypads and siren information
  ' ------------------------------------------------------
  $cConfig["siren"] = New Collection

  ' PowerMaster has only 1 type of keypad. PowerMax has 2 types of keypads, 1 and 2-way communication

  If $bPowerMaster Then

    $cConfig["keypad2"] = New Collection
    sData = ReadMemoryMap(VMSG_DL_MASTER_KEYPADS)

    For iCnt = 1 To iKeypad2Cnt
      bEnrolled = (ByteToHex(sData.Copy(iCnt * 10 - 6, 5)) <> String$(5, "00"))

      If bEnrolled Then
        $cConfig["keypad2"][iCnt] = New Collection
        $cConfig["keypad2"][iCnt]["enrolled"] = True
      Endif
    Next

    sData = ReadMemoryMap(VMSG_DL_MASTER_SIRENS)
    For iCnt = 1 To iSirenCnt
      bEnrolled = (ByteToHex(sData.Copy(iCnt * 10 - 6, 5)) <> String$(5, "00"))

      If bEnrolled Then
        $cConfig["siren"][iCnt] = New Collection
        $cConfig["siren"][iCnt]["enrolled"] = True
      Endif
    Next

  Else

    $cConfig["keypad1"] = New Collection
    $cConfig["keypad2"] = New Collection

    sData = ReadMemoryMap(VMSG_DL_1WKEYPADS)
    For iCnt = 1 To iKeypad1Cnt
      bEnrolled = (ByteToHex(sData.Copy(iCnt * 4 - 4, 2)) <> String$(2, "00"))
      If bEnrolled Then
        $cConfig["keypad1"][iCnt] = New Collection
        $cConfig["keypad1"][iCnt]["enrolled"] = True
      Endif
    Next

    sData = ReadMemoryMap(VMSG_DL_2WKEYPADS)
    For iCnt = 1 To iKeypad2Cnt
      bEnrolled = (ByteToHex(sData.Copy(iCnt * 4 - 4, 3)) <> String$(3, "00"))
      If bEnrolled Then
        $cConfig["keypad2"][iCnt] = New Collection
        $cConfig["keypad2"][iCnt]["enrolled"] = True
      Endif
    Next

    sData = ReadMemoryMap(VMSG_DL_SIRENS)
    For iCnt = 1 To iSirenCnt
      bEnrolled = (ByteToHex(sData.Copy(iCnt * 4 - 4, 3)) <> String$(3, "00"))
      If bEnrolled Then
        $cConfig["siren"][iCnt] = New Collection
        $cConfig["siren"][iCnt]["enrolled"] = True
      Endif
    Next
  Endif

  ' All information gathered, now print it in debug
  If $bDebug Then

    If $cConfig.Exist("keypad1") Then
      bLog = False
      Main.WriteDebugLog(LogLabel & "1-Way Keypad:")

      For iCnt = 1 To iKeypad1Cnt
        If $cConfig["keypad1"].Exist(iCnt) Then
          bLog = True
          Main.WriteDebugLog(LogLabel & "  " & Format$(iCnt, "00") & ": Enrolled")
        Endif
      Next

      If Not bLog Then Main.WriteDebugLog(LogLabel & "  None")
    Endif

    bLog = False
    Main.WriteDebugLog(LogLabel & "2-Way Keypad:")
    For iCnt = 1 To iKeypad2Cnt
      If $cConfig["keypad2"].Exist(iCnt) Then
        bLog = True
        Main.WriteDebugLog(LogLabel & "  " & Format$(iCnt, "00") & ": Enrolled")
      Endif
    Next
    If Not bLog Then Main.WriteDebugLog(LogLabel & "  None")

    bLog = False
    Main.WriteDebugLog(LogLabel & "Siren:")
    For iCnt = 1 To iSirenCnt
      If $cConfig["siren"].Exist(iCnt) Then
        bLog = True
        Main.WriteDebugLog(LogLabel & "  " & Format$(iCnt, "00") & ": Enrolled")
      Endif
    Next
    If Not bLog Then Main.WriteDebugLog(LogLabel & "  None")

  Endif

  ' --- DONE with ReadSettings ---

Finally

  ' --------------------------------
  ' Finally done with panel settings
  ' --------------------------------
  ' Now send a restore message, this will give the current status
  SendMsg_RESTORE()

Catch
  Main.WriteLog(LogLabel & "ERROR: ProcessSettings '" & Error.Text & "' at '" & Error.Where & "'")

End


'########################################################
' Send PowerMax/Master messages
'########################################################

'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
' Send an ACK upon receive a message, an ACK is never queued
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Private Sub SendMsg_ACK(Optional bUseType As Boolean = True)

  If bUseType Then

    ' Depending on the msgtype and/or last byte, we will be sending type-1 or 2 ACK
    If $sReceiveData[0] >= &H80 Or If ($sReceiveData[0] < &H10 And $sReceiveData[$sReceiveData.Count - 1] = &H43) Then
      SendCommand(VMSG_ACK2.Copy())
    Else
      SendCommand(VMSG_ACK1.Copy())
    Endif

  Else
    ' If no buffer is available, always send type-1 ACK
    SendCommand(VMSG_ACK1.Copy())
  Endif

  If $bDebug Then Main.WriteDebugLog(LogLabel & "Acknowledgement")

End

'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
' Initialize the PowerMax/Master
' Normally if no communication has been estabilished before
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Private Sub SendMsg_INIT()

  QueueCommand(VMSG_INIT.Copy(), "Initializing PowerMax/Master PowerLink Connection", &H00)

End

'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
' Restore the connection
' Normally if the keepalive timer expired after 60 seconds
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Private Sub SendMsg_RESTORE()

  QueueCommand(VMSG_RESTORE.Copy(), "Restore PowerMax/Master Connection", &H00) 

End

'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
' Auto enroll the PowerMax/Master unit
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Private Sub SendMsg_ENROLL()

  ' Send the request, the pin will be added when the command is send
  QueueCommand(VMSG_ENROLL.Copy(), "Auto-Enroll of the PowerMax/Master", &H00, "PIN:DownloadCode:4")

  ' We are doing an auto-enrollment, most likely the download failed. Lets restart the download stage.
  If $bDownloadMode Then
    If $bDebug Then Main.WriteDebugLog(LogLabel & "Resetting download mode to 'Off'")
    $bDownloadMode = False
  Endif

  SendMsg_DL_START()

End

'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
' Start download mode
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Private Sub SendMsg_DL_START()

  If Not $bDownloadMode Then
    $bDownloadMode = True

    QueueCommand(VMSG_DL_START.Copy(), "Start Download Mode", &H3C, "PIN:DownloadCode:3")
  Else
    If $bDebug Then Main.WriteDebugLog(LogLabel & "Already in Download Mode?")
  Endif

End

'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
' Get al(most) all relevant parameter during the startup
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Private Sub SendMsg_DL_GET()

  QueueCommand(VMSG_DL_GET.Copy(), "DL: Retrieving Revelant Settings", &H33)

End

'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
' Stop download mode
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Private Sub SendMsg_DL_EXIT()

  If $bDownloadMode Then
    $bDownloadMode = False
    QueueCommand(VMSG_DL_EXIT.Copy(), "Exit Download Mode", &H00)
  Else
    If $bDebug Then Main.WriteDebugLog(LogLabel & "Not in Download Mode?")
  Endif

End

'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
' Request the panel FW
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Private Sub SendMsg_DL_PANELFW()

  QueueCommand(VMSG_DL_PANELFW.Copy(), "DL: Panel Firmware", &H3F)

End

'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
' Request serial & type (not always sent by default)
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Private Sub SendMsg_DL_SERIAL()

  QueueCommand(VMSG_DL_SERIAL.Copy(), "DL: Serialnumber", &H3F)

End

'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
' Read the names of the zones
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Private Sub SendMsg_DL_ZONESTR()

  QueueCommand(VMSG_DL_ZONESTR.Copy(), "DL: Zonenames", &H3F)

End

'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
' Retrieve extra info if this is a PowerMaster
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Private Sub SendMsg_DL_MASTER_SIRENKEYPADSZONE()

  QueueCommand(VMSG_DL_MASTER_SIRENKEYPADSZONE.Copy(), "DL: PowerMaster Siren/Keypad/Zones", &H3F)

End

'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
' Request status update
' Only done when we are not in PowerLink mode
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Private Sub SendMsg_STATUS()

  QueueCommand(VMSG_STATUS.Copy(), "Request Status (None PowerLink Mode)", &HA5)

End

'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
' Request the event logs
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Private Sub SendMsg_EVENTLOG()

  ' The MasterCode is used, and it is on position 4 and 5
  QueueCommand(VMSG_EVENTLOG.Copy(), "Request Event Logs", &HA0, "PIN:MasterCode:4")

End

'########################################################
' Handle MemoryMap reads and writes
'########################################################

'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
' Write the 3C and 3F information into our own memory map structure. This contains all the
' information of the PowerMax/Master and will later be processed in ReadSettings
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Private Sub WriteMemoryMap(iPage As Integer, iIndex As Integer, sData As Byte[])

  Dim dPage As New Byte[]
  Dim iFree As Integer

  If $bDebug Then Main.WriteDebugLog(LogLabel & "Received Settings Page=" & Hex$(iPage, 2) & ", Index=" & Hex$(iIndex, 2) & ", Length=" & sData.Count)

  ' Repeat until we put all the data into the MemoryMap
  While sData.Count > 0

    If $cMemoryMap.Exist(iPage) Then
      ' Place Byte[] data in a local variable
      dPage = $cMemoryMap[iPage]
    Else
      ' Create empty page with 255 values
      dPage = New Byte[]
      dPage.Resize(&H100)
      dPage.Fill(&HFF, &H00, &H100)
      $cMemoryMap[iPage] = dPage
    Endif

'Main.WriteDebugLog(LogLabel & "### BEGIN ### " & ByteToHex(dPage, True))

    ' Check if the data fits in the current page
    If iIndex + sData.Count <= &H100 Then

      ' It fits, just copy all in and we are done
      dPage.Extract(iIndex, sData.Count)
      dPage.Insert(sData, iIndex)
      sData.Clear()

    Else

      ' It spans multiple pages, take care of it
      iFree = &H100 - iIndex
      dPage.Extract(iIndex, iFree)
      dPage.Insert(sData.Extract(0, iFree), iIndex)
 
      ' Set it to the next page and index to 0
      iPage += 1
      iIndex = 0
    Endif 

'Main.WriteDebugLog(LogLabel & "### END   ### " & ByteToHex(dPage, True))

  Wend

End

'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
' Read data from the memory map and return the relevant bytes
' We will return Null if if the request page/index/length can't be returned
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Private Sub ReadMemoryMap(aMsg As Byte[]) As Byte[]

  Dim aResult As New Byte[]
  Dim dPage As New Byte[]
  Dim iPage As Integer
  Dim iIndex As Integer
  Dim iLength As Integer
  Dim iTemp As Integer

  ' The aMsg is in the regular download format, ignore the SubType and only use page, index and length
  ' NOTE: Length can be more then &HFF bytes, in such we got multiple 3F responses with a "real" download
  iPage = aMsg[2]
  iIndex = aMsg[1]
  iLength = CInt(aMsg[4]) * &H100 + aMsg[3]

  While iLength > 0

    If Not $cMemoryMap.Exist(iPage) Then Return Null

    dPage = $cMemoryMap[iPage]

    If iIndex + iLength <= &H100 Then
      aResult.Insert(dPage.Copy(iIndex, iLength))
      iLength = 0
    Else

      ' It spans multiple pages, take care of it
      iTemp = &H100 - iIndex
      aResult.Insert(dPage.Copy(iIndex, iTemp))

      ' Set it to the next page and index to 0
      iPage += 1
      iIndex = 0
      iLength -= iTemp
    Endif

  Wend

  If aResult.Count >= 1
    Return aResult
  Else
    Return Null
  Endif

End

'########################################################
' Handle MsgType section
'########################################################

'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
' MsgType=02 - ACK
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Private Sub Handle_MsgType02()

  If $bDebug Then Main.WriteDebugLog(LogLabel & "Acknowledgement")

  ' Check if the last message is Download Exit, if this is the case, process the settings
  If $cSendLastCommand Then
    If $cSendLastCommand.Command[0] = &H0F Then
      ProcessSettings()
    Endif
  Endif

End

'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
' MsgType=06 - Time out
' Timeout message from the PM, most likely we are/were in download mode
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Private Sub Handle_MsgType06()

  If $bDebug Then Main.WriteDebugLog(LogLabel & "Timeout Received")
  SendMsg_DL_EXIT()

End

'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
' MsgType=08 - Access denied
' Access denied, a wrong pin supplied
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Private Sub Handle_MsgType08()

  If $bDebug Then Main.WriteDebugLog(LogLabel & "Access Denied")

  ' If LastMsgType And &HF0 = &HA0 Then
  '   Wrong pin  enroll, eventlog, arm, bypass
  ' Endif

  ' If LastMsgType And &HF0 = &H24 Then
  '   Wrong download pin
  ' Endif

End

'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
' MsgType=25 - Download retry
' Unit is not ready to enter download mode
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Private Sub Handle_MsgType25()

  Dim iDelay As Integer

  ' Format: <MsgType> <?> <?> <delay in sec>

  iDelay = $sReceiveData[3]

  If $bDebug Then Main.WriteDebugLog(LogLabel & "Download Retry, have to wait " & iDelay & " seconds")

  ' Restart the queue timer, but untested
  $tQueueDelay.Stop
  $tQueueDelay = New Timer As "tQueueDelay" 
  $tQueueDelay.Delay = iDelay * 1000
  $tQueueDelay.Start

End

'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
' MsgType=33 - Settings
' Message send after a VMSG_START. We will store the information in an internal array/collection
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Private Sub Handle_MsgType33()

  Dim iPage As Integer
  Dim iIndex As Integer

  If $sReceiveData.Count <> 11 Then
    If $bDebug Then Main.WriteDebugLog(LogLabel & "ERROR: MSGTYPE=0x33 Expected=11, Received=" & $sReceiveData.Count)
    Return
  Endif

  ' Format is: <MsgType> <index> <page> <data 8x bytes>
  ' Extract Page and Index information
  iIndex = $sReceiveData[1]
  iPage = $sReceiveData[2]

  ' Write to memory map structure, but remove the first 3 bytes from the data
  WriteMemoryMap(iPage, iIndex, $sReceiveData.Copy(3, $sReceiveData.Count - 3))

End

'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
' MsgType=3C - Panel information
' Direct message after we do a download start. Contains the paneltype information
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Private Sub Handle_MsgType3C()

  ' The panel information is in 5 & 6
  ' 6=PanelType e.g. PowerMax, PowerMaster
  ' 5=Sub model type of the panel - just informational
  $iPanelType = $sReceiveData[6]
  $iModelType = $sReceiveData[5]

  $bPowerMaster = ($iPanelType >= 7)

  If $bDebug Then Main.WriteDebugLog(LogLabel & "PanelType=" & DisplayPanelType() & ", Model=" & DisplayPanelModel())

  ' We got a first response, now we can continue enrollment the PowerMax/Master PowerLink
  PowerLinkEnrolled()

End

'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
' MsgType=3F - Download information
' Multiple 3F can follow eachother, if we request more then &HFF bytes
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Private Sub Handle_MsgType3F()

  Dim iPage As Integer
  Dim iIndex As Integer

  ' Format is: <MsgType> <index> <page> <length> <data ...>
  iIndex = $sReceiveData[1]
  iPage = $sReceiveData[2]

  ' Write to memory map structure, but remove the first 4 bytes from the data
  WriteMemoryMap(iPage, iIndex, $sReceiveData.Copy(4, $sReceiveData.Count - 4))

End

'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
' MsgType=A0 - Event Log
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Private Sub Handle_MsgTypeA0()

  Dim iSec, iMin, iHour, iDay, iMonth, iYear As Integer
  Dim iEventZone As Integer
  Dim iLogEvent As Integer
  Dim sEventZone As String
  Dim sLogEvent As String
  Dim sDate As String
  Dim dDate As Date

  ' Check for the first entry, it only contains the number of events
  If $sReceiveData[2] = &H01 Then

    If $bDebug Then Main.WriteDebugLog(LogLabel & "Eventlog received")

    $cSendLastCommand.ReceiveCnt = $sReceiveData[1] - 1
    $cSendLastCommand.ReceiveCntFixed = $sReceiveData[1] - 1
  Else

    If $bPowerMaster Then

      ' Set sec, min, etc to 1-Jan-2000 00:00:00
      iSec = 0
      iMin = 0
      iHour = 0
      iDay = 1
      iMonth = 1
      iYear = 2000

      dDate = Now()
      ' timestamp looks unixtime
      'sDate = "&H" & Hex$($sReceiveData[6], 2) & Hex$($sReceiveData[5], 2) & Hex$($sReceiveData[4], 2) & Hex$($sReceiveData[3], 2)
      'Try dDate = DateAdd(CDate("1/1/1970"), Val(sDate), gb.Second)
      'If Not Error Then
      '  iSec = Second(dDate)
      '  iMin = Minute(dDate)
      '  iHour = Hour(dDate)
      '  iDay = Day(dDate)
      '  iMonth = Month(dDate)
      '  iYear = Year(dDate)
      'Endif
    Else
      iSec = $sReceiveData[3]
      iMin = $sReceiveData[4]
      iHour = $sReceiveData[5]
      iDay = $sReceiveData[6]
      iMonth = $sReceiveData[7]
      iYear = CInt($sReceiveData[8]) + 2000
    Endif

    iEventZone = $sReceiveData[9]
    iLogEvent = $sReceiveData[10]
    Try sEventZone = $cConfig["zonenname"][iEventZone]
    If Error Then sEventZone = "Unknown (" & iEventZone & ")"
    Try sLogEvent = DisplayLogEvent(iLogEvent)
    If Error Then sLogEvent = "Unknown (" & iLogEvent & ")"

    If $bDebug Then
      sDate = CStr(iYear) & "/" & Format$(iMonth, "00") & "/" & Format$(iDay, "00") & " " & Format$(iHour, "00") & ":" & Format$(iMin, "00") & ":" & Format$(iSec, "00")
      Main.WriteDebugLog(LogLabel & "  " & sDate & " Zone: " & Format$(iEventZone) & ", Msg=" & sLogEvent)
    Endif
  Endif

End

'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
' A5 = Handle Status Messages
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Private Sub Handle_MsgTypeA5()

  Dim sLog As String
  Dim iDeviceId As Integer
  Dim iCnt As Integer
  Dim bByte As Byte
  Dim bBit As Byte

  ' Format: <msgtype> <total rows> <row> <data 8x bytes>

  Select Case $sReceiveData[2]
    Case &H01 ' Log Event Print
      If $bDebug Then Main.WriteDebugLog(LogLabel & "Log Event Print")

    Case &H02 ' Status message zones
      If $bDebug Then
        Main.WriteDebugLog(LogLabel & "Status and Battery Message")
        Main.WriteDebugLog(LogLabel & "Status Zones 01-08: " & DisplayZoneBin($sReceiveData[3]))
        Main.WriteDebugLog(LogLabel & "Status Zones 09-16: " & DisplayZoneBin($sReceiveData[4]))
        Main.WriteDebugLog(LogLabel & "Status Zones 17-24: " & DisplayZoneBin($sReceiveData[5]))
        Main.WriteDebugLog(LogLabel & "Status Zones 25-30: " & DisplayZoneBin($sReceiveData[6]))
        Main.WriteDebugLog(LogLabel & "Battery Zones 01-08: " & DisplayZoneBin($sReceiveData[7]))
        Main.WriteDebugLog(LogLabel & "Battery Zones 09-16: " & DisplayZoneBin($sReceiveData[8]))
        Main.WriteDebugLog(LogLabel & "Battery Zones 17-24: " & DisplayZoneBin($sReceiveData[9]))
        Main.WriteDebugLog(LogLabel & "Battery Zones 25-30: " & DisplayZoneBin($sReceiveData[10]))
      Endif 

      ' Send an "On" when the zone status is 1. This doesn't work for PowerMaster PIRs, but seems to work for magnets
      For iCnt = 1 To 30
        bByte = (iCnt - 1) / 8
        bBit = (iCnt - 1) Mod 8

        ' Only do it, when the zone information is known
        If $cConfig And If $cConfig["zoneinfo"].Exist(iCnt) And If $cConfig["zoneinfo"][iCnt]["sensortype"] Then

          ' Check the zone status
          If ($sReceiveData[3 + bByte] And CInt(2 ^ bBit)) <> $cConfig["zoneinfo"][iCnt]["tripstatus"] Then

            ' Try to find it, it will autocreate the device if needed
            iDeviceId = Devices.Find(Instance, "Z" & Format$(iCnt, "00"), InterfaceId, $cConfig["zoneinfo"][iCnt]["autocreate"])

            If ($sReceiveData[3 + bByte] And CInt(2 ^ bBit)) = 0 Then
              If iDeviceId Then Devices.ValueUpdate(iDeviceId, 1, "Off")
            Else
              If iDeviceId Then Devices.ValueUpdate(iDeviceId, 1, "On")
              EnableTripTimer("Z" & Format$(iCnt, "00"))
            Endif

            $cConfig["zoneinfo"][iCnt]["tripstatus"] = ($sReceiveData[3 + bByte] And CInt(2 ^ bBit))
          Endif

          ' Check the battery status
          If ($sReceiveData[7 + bByte] And CInt(2 ^ bBit)) <> $cConfig["zoneinfo"][iCnt]["batterystatus"] Then

            ' Try to find it, it will autocreate the device if needed
            iDeviceId = Devices.Find(Instance, "Z" & Format$(iCnt, "00"), InterfaceId, $cConfig["zoneinfo"][iCnt]["autocreate"])

            If ($sReceiveData[7 + bByte] And CInt(2 ^ bBit)) = 0 Then
              If iDeviceId Then Devices.Battery(iDeviceId, "Low")
            Else
              If iDeviceId Then Devices.Battery(iDeviceId, "OK")
            Endif

            ' Store latest battery status, we don't want to generate too many valueupdates
            $cConfig["zoneinfo"][iCnt]["batterystatus"] = ($sReceiveData[7 + bByte] And CInt(2 ^ bBit))
          Endif

        Else
          'Main.WriteLog(LogLabel & "ERROR: Zone information for zone '" & iCnt & "' is unknown, possible the Plugin couldn't retrieve the information from the panel?")
        Endif
      Next

    Case &H03 ' Tamper event
      If $bDebug Then Main.WriteDebugLog(LogLabel & "Tamper Event")

    Case &H04 ' Zone event
      Select Case $sReceiveData[3] ' System Status
        Case &H00
          sLog = "Disarm"
        Case &H01
          sLog = "Exit Delay, Arming Home"
        Case &H02
          sLog = "Exit Delay, Arming Away"
        Case &H03
          sLog = "Entry Delay"
        Case &H04
          sLog = "Armed Home"
        Case &H05
          sLog = "Armed Away"
        Case &H06
          sLog = "User Test"
        Case &H07
          sLog = "Downloading"
        Case &H08
          sLog = "Programming"
        Case &H09
          sLog = "Installer"
        Case &H0A
          sLog = "Home Bypass"
        Case &H0B
          sLog = "Away Bypass"
        Case &H0C
          sLog = "Ready"
        Case &H0D
          sLog = "Not Ready"
        Default
          sLog = "Unknown (" & Hex$($sReceiveData[3], 2) & ")"
      End Select

      If $bDebug Then Main.WriteDebugLog(LogLabel & "Zone Event " & sLog)

      If ($sReceiveData[4] And 1) Then
        If $bDebug Then Main.WriteDebugLog(LogLabel & "Bit 0 set, Ready")
      Endif
      If ($sReceiveData[4] And 2) Then
        If $bDebug Then Main.WriteDebugLog(LogLabel & "Bit 1 set, Alert in Memory")
      Endif
      If ($sReceiveData[4] And 4) Then 
        If $bDebug Then Main.WriteDebugLog(LogLabel & "Bit 2 set, Trouble!")
      Endif
      If ($sReceiveData[4] And 8) Then 
        If $bDebug Then Main.WriteDebugLog(LogLabel & "Bit 3 set, Bypass")
      Endif
      If ($sReceiveData[4] And 16) Then 
        If $bDebug Then Main.WriteDebugLog(LogLabel & "Bit 4 set, Last 10 seconds of entry/exit")
      Endif
      If ($sReceiveData[4] And 32) Then 
        If $bDebug Then Main.WriteDebugLog(LogLabel & "Bit 5 set, Zone Event")
        If $bDebug Then Main.WriteDebugLog(LogLabel & "Zone: " & Hex$($sReceiveData[5], 2))

        Select Case $sReceiveData[6]
          Case &H00 ' None
            sLog = "No Zone Event"
          Case &H01 ' Tamper Alarm
            sLog = "Tamper Alarm"
          Case &H02 ' Tamper Restore
            sLog = "Tamper Alarm Restored"
          Case &H03 ' Open
            sLog = "Zone Open"
          Case &H04 ' Closed
            sLog = "Zone Closed"
          Case &H05 ' Violated (Motion)
            sLog = "Zone Violation, Motion Detected"
          Case &H06 ' Panic Alarm
            sLog = "Zone Panic Alarm"
          Case &H07 ' RF Jamming
            sLog = "RF Jamming Detected"
          Case &H08 ' Tamper Open
            sLog = "Zone Tamper Alarm Open"
          Case &H09 ' Communication Failure
            sLog = "Zone Communication Failure"
          Case &H0A ' Line Failure
            sLog = "Zone Line Failure"
          Case &H0B ' Fuse
            sLog = "Zone Fuse"
          Case &H0C ' Not Active
            sLog = "Zone Not Active"
          Case &H0D ' Low Battery
            sLog = "Zone Low Battery"
          Case &H0E ' AC Failure
            sLog = "Zone AC Failure"
          Case &H0F ' Fire Alarm
            sLog = "Zone Fire Alarm"
          Case &H10 ' Emergency
            sLog = "Zone Emergency"
          Case &H11 ' Siren Tamper
            sLog = "Zone Siren Tamper"
          Case &H12 ' Siren Tamper Restore
            sLog = "Zone Siren Tamper Restored"
          Case &H13 ' Siren Low Battery
            sLog = "Zone Siren Low Battery"
          Case &H14 ' Siren AC Fail
            sLog = "Zone Siren AC Failure"
          Default
            sLog = "Unknown (" & Hex$($sReceiveData[6]) & ")"
        End Select

        If $bDebug Then Main.WriteDebugLog(LogLabel & "Bit 5 set, Zone Event")
        If $bDebug Then Main.WriteDebugLog(LogLabel & "Zone: " & $sReceiveData[5] & ", " & sLog)
      Endif

      If ($sReceiveData[4] And 64) Then 
        If $bDebug Then Main.WriteDebugLog(LogLabel & "Bit 6 set, Arm")
      Endif
      If ($sReceiveData[4] And 128) Then 
        If $bDebug Then Main.WriteDebugLog(LogLabel & "Bit 7 set, Alarm!")
      Endif

      ' Trigger a zone event
      If $sReceiveData[7] = 3 Or If $sReceiveData[7] = 4 Or If $sReceiveData[7] = 5 Then

        If $cConfig And If $cConfig["zoneinfo"][$sReceiveData[5]]["sensortype"] Then

          ' Try to find it, it will autocreate the device if needed
          iDeviceId = Devices.Find(Instance, "Z" & Format$(iCnt, "00"), InterfaceId, $cConfig["zoneinfo"][$sReceiveData[5]]["autocreate"])
          If iDeviceId Then Devices.ValueUpdate(iDeviceId, 1, "On")
          EnableTripTimer("Z" & Format$(iCnt, "00"))
        Else
          Main.WriteLog(LogLabel & "ERROR: Zone information for zone '" & $sReceiveData[5] & "' is unknown, possible the Plugin couldn't retrieve the information from the panel?")
        Endif

      Endif

    Case &H06 ' Status message enrolled/bypassed
      If $bDebug Then
        Main.WriteDebugLog(LogLabel & "Enrollment and Bypass Message")
        Main.WriteDebugLog(LogLabel & "Enrolled Zones 01-08: " & DisplayZoneBin($sReceiveData[3]))
        Main.WriteDebugLog(LogLabel & "Enrolled Zones 09-16: " & DisplayZoneBin($sReceiveData[4]))
        Main.WriteDebugLog(LogLabel & "Enrolled Zones 17-24: " & DisplayZoneBin($sReceiveData[5]))
        Main.WriteDebugLog(LogLabel & "Enrolled Zones 25-30: " & DisplayZoneBin($sReceiveData[6]))
        Main.WriteDebugLog(LogLabel & "Bypassed Zones 01-08: " & DisplayZoneBin($sReceiveData[7]))
        Main.WriteDebugLog(LogLabel & "Bypassed Zones 09-16: " & DisplayZoneBin($sReceiveData[8]))
        Main.WriteDebugLog(LogLabel & "Bypassed Zones 17-24: " & DisplayZoneBin($sReceiveData[9]))
        Main.WriteDebugLog(LogLabel & "Bypassed Zones 25-30: " & DisplayZoneBin($sReceiveData[10]))
      Endif

    Default
      If $bDebug Then Main.WriteDebugLog(LogLabel & "Unknown A5 event: " & Hex$($sReceiveData[2], 2))
  End Select

End

'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
' MsgType=A7 - Panel Status Change
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Private Sub Handle_MsgTypeA7()

  If $bDebug Then Main.WriteDebugLog(LogLabel & "Panel Status Change")

   If $bDebug Then Main.WriteDebugLog(LogLabel & "Zone/User: " & DisplayZoneUser($sReceiveData[3]))
   If $bDebug Then Main.WriteDebugLog(LogLabel & "Log Event: " & DisplayLogEvent($sReceiveData[4]))

End

'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
' MsgType=AB - PowerLink message
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Private Sub Handle_MsgTypeAB()

  Select Case $sReceiveData[1]
    Case &H03 ' PowerLink keep-alive
      If $bDebug Then Main.WriteDebugLog(LogLabel & "PowerLink Keep-Alive (" & ByteToString($sReceiveData.Copy(5, 4)) & ")")

      ' We received a keep-alive, restart timer
      $tPowerLinkKeepAlive.Stop
      $tPowerLinkKeepAlive = New Timer As "tPowerLinkKeepAlive"
      $tPowerLinkKeepAlive.Delay = $iPowerLinkTimeOut
      $tPowerLinkKeepAlive.Start

    Case &H05 ' Phone message
      Select $sReceiveData[3]
        Case &H01
          If $bDebug Then Main.WriteDebugLog(LogLabel & "PowerLink Phone: Calling User")
        Case &H02
          If $bDebug Then Main.WriteDebugLog(LogLabel & "PowerLink Phone: User Acknowledged")
        Default
          If $bDebug Then Main.WriteDebugLog(LogLabel & "PowerLink Phone: Unknown Action " & Hex$($sReceiveData[3], 2))
      End Select

    Case &H0A ' PowerLink most likely wants to auto-enroll

      If $sReceiveData[3] = &H01 Then

        ' Send the auto-enroll message with the new download pin/code
        SendMsg_ENROLL()

        ' Restart the timer
        $tPowerLinkKeepAlive.Stop
        $tPowerLinkKeepAlive = New Timer As "tPowerLinkKeepAlive"
        $tPowerLinkKeepAlive.Delay = $iPowerLinkTimeOut
        $tPowerLinkKeepAlive.Start
      Endif

    Default
      If $bDebug Then Main.WriteDebugLog(LogLabel & "Unknown AB Message: " & Hex$($sReceiveData[1], 2))

  End Select

End

'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
' B0 = Handle PowerMaster message
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Private Sub Handle_MsgTypeB0()

  If $bDebug Then Main.WriteDebugLog(LogLabel & "PowerMaster Message")

  ' Format: <Type> <SubType> <Length> <Data>

  ' Only do it in this scenario
  If $sReceiveData[1] = &H03 And If $sReceiveData[2] = &H39 Then
    QueueCommand(VMSG_PMASTER_STAT1, "PowerMaster Msg1", &HB0)
    QueueCommand(VMSG_PMASTER_STAT2, "PowerMaster Msg2", &HB0)
  Endif

End

'########################################################
' Trip timers functions
'########################################################

'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
' Enable or restart the trip timer
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Private Sub EnableTripTimer(sZone As String)

  Dim oObject As Object

  ' First try to find running timers and remove it
  For Each oObject In $oTripTimers
    If oObject.Tag = sZone Then
      $oTripTimers.Remove($oTripTimers.Find(oObject))
      Break
    Endif
  Next

  ' Start the timer (again)
  $tTripTimer = New CTimerGeneric As "tTripTimer"
  $oTripTimers.Add($tTripTimer)

  $tTripTimer.Delay = $iTripReset * 1000
  $tTripTimer.Start

End

'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
' Trip timer expired, reset the zone to Off
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Public Sub tTripTimer_Timer()

  Dim iDeviceId As Integer
  Dim sZone As String
  Dim iZone As Integer

  ' Retrieve the zone information, stop and remove the timer
  sZone = Last.Tag
  Try iZone = CInt(Mid$(sZone, 1))
  Last.Stop
  $oTripTimers.Remove($oTripTimers.Find(Last))

  If $cConfig And If $cConfig["zoneinfo"].Exist(iZone) And If $cConfig["zoneinfo"][iZone]["sensortype"] Then

    ' Try to find it, it will autocreate the device if needed
    iDeviceId = Devices.Find(Instance, sZone, InterfaceId, $cConfig["zoneinfo"][iZone]["autocreate"])
    If iDeviceId Then Devices.ValueUpdate(iDeviceId, 1, "Off")
  Else
    Main.WriteLog(LogLabel & "ERROR: Zone information for zone '" & iZone & "' is unknown, possible the Plugin couldn't retrieve the information from the panel?")
  Endif

End

'########################################################
' Display functions
'########################################################

'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
' Convert an array of bytes to a string, also remove space at the end of the string
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Private Sub ByteToString(aStr As Byte[]) As String

  Dim bVal As Byte
  Dim sStr As String

  For Each bVal In aStr
    ' If the value is &HFF, most likely we hit end of the string and we should stop processing
    If bVal = &HFF Then Return RTrim$(sStr)

    ' Append byte as character to string
    ' TODO: None-Ascii characters
    sStr &= Chr$(bVal)
  Next

  Return RTrim$(sStr)

End

'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
' Convert an array of bytes to a hex string
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Private Sub ByteToHex(aStr As Byte[], Optional bSpace As Boolean = False) As String

  Dim bVal As Byte
  Dim sStr As String

  For Each bVal In aStr
    ' Append byte as character to string
    If bSpace And If sStr Then sStr &= " "
    sStr &= Hex$(bVal, 2)
  Next

  Return sStr

End

'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
' Display Short PanelType name
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Private Sub DisplayPanelType() As String

  Select $iPanelType
    Case &H00
      Return "PowerMax"
    Case &H01
      Return "PowerMax+"
    Case &H02
      Return "PowerMax Pro"
    Case &H03
      Return "PowerMax Complete"
    Case &H04
      Return "PowerMax Pro Part"
    Case &H05
      Return "PowerMax Complete Part"
    Case &H06
      Return "PowerMax Express"
    Case &H07
      Return "PowerMaster10"
    Case &H08
      Return "PowerMaster30"
    Default
      Return "Unknown"
  End Select

End

'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
' Display the panels model name
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Private Sub DisplayPanelModel() As String

  Select ((CInt($iPanelType) * &H100) + $iModelType)
    Case &H0000
      Return "PowerMax"
    Case &H0001
      Return "PowerMax LT"
    Case &H0004
      Return "PowerMax A"
    Case &H0005
      Return "PowerMax"
    Case &H0006
      Return "PowerMax LT"
    Case &H0009
      Return "PowerMax B"
    Case &H000A
      Return "PowerMax A"
    Case &H000B
      Return "PowerMax"
    Case &H000C
      Return "PowerMax LT"
    Case &H000F
      Return "PowerMax B"
    Case &H0014
      Return "PowerMax A"
    Case &H0015
      Return "PowerMax"
    Case &H0016
      Return "PowerMax"
    Case &H0017
      Return "PowerArt"
    Case &H0018
      Return "PowerMax SC"
    Case &H0019
      Return "PowerMax SK"
    Case &H001A
      Return "PowerMax SV"
    Case &H001B
      Return "PowerMax T"
    Case &H001E
      Return "PowerMax WSS"
    Case &H001F
      Return "PowerMax Smith"
    Case &H0100
      Return "PowerMax+"
    Case &H0103
      Return "PowerMax+ UK (3)"
    Case &H0104
      Return "PowerMax+ JP"
    Case &H0106
      Return "PowerMax+ CTA"
    Case &H0108
      Return "PowerMax+"
    Case &H010a
      Return "PowerMax+ SH"
    Case &H010b
      Return "PowerMax+ CF"
    Case &H0112
      Return "PowerMax+ WSS"
    Case &H0113
      Return "PowerMax+ 2INST"
    Case &H0114
      Return "PowerMax+ HL"
    Case &H0115
      Return "PowerMax+ UK"
    Case &H0116
      Return "PowerMax+ 2INST3"
    Case &H0118
      Return "PowerMax+ CF"
    Case &H0119
      Return "PowerMax+ 2INST"
    Case &H011A
      Return "PowerMax+"
    Case &H011C
      Return "PowerMax+ WSS"
    Case &H011D
      Return "PowerMax+ UK"
    Case &H0120
      Return "PowerMax+ 2INST33"
    Case &H0121
      Return "PowerMax+"
    Case &H0122
      Return "PowerMax+ CF"
    Case &H0124
      Return "PowerMax+ UK"
    Case &H0127
      Return "PowerMax+ 2INST_MONITOR"
    Case &H0128
      Return "PowerMax+ KeyOnOff"
    Case &H0129
      Return "PowerMax+ 2INST_MONITOR"
    Case &H012A
      Return "PowerMax+ 2INST_MONITOR42"
    Case &H012B
      Return "PowerMax+ 2INST33"
    Case &H012C
      Return "PowerMax+ One Inst_1_44_0"
    Case &H012D
      Return "PowerMax+ CF_1_45_0"
    Case &H012E
      Return "PowerMax+ SA_1_46"
    Case &H012F
      Return "PowerMax+ UK_1_47"
    Case &H0130
      Return "PowerMax+ SA UK_1_48"
    Case &H0132
      Return "PowerMax+ KeyOnOff 1_50"
    Case &H0201
      Return "PowerMax Pro"
    Case &H0202
      Return "PowerMax Pro-Nuon"
    Case &H0204
      Return "PowerMax Pro-PortugalTelecom"
    Case &H020a
      Return "PowerMax Pro-PortugalTelecom2"
    Case &H020c
      Return "PowerMax HW-V9 Pro"
    Case &H020d
      Return "PowerMax ProSms"
    Case &H0214
      Return "PowerMax Pro-PortugalTelecom_4_5_02"
    Case &H0216
      Return "PowerMax HW-V9_4_5_02 Pro"
    Case &H0217
      Return "PowerMax ProSms_4_5_02"
    Case &H0218
      Return "PowerMax UK_DD243_4_5_02 Pro M"
    Case &H021B
      Return "PowerMax Pro-Part2__2_27"
    Case &H0223
      Return "PowerMax Pro Bell-Canada"
    Case &H0301
      Return "PowerMax Complete"
    Case &H0302
      Return "PowerMax Complete_NV"
    Case &H0303
      Return "PowerMax Complete-PortugalTelecom"
    Case &H0307
      Return "PowerMax Complete_1_0_07"
    Case &H0308
      Return "PowerMax Complete_NV_1_0_07"
    Case &H030A
      Return "PowerMax Complete_UK_DD243_1_1_03"
    Case &H030B
      Return "PowerMax Complete_COUNTERFORCE_1_0_06"
    Case &H0401
      Return "PowerMax Pro-Part"
    Case &H0402
      Return "PowerMax Pro-Part CellAdaptor"
    Case &H0405
      Return "PowerMax Pro-Part_5_0_08"
    Case &H0406
      Return "PowerMax Pro-Part CellAdaptor_5_2_04"
    Case &H0407
      Return "PowerMax Pro-Part KeyOnOff_5_0_08"
    Case &H0408
      Return "PowerMax UK Pro-Part_5_0_08"
    Case &H0409
      Return "PowerMax SectorUK Pro-Part_5_0_08"
    Case &H040A
      Return "PowerMax Pro-Part CP1 4_10"
    Case &H040C
      Return "PowerMax Pro-Part_Cell_key_4_12"
    Case &H040D
      Return "PowerMax Pro-Part UK 4_13"
    Case &H040E
      Return "PowerMax SectorUK Pro-Part_4_14"
    Case &H040F
      Return "PowerMax Pro-Part UK 4_15"
    Case &H0410
      Return "PowerMax Pro-Part CP1 4_16"
    Case &H0411
      Return "PowerMax NUON key 4_17"
    Case &H0433
      Return "PowerMax Pro-Part2__4_51"
    Case &H0434
      Return "PowerMax UK Pro-Part2__4_52"
    Case &H0436
      Return "PowerMax Pro-Part2__4_54"
    Case &H0437
      Return "PowerMax Pro-Part2__4_55 (CP_01)"
    Case &H0438
      Return "PowerMax Pro-Part2__4_56"
    Case &H0439
      Return "PowerMax Pro-Part2__4_57 (NUON)"
    Case &H043a
      Return "PowerMax Pro 4_58"
    Case &H043c
      Return "PowerMax Pro 4_60"
    Case &H043e
      Return "PowerMax Pro-Part2__4_62"
    Case &H0440
      Return "PowerMax Pro-Part2__4_64"
    Case &H0442
      Return "PowerMax 4_66"
    Case &H0443
      Return "PowerMax Pro 4_67"
    Case &H0444
      Return "PowerMax Pro 4_68"
    Case &H0445
      Return "PowerMax Pro 4_69"
    Case &H0446
      Return "PowerMax Pro-Part2__4_70"
    Case &H0447
      Return "PowerMax 4_71"
    Case &H0449
      Return "PowerMax 4_73"
    Case &H044b
      Return "PowerMax Pro-Part2__4_75"
    Case &H0451
      Return "PowerMax Pro 4_81"
    Case &H0452
      Return "PowerMax Pro 4_82"
    Case &H0454
      Return "PowerMax 4_84"
    Case &H0455
      Return "PowerMax 4_85"
    Case &H0456
      Return "PowerMax 4_86"
    Case &H0503
      Return "PowerMax UK Complete partition 1_5_00"
    Case &H050a
      Return "PowerMax Complete partition GPRS"
    Case &H050b
      Return "PowerMax Complete partition NV GPRS"
    Case &H050c
      Return "PowerMax Complete partition GPRS NO-BBA"
    Case &H050d
      Return "PowerMax Complete partition NV GPRS NO-BBA"
    Case &H050e
      Return "PowerMax Complete part. GPRS NO-BBA UK_5_14"
    Case &H0511
      Return "PowerMax Pro-Part CP1 GPRS 5_17"
    Case &H0512
      Return "PowerMax Complete part. BBA UK_5_18"
    Case &H0533
      Return "PowerMax Complete part2 5_51"
    Case &H0534
      Return "PowerMax Complete part2 5_52 (UK)"
    Case &H0536
      Return "PowerMax Complete 5_54 (GR)"
    Case &H0537
      Return "PowerMax Complete 5_55"
    Case &H053A
      Return "PowerMax Complete 5_58 (PT)"
    Case &H053B
      Return "PowerMax Complete part2 5_59 (NV)"
    Case &H053C
      Return "PowerMax Complete 5_60"
    Case &H053E
      Return "PowerMax Complete 5_62"
    Case &H053F
      Return "PowerMax Complete part2  5_63"
    Case &H0540
      Return "PowerMax Complete 5_64"
    Case &H0541
      Return "PowerMax Complete 5_65"
    Case &H0543
      Return "PowerMax Complete 5_67"
    Case &H0544
      Return "PowerMax Complete 5_68"
    Case &H0545
      Return "PowerMax Complete 5_69"
    Case &H0546
      Return "PowerMax Complete 5_70"
    Case &H0547
      Return "PowerMax Complete 5_71"
    Case &H0549
      Return "PowerMax Complete 5_73"
    Case &H054B
      Return "PowerMax Complete 5_75"
    Case &H054F
      Return "PowerMax Complete 5_79"
    Case &H0601
      Return "PowerMax Express"
    Case &H0603
      Return "PowerMax Express CP 01"
    Case &H0605
      Return "PowerMax Express OEM 6_5"
    Case &H0607
      Return "PowerMax Express BBA 6_7"
    Case &H0608
      Return "PowerMax Express CP 01 BBA 6_8"
    Case &H0609
      Return "PowerMax Express OEM1 BBA 6_9"
    Case &H060B
      Return "PowerMax Express BBA 6_11"
    Case &H0633
      Return "PowerMax Express 6_51"
    Case &H063B
      Return "PowerMax Express 6_59"
    Case &H063D
      Return "PowerMax Express 6_61"
    Case &H063E
      Return "PowerMax Express 6_62 (UK)"
    Case &H0645
      Return "PowerMax Express 6_69"
    Case &H0647
      Return "PowerMax Express 6_71"
    Case &H0648
      Return "PowerMax Express 6_72"
    Case &H0649
      Return "PowerMax Express 6_73"
    Case &H064A
      Return "PowerMax Activa 6_74"
    Case &H064C
      Return "PowerMax Express 6_76"
    Case &H064D
      Return "PowerMax Express 6_77"
    Case &H064E
      Return "PowerMax Express 6_78"
    Case &H064F
      Return "PowerMax Secure 6_79"
    Case &H0650
      Return "PowerMax Express 6_80"
    Case &H0650
      Return "PowerMax Express part2 M 6_80"
    Case &H0651
      Return "PowerMax Express 6_81"
    Case &H0652
      Return "PowerMax Express 6_82"
    Case &H0653
      Return "PowerMax Express 6_83"
    Case &H0654
      Return "PowerMax 6_84"
    Case &H0655
      Return "PowerMax 6_85"
    Case &H0658
      Return "PowerMax 6_88"
    Case &H0659
      Return "PowerMax 6_89"
    Case &H065A
      Return "PowerMax 6_90"
    Case &H065B
      Return "PowerMax 6_91"
    Case &H0701
      Return "PowerMax PowerCode-G 7_1"
    Case &H0702
      Return "PowerMax PowerCode-G 7_2"
    Case &H0704
      Return "PowerMaster10 7_4"
    Case &H0705
      Return "PowerMaster10 7_05"
    Case &H0707
      Return "PowerMaster10 7_07"
    Case &H070C
      Return "PowerMaster10 7_12"
    Case &H070F
      Return "PowerMaster10 7_15"
    Case &H0710
      Return "PowerMaster10 7_16"
    Case &H0711
      Return "PowerMaster10 7_17"
    Case &H0712
      Return "PowerMaster10 7_18"
    Case &H0713
      Return "PowerMaster10 7_19"
    Case &H0802
      Return "PowerMax Complete PowerCode-G 8_2"
    Case &H0803
      Return "PowerMaster30 8_3"
    Case &H080F
      Return "PowerMaster30 8_15"
    Case &H0810
      Return "PowerMaster30 8_16"
    Case &H0812
      Return "PowerMaster30 8_18"
    Case &H0813
      Return "PowerMaster30 8_19"
    Case &H0815
      Return "PowerMaster30 8_21"
    Default
      Return "Unknown (" & Hex$((CInt($iPanelType) * &H100) + $iModelType, 4) & ")"
  End Select

End

'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
' Display Zone/User
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Private Sub DisplayZoneUser(bType As Byte) As String

  Select bType
    Case &H00
      Return "System"
    Case &H01
      Return "Zone 1"
    Case &H02
      Return "Zone 2"
    Case &H03
      Return "Zone 3"
    Case &H04
      Return "Zone 4"
    Case &H05
      Return "Zone 5"
    Case &H06
      Return "Zone 6"
    Case &H07
      Return "Zone 7"
    Case &H08
      Return "Zone 8"
    Case &H09
      Return "Zone 9"
    Case &H0A
      Return "Zone 10"
    Case &H0B
      Return "Zone 11"
    Case &H0C
      Return "Zone 12"
    Case &H0D
      Return "Zone 13"
    Case &H0E
      Return "Zone 14"
    Case &H0F
      Return "Zone 15"
    Case &H10
      Return "Zone 16"
    Case &H11
      Return "Zone 17"
    Case &H12
      Return "Zone 18"
    Case &H13
      Return "Zone 19"
    Case &H14
      Return "Zone 20"
    Case &H15
      Return "Zone 21"
    Case &H16
      Return "Zone 22"
    Case &H17
      Return "Zone 23"
    Case &H18
      Return "Zone 24"
    Case &H19
      Return "Zone 25"
    Case &H1A
      Return "Zone 26"
    Case &H1B
      Return "Zone 27"
    Case &H1C
      Return "Zone 28"
    Case &H1D
      Return "Zone 29"
    Case &H1E
      Return "Zone 30"
    Case &H1F
      Return "Keyfob1"
    Case &H20
      Return "Keyfob2"
    Case &H21
      Return "Keyfob3"
    Case &H22
      Return "Keyfob4"
    Case &H23
      Return "Keyfob5"
    Case &H24
      Return "Keyfob6"
    Case &H25
      Return "Keyfob7"
    Case &H26
      Return "Keyfob8"
    Case &H27
      Return "User1"
    Case &H28
      Return "User2"
    Case &H29
      Return "User3"
    Case &H2A
      Return "User4"
    Case &H2B
      Return "User5"
    Case &H2C
      Return "User6"
    Case &H2D
      Return "User7"
    Case &H2E
      Return "User8"
    Case &H2F
      Return "Wireless Commander1"
    Case &H30
      Return "Wireless Commander2"
    Case &H31
      Return "Wireless Commander3"
    Case &H32
      Return "Wireless Commander4"
    Case &H33
      Return "Wireless Commander5"
    Case &H34
      Return "Wireless Commander6"
    Case &H35
      Return "Wireless Commander7"
    Case &H36
      Return "Wireless Commander8"
    Case &H37
      Return "Wireless Siren1"
    Case &H38
      Return "Wireless Siren2"
    Case &H39
      Return "2Way Wireless Keypad1"
    Case &H3A
      Return "2Way Wireless Keypad2"
    Case &H3B
      Return "2Way Wireless Keypad3"
    Case &H3C
      Return "2Way Wireless Keypad4"
    Case &H3D
      Return "X10-1"
    Case &H3E
      Return "X10-2"
    Case &H3F
      Return "X10-3"
    Case &H40
      Return "X10-4"
    Case &H41
      Return "X10-5"
    Case &H42
      Return "X10-6"
    Case &H43
      Return "X10-7"
    Case &H44
      Return "X10-8"
    Case &H45
      Return "X10-9"
    Case &H46
      Return "X10-10"
    Case &H47
      Return "X10-11"
    Case &H48
      Return "X10-12"
    Case &H49
      Return "X10-13"
    Case &H4A
      Return "X10-14"
    Case &H4B
      Return "X10-15"
    Case &H4C
      Return "PGM"
    Case &H4D
      Return "GSM"
    Case &H4E
      Return "Powerlink"
    Case &H4F
      Return "Proxy Tag1"
    Case &H50
      Return "Proxy Tag2"
    Case &H51
      Return "Proxy Tag3"
    Case &H52
      Return "Proxy Tag4"
    Case &H53
      Return "Proxy Tag5"
    Case &H54
      Return "Proxy Tag6"
    Case &H55
      Return "Proxy Tag7"
    Case &H56
      Return "Proxy Tag8"
    Default
      Return "Unknown (" & Hex$(bType, 2) & ")"
  End Select

End

'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
' Display Log Event
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Private Sub DisplayLogEvent(bType As Byte) As String

  Select bType
    Case &H00
      Return "None"
    Case &H01
      Return "Interior Alarm"
    Case &H02
      Return "Perimeter Alarm"
    Case &H03
      Return "Delay Alarm"
    Case &H04
      Return "24h Silent Alarm"
    Case &H05
      Return "24h Audible Alarm"
    Case &H06
      Return "Tamper"
    Case &H07
      Return "Control Panel Tamper"
    Case &H08
      Return "Tamper Alarm"
    Case &H09
      Return "Tamper Alarm"
    Case &H0A
      Return "Communication Loss"
    Case &H0B
      Return "Panic From Keyfob"
    Case &H0C
      Return "Panic From Control Panel"
    Case &H0D
      Return "Duress"
    Case &H0E
      Return "Confirm Alarm"
    Case &H0F
      Return "General Trouble"
    Case &H10
      Return "General Trouble Restore"
    Case &H11
      Return "Interior Restore"
    Case &H12
      Return "Perimeter Restore"
    Case &H13
      Return "Delay Restore"
    Case &H14
      Return "24h Silent Restore"
    Case &H15
      Return "24h Audible Restore"
    Case &H16
      Return "Tamper Restore"
    Case &H17
      Return "Control Panel Tamper Restore"
    Case &H18
      Return "Tamper Restore"
    Case &H19
      Return "Tamper Restore"
    Case &H1A
      Return "Communication Restore"
    Case &H1B
      Return "Cancel Alarm"
    Case &H1C
      Return "General Restore"
    Case &H1D
      Return "Trouble Restore"
    Case &H1E
      Return "Not used"
    Case &H1F
      Return "Recent Close"
    Case &H20
      Return "Fire"
    Case &H21
      Return "Fire Restore"
    Case &H22
      Return "No Active"
    Case &H23
      Return "Emergency"
    Case &H24
      Return "No used"
    Case &H25
      Return "Disarm Latchkey"
    Case &H26
      Return "Panic Restore"
    Case &H27
      Return "Supervision (Inactive)"
    Case &H28
      Return "Supervision Restore (Active)"
    Case &H29
      Return "Low Battery"
    Case &H2A
      Return "Low Battery Restore"
    Case &H2B
      Return "AC Fail"
    Case &H2C
      Return "AC Restore"
    Case &H2D
      Return "Control Panel Low Battery"
    Case &H2E
      Return "Control Panel Low Battery Restore"
    Case &H2F
      Return "RF Jamming"
    Case &H30
      Return "RF Jamming Restore"
    Case &H31
      Return "Communications Failure"
    Case &H32
      Return "Communications Restore"
    Case &H33
      Return "Telephone Line Failure"
    Case &H34
      Return "Telephone Line Restore"
    Case &H35
      Return "Auto Test"
    Case &H36
      Return "Fuse Failure"
    Case &H37
      Return "Fuse Restore"
    Case &H38
      Return "Keyfob Low Battery"
    Case &H39
      Return "Keyfob Low Battery Restore"
    Case &H3A
      Return "Engineer Reset"
    Case &H3B
      Return "Battery Disconnect"
    Case &H3C
      Return "1-Way Keypad Low Battery"
    Case &H3D
      Return "1-Way Keypad Low Battery Restore"
    Case &H3E
      Return "1-Way Keypad Inactive"
    Case &H3F
      Return "1-Way Keypad Restore Active"
    Case &H40
      Return "Low Battery"
    Case &H41
      Return "Clean Me"
    Case &H42
      Return "Fire Trouble"
    Case &H43
      Return "Low Battery"
    Case &H44
      Return "Battery Restore"
    Case &H45
      Return "AC Fail"
    Case &H46
      Return "AC Restore"
    Case &H47
      Return "Supervision (Inactive)"
    Case &H48
      Return "Supervision Restore (Active)"
    Case &H49
      Return "Gas Alert"
    Case &H4A
      Return "Gas Alert Restore"
    Case &H4B
      Return "Gas Trouble"
    Case &H4C
      Return "Gas Trouble Restore"
    Case &H4D
      Return "Flood Alert"
    Case &H4E
      Return "Flood Alert Restore"
    Case &H4F
      Return "X-10 Trouble"
    Case &H50
      Return "X-10 Trouble Restore"
    Case &H51
      Return "Arm Home"
    Case &H52
      Return "Arm Away"
    Case &H53
      Return "Quick Arm Home"
    Case &H54
      Return "Quick Arm Away"
    Case &H55
      Return "Disarm"
    Case &H56
      Return "Fail To Auto-Arm"
    Case &H57
      Return "Enter To Test Mode"
    Case &H58
      Return "Exit From Test Mode"
    Case &H59
      Return "Force Arm"
    Case &H5A
      Return "Auto Arm"
    Case &H5B
      Return "Instant Arm"
    Case &H5C
      Return "Bypass"
    Case &H5D
      Return "Fail To Arm"
    Case &H5E
      Return "Door Open"
    Case &H5F
      Return "Communication Established By Control Panel"
    Case &H60
      Return "System Reset"
    Case &H61
      Return "Installer Programming"
    Case &H62
      Return "Wrong Password"
    Case &H63
      Return "Not Sys Event"
    Case &H64
      Return "Not Sys Event"
    Case &H65
      Return "Extreme Hot Alert"
    Case &H66
      Return "Extreme Hot Alert Restore"
    Case &H67
      Return "Freeze Alert"
    Case &H68
      Return "Freeze Alert Restore"
    Case &H69
      Return "Human Cold Alert"
    Case &H6A
      Return "Human Cold Alert Restore"
    Case &H6B
      Return "Human Hot Alert"
    Case &H6C
      Return "Human Hot Alert Restore"
    Case &H6D
      Return "Temperature Sensor Trouble"
    Case &H6E
      Return "Temperature Sensor Trouble Restore"
    Case &H6F
      Return "PIR Mask"
    Case &H70
      Return "PIR Mask Restore"
    Case &H7B
      Return "Alarmed"
    Case &H7C
      Return "Restore"
    Case &H7D
      Return "Alarmed"
    Case &H7E
      Return "Restore"
    Case &H8E
      Return "Exit Installer"
    Case &H8F
      Return "Enter Installer"
    Default
      Return "Unknown (" & Hex$(bType, 2) & ")"
  End Select

End

'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
' Display Zone Even Type information
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Private Sub DisplayZoneEventType(bType As Byte) As String

  Select bType
    Case &H00
      Return "None" 
    Case &H01
      Return "Tamper Alarm"
    Case &H02
      Return "Tamper Restore"
    Case &H03
      Return "Open" 
    Case &H04
      Return "Closed"
    Case &H05
      Return "Violated (Motion)"
    Case &H06
      Return "Panic Alarm"
    Case &H07
      Return "RF Jamming"
    Case &H08
      Return "Tamper Open"
    Case &H09
      Return "Communication Failure"
    Case &H0A
      Return "Line Failure"
    Case &H0B
      Return "Fuse"
    Case &H0C
      Return "Not Active"
    Case &H0D
      Return "Low Battery"
    Case &H0E
      Return "AC Failure"
    Case &H0F
      Return "Fire Alarm"
    Case &H10
      Return "Emergency"
    Case &H11
      Return "Siren Tamper"
    Case &H12
      Return "Siren Tamper Restore"
    Case &H13
      Return "Siren Low Battery"
    Case &H14
      Return "Siren AC Fail"
    Default
      Return "Unknown (" & Hex$(bType, 2) & ")"
  End Select

End

'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
' Display Zone Type Name
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Private Sub DisplayZoneType(bType As Byte) As String

  Select bType
    Case &H00
      Return "Non-Alarm"
    Case &H01
      Return "Emergency"
    Case &H02
      Return "Flood"
    Case &H03
      Return "Gas"
    Case &H04
      Return "Delay 1"
    Case &H05
      Return "Delay 2"
    Case &H06
      Return "Interior-Follow"
    Case &H07
      Return "Perimeter"
    Case &H08
      Return "Perimeter-Follow"
    Case &H09
      Return "24 Hours Silent"
    Case &H0A
      Return "24 Hours Audible"
    Case &H0B
      Return "Fire"
    Case &H0C
      Return "Interior"
    Case &H0D
      Return "Home Delay"
    Case &H0E
      Return "Temperature"
    Case &H0F
      Return "Outdoor"
    Default
      Return "Unknown (" & Hex$(bType, 2) & ")"
  End Select

End

'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
' Display Zones in reverse binary format
' Zones are from e.g. 1-8, but it is stored in 87654321 order in binary format
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Private Sub DisplayZoneBin(sBin As Byte) As String

  Dim sTmp As String
  Dim sStr As String
  Dim iCount As Integer

  sTmp = Bin$(sBin, 8)

  For iCount = Len(sTmp) To 1 Step -1
    sStr &= Mid$(sTmp, iCount, 1)
  Next 

  Return sStr

End

'########################################################
  'Dim MSGV_DL_PINCODES As Byte[] = [&H3E, &HFA, &H01, &H10, &H00, &HB0, &H00, &H00, &H00, &H00, &H00] '&H3F
  ' TBD: if 0x10 -> 0x60 we see Master Installer & Installer & PowerLink pin
'########################################################

'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
' Arm or Disarm the PowerMax/Master
' Byte 3 must be one of the following commands:
' 0x00 Disarm
' 0x04 Arm home
' 0x05 Arm away
' 0x14 Arm home instantly
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Public Sub ArmDisarm(sMode As String)
  Dim bCommand As Byte[]

  bCommand = VMSG_ARMDISARM.Copy()
  
  SELECT CASE sMode
    CASE "Disarm"
      bCommand[3] = &H00
    CASE "ArmHome"
      bCommand[3] = &H04
    CASE "ArmAway"
      bCommand[3] = &H05
    CASE "ArmInstant"
      bCommand[3] = &H14
    CASE ELSE
      if $bDebug then Main.WriteDebugLog(LogLabel & "Error arming alarm, unknown arm command: " & sMode)
      return
  END SELECT
  
  ' Send the request, the pin will be added when the command is send
  QueueCommand(bCommand, "Disarm/Arm of the PowerMax/Master", &H00, "PIN:MasterCode:4")
  
End


'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
' Set the date & time on the PowerMax/Master
' Note: This seems to work only on the Powermax Pro and not on the Powermax Plus
' Byte 4 Minutes
' Byte 5 Hours (0-24)
' Byte 6 Day of month (1-31)
' Byte 7 Month (1-12)
' Byte 8 Year since 2000
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Public Sub SetDateTime()
  Dim bCommand As Byte[]
  Dim dNow As Date

  bCommand = VMSG_SET_DATETIME.Copy()
  
  dNow = Now()
  bCommand[4] = Minute(dNow)
  bCommand[5] = Hour(dNow)
  bCommand[6] = Day(dNow)
  bCommand[7] = Month(dNow)
  bCommand[8] = Year(dNow) - 2000
  
  ' Send the request, the pin will be added when the command is send
  QueueCommand(bCommand, "Set Date & Time on PowerMax/Master", &H00)
  
End



