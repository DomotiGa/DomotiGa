' Gambas class file

' Description:
' Mochad.class
' Provide support for Mochad.

' Development Status:
' Finished

' Links:
' http://sourceforge.net/apps/mediawiki/mochad/index.php?title=Main_Page

' DomotiGa - an open source home automation program.
' Copyright (C) Ron Klinkien, The Netherlands.

' This module is written by and Copyright(C) 2012 Roland van Hulzen.
' This class only support standard X10 but the mochad interface can do much more.

' Read file called COPYING for license details.

'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
' Module/Class specific variables
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Public PluginName As String = "Mochad"
Public PluginFriendlyName As String = "Mochad X10"
Public PluginVersion As String = "2.00"
Public PluginAuthor As String = "Roland van Hulzen"
Public PluginProtocols As String[]
Public PluginMaxInstances As Integer = 1

Public KeyName As String
Public LogLabel As String = "[Mochad] "
Public InterfaceId As Integer
Public Instance As Integer
Public IsRunning As Boolean
Public ErrorText As String
Public ErrorWhere As String

'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
' Private Variables
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Private $bEnabled As Boolean
Private $sTCPHost As String
Private $iTCPPort As String
Private $bDebug As Boolean
Private $bGlobalX10 As Boolean

' Interface objects
Public hMySocket As CSocket
Private $sMsgData As String
Private $sLastCommand As String

'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
' Mandatory subroutine for each Module/Class to initialize:
' - The cPlugin[x].Settings are copied into local variables
' - Port/Connection will be started (any errors caught)
' - Any other code per Class
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Public Sub StartPlugin(cPl As CPluginEntry)

  KeyName = cPl.KeyName
  Instance = cPl.Instance
  If Instance <> 1 Then LogLabel = Replace(LogLabel, "] ", "#" & Instance & "] ")

  ' Copy configuration items locally
  $bEnabled = cPl.Settings["enabled"]
  $sTCPHost = cPl.Settings["tcphost"]
  $iTCPPort = cPl.Settings["tcpport"]
  $bGlobalX10 = cPl.Settings["globalX10"]
  $bDebug = cPl.Settings["debug"]

  InterfaceId = Devices.FindInterface("Mochad Interface")
  If InterfaceId = 0 Then
    ErrorText = "Required InterfaceId can't be retrieved from the database!"
    WriteLog("ERROR: " & ErrorText)
    IsRunning = False
    Return
  Endif

  ' Connect/Initialize connection
  ConnectTCP()

End

'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
' Mandatory sub for each Module/Class to stop
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Public Sub StopPlugin()

  Try Disconnect()

End

'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
' Easy helper for WriteLog
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Private Sub WriteLog(sLog As String)

  Main.WriteLog(LogLabel & sLog)
  If $bDebug Then Main.WriteDebugLog(LogLabel & sLog)

End

'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
' Easy helper for WriteDebugLog
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Private Sub WriteDebugLog(sLog As String)

  If $bDebug Then Main.WriteDebugLog(LogLabel & sLog)

End

'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
' connect to the host:port
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Private Sub ConnectTCP()

  Dim iReconnectRetry As Integer = 0

  ' try to close the connection
  Try hMySocket.Close
  Try iReconnectRetry = hMySocket.ReconnectRetry

  ' get a new one - but also pass on our previous reconnect counter
  hMySocket = New CSocket(iReconnectRetry) As "MySocket"

  hMySocket.DataType = gb.String
  hMySocket.Connect($sTCPHost, $iTCPPort)

  WriteLog(PluginFriendlyName & " TCP interface connecting to " & $sTCPHost & ":" & $iTCPPort)

Catch ' some errors
  WriteLog("ERROR: " & PluginFriendlyName & " TCP interface FAILED to connect to " & $sTCPHost & ":" & $iTCPPort)
  WriteLog("ERROR: " & Error.Text)
  IsRunning = False
  ErrorText = Error.Text
  ErrorWhere = Error.Where

End

'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
' disconnect from the host
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Private Sub Disconnect()

  ' try to close the connection
  Try hMySocket.Close

  ' try stop running timers
  StopTimers()

  WriteLog(PluginFriendlyName & " TCP connection closed.")

Finally
  IsRunning = False
  ErrorText = ""
  ErrorWhere = ""

Catch
  WriteLog("ERROR: " & Error.Text)

End

'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
'
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Private Sub StopTimers()

End

'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
' Run after succesfull connect
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Private Sub Run()

  ' Empty internal buffer
  $sMsgData = ""

  hMySocket.Write("ASCI" & gb.Lf)

End

'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
' peer closed tcp socket
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Public Sub MySocket_Closed()

  WriteLog("ERROR: TCP socket closed by peer.")

  IsRunning = False
  ErrorText = "TCP socket closed by peer"

  StopTimers()

End

'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
' error while connected/connecting to tcp host
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Public Sub MySocket_Error(sMsg As String)

  WriteLog("ERROR: " & sMsg)

  IsRunning = False
  ErrorText = sMsg

  StopTimers()

End

'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
' host ip address found
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Public Sub MySocket_Found()

  Log.Plugin_DNS_Found(LogLabel, $sTCPHost)

End

'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
' tcp socket is connected
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Public Sub MySocket_Ready()

  WriteLog("TCP interface connected.")
  IsRunning = True

  Run()

End

'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
' Called when we should reconnect to the tcp host
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Public Sub MySocket_Reconnect()

  ConnectTCP()

End

'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
' received data from the tcp port. vVar is gb.String
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Public Sub MySocket_Read(vVar As Variant)

  $sMsgData &= vVar

  ' Check for linefeed and process data
  While InStr($sMsgData, gb.Lf)
    ProcessReceivedPacket(Mid($sMsgData, 1, InStr($sMsgData, gb.Lf) - 1), $sLastCommand)
    $sMsgData = Mid($sMsgData, InStr($sMsgData, gb.Lf) + 1)
  Wend

End

'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
' send generic command via tcp socket
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Public Sub SendCommand(sAddress As String, sValue As String)

  Dim sCmd As String
  Dim aDim As String[]
  Dim iDim As Integer
  Dim iDeviceId As Integer
  Dim rResult As Result

  iDeviceId = Devices.Find(1, sAddress, InterfaceId)
  rResult = Devices.GetDevicesAndValues(["device_id": iDeviceId, "inc_device_values": False])

  sCmd = "PL " & Left(sAddress, 1) & Val(Right(sAddress, 2)) & " "

  sValue = UCase(sValue)
  ' dimmer
  If InStr(sValue, "DIM ") And If rResult!device_extcode Then ' DIM 1 - 99
    aDim = Split(sValue, " ")
    If aDim.Count = 2 Then
      iDim = Val(aDim[1])
      If iDim > 0 Then iDim = Round(0.63 * iDim) ' 63 steps
      sCmd &= "xdim " & iDim
    Else
      sCmd &= sValue
    Endif
  ' shutter
  Else If sValue = "UP" Then
    sCmd &= "BRIGHT"
  Else If sValue = "DOWN" Then
    sCmd &= "DIM"
  ' else like switch
  Else
    sCmd &= sValue
  Endif

  If $bDebug Then WriteDebugLog("Send command: " & sCmd)

  ' Send command
  hMySocket.Write(sCmd & gb.Lf)

End

'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
'
'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Private Sub ProcessReceivedPacket(sStr As String, sLast As String)

  Dim sAddress, sType, sValue, sTamper, sBatt As String
  Dim aData, aType, aCmd As String[]
  Dim iDeviceId As Integer

  ' Don't continue if the string/packet is empty
  If Not sStr Then Return

  $sLastCommand = Null

  If InStr(sStr, "Raw data received:") = 0 Then
    If $bDebug Then WriteDebugLog("< " & sStr)
    Select Mid(sStr, 19, 2)
      Case "PL"

        ' mm/dd hh:mm:ss Rx PL HouseUnit: <H> Func: Ext code 1, data, control Data: <Xdims> Command: 31
        If InStr(sStr, " HouseUnit: ") Then
          aData = Scan(sStr, "* HouseUnit: *")
          If aData.Count = 2 Then
            $sLastCommand = aData[1]
            aData = Scan($sLastCommand, "* Func: Ext code 1, data, control Data: * Command: 31")
            If aData.Count = 2 Then
              sAddress = Left(aData[0], 1) & Format$(Mid$(aData[0], 2), "00")
              sValue = "Dim " & Round(Val("&H" & Mid(aData[1], 1, 2)) / 0.63)
              If $bDebug Then
                WriteDebugLog("Address = " & sAddress)
                WriteDebugLog("Command = " & sValue)
                WriteDebugLog("Type = X10")
              Endif
              UpdateX10(sAddress, sValue)
              Return
            Endif
          Else
            If $bDebug Then WriteDebugLog("Invalid data: " & sStr)
            Return
          Endif
        Endif

        ' mm/dd hh:mm:ss Rx PL House: <H> Func: All units off
        ' mm/dd hh:mm:ss Rx PL House: <H> Func: All lights On
        ' mm/dd hh:mm:ss Rx PL House: <H> Func: On
        ' mm/dd hh:mm:ss Rx PL House: <H> Func: Off
        ' mm/dd hh:mm:ss Rx PL House: <H> Func: Dim <Dims>
        ' mm/dd hh:mm:ss Rx PL House: <H> Func: Bright <Dims>
        ' mm/dd hh:mm:ss Rx PL House: <H> Func: All lights off 
        ' mm/dd hh:mm:ss Rx PL House: <H> Func: Status On
        ' mm/dd hh:mm:ss Rx PL House: <H> Func: Status off
        ' mm/dd hh:mm:ss Rx PL House: <H> Func: Status request
        If InStr(sStr, " House: ") Then 
          aData = Scan(sStr, "* House: * Func: *")
          If aData.Count = 3 Then
            If Left(sLast, 1) = aData[1] Then
              sAddress = Left(sLast, 1) & Format$(Mid$(sLast, 2), "00")
              sValue = aData[2]
              Select sValue
                Case "On", "Off"
                  If $bDebug Then
                    WriteDebugLog("Address = " & sAddress)
                    WriteDebugLog("Command = " & sValue)
                    WriteDebugLog("Type = X10")
                  Endif
                  UpdateX10(sAddress, sValue)
                Case Else
                  If $bDebug Then WriteDebugLog("Unsupported command: " & aData[2])
                  Return
              End Select
            Else
              If $bDebug Then WriteDebugLog("Invalid data: " & sStr)
              Return
            Endif
          Else
            If $bDebug Then WriteDebugLog("Invalid data: " & sStr)
            Return
          Endif
        Endif

      Case "RF"
        ' mm/dd hh:mm:ss Rx RF House: <H><U> Func: On
        ' mm/dd hh:mm:ss Rx RF House: <H><U> Func: Off
        ' mm/dd hh:mm:ss Rx RF House: <H><U> Func: Dim
        ' mm/dd hh:mm:ss Rx RF House: <H><U> Func: Bright

        ' mm/dd hh:mm:ss Rx RF HouseUnit: <H><U> Func: On
        ' mm/dd hh:mm:ss Rx RF HouseUnit: <H><U> Func: Off

        ' mm/dd hh:mm:ss Rx RFSEC Addr: <Secaddr8> Func: Arm_Home_min_SH624
        ' mm/dd hh:mm:ss Rx RFSEC Addr: <Secaddr8> Func: Arm_Away_min_SH624
        ' mm/dd hh:mm:ss Rx RFSEC Addr: <Secaddr8> Func: Arm_Home_max_SH624
        ' mm/dd hh:mm:ss Rx RFSEC Addr: <Secaddr8> Func: Arm_Away_max_SH624
        ' mm/dd hh:mm:ss Rx RFSEC Addr: <Secaddr8> Func: Disarm_SH624
        ' mm/dd hh:mm:ss Rx RFSEC Addr: <Secaddr8> Func: Panic_SH624
        ' mm/dd hh:mm:ss Rx RFSEC Addr: <Secaddr8> Func: Lights_On_SH624
        ' mm/dd hh:mm:ss Rx RFSEC Addr: <Secaddr8> Func: Lights_Off_SH624

        ' mm/dd hh:mm:ss Rx RFSEC Addr: <Secaddr17> Func: Motion_alert_MS10A
        ' mm/dd hh:mm:ss Rx RFSEC Addr: <Secaddr17> Func: Motion_normal_MS10A
        ' mm/dd hh:mm:ss Rx RFSEC Addr: <Secaddr17> Func: Contact_alert_min_DS10A
        ' mm/dd hh:mm:ss Rx RFSEC Addr: <Secaddr17> Func: Contact_normal_min_DS10A
        ' mm/dd hh:mm:ss Rx RFSEC Addr: <Secaddr17> Func: Contact_alert_max_DS10A
        ' mm/dd hh:mm:ss Rx RFSEC Addr: <Secaddr17> Func: Contact_normal_max_DS10A
        ' mm/dd hh:mm:ss Rx RFSEC Addr: <Secaddr17> Func: Contact_alert_min_low_DS10A
        ' mm/dd hh:mm:ss Rx RFSEC Addr: <Secaddr17> Func: Contact_normal_min_low_DS10A
        ' mm/dd hh:mm:ss Rx RFSEC Addr: <Secaddr17> Func: Contact_alert_max_low_DS10A
        ' mm/dd hh:mm:ss Rx RFSEC Addr: <Secaddr17> Func: Contact_normal_max_low_DS10A
        ' mm/dd hh:mm:ss Rx RFSEC Addr: <Secaddr17> Func: Arm_KR10A
        ' mm/dd hh:mm:ss Rx RFSEC Addr: <Secaddr17> Func: Disarm_KR10A
        ' mm/dd hh:mm:ss Rx RFSEC Addr: <Secaddr17> Func: Lights_On_KR10A
        ' mm/dd hh:mm:ss Rx RFSEC Addr: <Secaddr17> Func: Lights_Off_KR10A
        ' mm/dd hh:mm:ss Rx RFSEC Addr: <Secaddr17> Func: Panic_KR10A
        aData = Scan(sStr, "* Rx RFSEC Addr: * Func: *")
        If aData.Count = 3 Then
          sAddress = "x10sec 0x" & Lower(Replace(aData[1], ":", ""))
          If aData[2] = "(null)" Then Return
          aType = Scan(aData[2], "*_*")
          If aType.Count = 2 Then
          Select aType[0]
            Case "Motion"
              sType = "MOTION"
              aCmd = Scan(aType[1], "*_*")
              If aCmd.Count = 2 Then
                sValue = IIf(aCmd[0] = "alert", "Motion", "No Motion")
              Endif
            Case "Contact"
              sType = "DWS"
              aCmd = Scan(aType[1], "*_*_*")
              If aCmd.Count = 3 Then
                sValue = IIf(aCmd[0] = "alert", "Alert", "Normal")
                sTamper = IIf(aCmd[1] = "min", "Secure", "Tamper")
                sBatt = "Low"
              Else
                aCmd = Scan(aType[1], "*_*")
                If aCmd.Count = 2 Then
                  sValue = IIf(aCmd[0] = "alert", "Alert", "Normal")
                  sTamper = IIf(aCmd[1] = "min", "Secure", "Tamper")
                  sBatt = "Ok"
                Endif
              Endif
            Case "Arm"
              sType = "REMOTE"
              aCmd = Scan(aType[1], "*_*_*")
              If aCmd.Count = 3 Then
                sValue = aCmd[0]
                sTamper = IIf(aCmd[1] = "min", "Secure", "Tamper")
              Else
                sValue = aType[0]
              Endif
            Case "Disarm", "Panic"
              sType = "REMOTE"
              sValue = aType[0]
            Case "Lights"
              sType = "REMOTE"
              aCmd = Scan(aType[1], "*_*")
              If aCmd.Count = 2 Then
                sValue = "Lights " & aCmd[0]
              Endif
            Case Else
              If $bDebug Then WriteDebugLog("Unknown device type: " & aData[1])
          End Select
        Else
          If $bDebug Then WriteDebugLog("Invalid command data: " & aData[2])
        Endif
      Else
        If $bDebug Then WriteDebugLog("Invalid data: " & sStr)
      Endif
      If $bDebug Then
        WriteDebugLog("Address = " & sAddress)
        WriteDebugLog("Command = " & sValue)
        WriteDebugLog("Type = " & sType)
        WriteDebugLog("Battery level = " & sBatt)
        WriteDebugLog("Tamper = " & sTamper)
      Endif

      If Not sAddress Then 
        If $bDebug Then WriteDebugLog("Invalid address")
        Return
      Endif

      iDeviceId = Devices.Find(Instance, sAddress, InterfaceId, sType)
      ' update value & battery status
      If iDeviceId Then
        Devices.ValueUpdate(iDeviceId, 1, sValue)
        Devices.ValueUpdate(iDeviceId, 2, sTamper)
        If Len(sBatt) Then Devices.Battery(iDeviceId, sBatt)
      Endif
    End Select
  Endif

Catch
   WriteDebugLog("Error while Parsing: '" & Error.Text & "' at '" & Error.Where & "'")

End

Private Sub UpdateX10(sCode As String, sCommand As String)

  Dim iDeviceId As Integer

  If $bDebug Then WriteDebugLog("Received command '" & sCommand & "' for device '" & sCode & "'")

  If $bGlobalX10 Then
    iDeviceId = Devices.FindAll(Instance, sCode, 9999, "X10")
  Else
    iDeviceId = Devices.Find(Instance, sCode, InterfaceId, "X10")
  Endif
  If iDeviceId Then Devices.ValueUpdate(iDeviceId, 1, sCommand)

End

